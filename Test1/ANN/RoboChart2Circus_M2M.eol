/*this section need to be part of the transformation*/


//for(stm in RC!StateMachineDef.all().at(0)){
//	//var name = RC!StateMachineDef.all().at(0).name + "_" + n.name + "proc";
//	stm.nodes.composedNodes();
//
//}


RC.println();
//removeRef();

var p = RC!RCPackage.all();
p.println();
p.eContents.println();
var nc = RC!StateMachineDef.all().at(0);



RC!StateMachine.all().println();



//nc.FQN().println();

//nc.createTransitionsAsCircusProcess();
//var nodes = RC!StateMachineDef.all().at(0).nodes;
//nodes.println();
//composedNodes(nodes).createRenameProcess(Sequence{"share"},Sequence{"share", "setL_a"});
//ncCoreBehaviour(nc);
ncBehaviour(nc);
//
//
var zsect = createZSect("circus_theory", Sequence{}, Sequence{"Boolean_operators"});
	
//Set{}.createChannelPara("channel_group1").addChan2ChanPara("channel1");
//Set{"share", "share1", "share2"}.createChannelPara("channel_group1").addChan2ChanPara("share3");
//Set{"share4", "share5"}.createChannelPara("channel_group1","int");


//nc.createInternalChanParaNC();
//
for(p in Z!Para.all().select(p|p.instanceOf(Z!ChannelSetPara) or p.instanceOf(Z!ChannelPara) or p.instanceOf(Z!ProcessPara) or p.instanceOf(Z!FreePara) )){
	zsect.addPara2ZSect(p);	
}
//
createSpec(zsect);
"line 49".println();
RC!StateMachineDef.all().println();
RC!StateMachineDef.all().at(0).nodes.println();

for(n in RC!StateMachineDef.all().at(0).nodes.select(s|s.name = "s3")){
	"line3".println();
	usedVariables(n.actions.at(0).action).println();
	nc(n.actions.at(0).action).println();
	"line5".println();
	
	if(n.eClass().name = "State" and n.name = "s3"){
		
//		n.createStateActionAsCircusAction("DuringAction");
		//n.actions.at(0).action.createStmtInContextAsAction();
		usedVariables(n.actions.at(0).action).println();
		nc(n.actions.at(0).action).println();
		"line5".println();
		//set1.at(0).type().println();

	}
}

//RC!StateMachineDef.all().println();
//This is only used for M2T validation of ApplExpr
for(n in nc.nodes.select(s|s.name = "s3")){
	("n.name = "+ n.name).println();
	var expr = n.actions.at(0).action.right.createExpr();
	createApplExprList(Sequence{expr});
	
}

//This is only used for M2T validation of createPredList
for (t in nc.transitions.select(t|t.name = "t1")){
	if(t.condition != null){
		var pred = t.condition.createExpr().createMemPredEquality();
//		circusAction = createGuardedAction(pred, circusAction);
		createPredList(Sequence{pred});
	} 
}



//This is only used for M2T validation of ApplExpr
operation createApplExprList(exprSeq: Sequence<Z!ApplExpr>): Z!CApplExprList{
	var aeList = new Z!CApplExprList;
	aeList.applExprs = exprSeq;
	return aeList;
}

//This is only used for M2T validation of Pred
operation createPredList(predSeq: Sequence<Z!Pred>): Z!CPredList{
	var predList = new Z!CPredList;
	predList.preds = predSeq;
	return predList;
}

//for(n in RC!StateMachineDef.all().at(1).nodes){
//
//	if (n.eClass().name = "State" and n.name = "s3"){
//		RC!StateMachineDef.all().at(1).println();
//		for(nc in RC!StateMachineDef.all()){
//			if(nc.nodes.includes(n)){
//				("the node container of this state: " + nc.name).println();
//			} 
		
//	}
//		"line53".println();
//		n.actions.at(0).action.right.createExpr();
//		//To create Minus
//		if(n.actions.at(0).action.right.type().name = "Minus"){
//			"so we shall create an ApplExpr.".println();
//			n.actions.at(0).action.right.createExpr();
//		}
//		
//		
//	}
//}

//for (t in RC!StateMachineDef.all().at(1).transitions){
//	if(t.name = "t1"){
//	RC!StateMachineDef.all().at(1).println();
//		for(nc in RC!StateMachineDef.all()){
//			if(nc.transitions.includes(t)){
//				("the node container of this transition: " + nc.name).println();
//			} 
//		}
//	}
//
//}

//RC!StateMachineDef.all().at(0).createTransitionsAsCircusProcess();



//for(n in RC!StateMachineDef.all().at(0).nodes){
//	if(n.eClass().name = "State" and n.name = "s2"){
//		"line3".println();
//		var set1 = usedVariables(n.actions.at(1).action);
//		set1.println();
//		"line5".println();
//		set1.at(0).type().println();
//
//	}
//}


//var ta;
//for (t in RC!StateMachineDef.all().at(0).transitions){
//	if(t.name = "t3"){
//		ta = t.createTransitionAsCircusAction();
//	"line162".println();
//	ta.type().println();
//	
//	}
//
//}

//for(n in RC!StateMachineDef.all().at(0).nodes){
//	if(n.eClass().name = "State" and n.name = "s4"){
//		"line3".println();
//		n.actions.at(1).println();
//		n.actions.at(1).action.println();
//		var set1 = usedVariables(n.actions.at(1).action);
//		set1.println();
//		"line5".println();
//		set1.type().println();
//				//readState(set1,"SSTOP".createCallAction());
//	}
//}
	
//for(n in RC!StateMachineDef.all().at(0).nodes){
//	if(n.eClass().name = "State" and n.name = "s3"){
//		"line11".println();
//		usedVariables(n.actions.at(0).action).println();
//		"line13".println();
//	}
//}



operation removeRef(){

	for(stmr in RC!StateMachineRef.all()){
	
		var stm_new = new RC!StateMachineDef;
		stm_new = clone(stmr.ref);
		stm_new.name = stmr.name;
	 		
	 	ctl(stmr).machines.add(stm_new);
	 	ctl(stmr).machines.remove(stmr);
//	 	delete stmr;
		
	}

	for(ctlr in RC!ControllerRef.all()){

		var ctl_new = new RC!ControllerDef;
		ctl_new = clone(ctl.ref);
		ctl_new.name = ctlr.name;
	 		
	 	module(ctlr).nodes.add(ctl_new);
	 	module(ctlr).nodes.remove(ctlr);
//	 	delete ctlr;
		
	}
	return RC;
}

operation ctl(stmr: RC!StateMachineRef): RC!ControllerDef{
	for(ctl in RC!ControllerDef.all()){
		if(ctl.machines.includes(stmr)){
			return ctl;
		}
	}
}

operation module(ctlr: RC!ControllerRef): RC!RCModule{
	for(module in RC!RCModule.all()){
		if(module.nodes.includes(ctlr)){
			return module;
		}
	}
}
//Spec is the root element of the generated Circus model, it contains a narrative section and a ZSection
operation createSpec(zsect: Z!ZSect): Z!Spec{
	var spec = new Z!Spec;
	var narrativeSect = new Z!NarrSect;
//	var zSect = new Z!ZSect;
//	zSect =  zsect;
	spec.sects = Sequence{narrativeSect, zsect};
	return spec;
}


operation createZSect(
	sect_name: String,
	paraSeq: Sequence<Z!Para>,
	parentNameSeq: Sequence<String>
	): Z!ZSect{
	
	var zsect = new Z!ZSect;
	zsect.name = sect_name;
	
	zsect.paraList = new Z!ZParaList;
	zsect.paraList.paras = paraSeq;
	
	zsect.parents = createParentList(parentNameSeq);
	
	return zsect;
}

//used in createZSect
operation createParentList(parentNameSeq: Sequence<String>): Sequence<Z!Parent>{
	var parents = Sequence<Z!Parent>;
	parents = Sequence{};
	for(p in parentNameSeq){
		parents.add(createParent(p));
	}
	return parents;
}

operation createParent(p: String): Z!Parent{
	var parent = new Z!Parent;
	parent.word = p;
	return parent;
}

operation Z!ZSect addPara2ZSect(para: Z!Para): Z!ZSect{
	var zsect =  self;
		
	zsect.paraList.paras.add(para);
	("line 193 is executed: self.paraList.paras = " + self.paraList.paras).println();
	return zsect;

}

//used to create NIDS enumeration typePara
operation Z!Freetype createEnumTypePara(): Z!FreePara{
	var freePara = new Z!FreePara;
	freePara.freetypeList =  new Z!ZFreetypeList;
	freePara.freetypeList.freeTypes.add(self);
	
	return freePara;
}


//to create enumeration type to be used for channels, e.g., channel internal__: NIDS, where NIDS is a enumeration type
operation createEnumType(
	name: String, 
	str_seq: Sequence<String>
	): Z!Freetype{
	
	var enumType = new Z!Freetype;
	enumType.name = name.createZName();
	
	var branchList = new Z!ZBranchList;
	for(elm in str_seq){
		branchList.branches.add(elm.createBranch());
	}
	enumType.branchList = branchList;
	
	return enumType;
}


//used in createEnumType
operation String createBranch(): Z!Branch{
	var branch = new Z!Branch;
	branch.name = self.createZName();
	return branch;
	//branch.expr = null;
}

//Fully Qualified Name for Node
operation RC!Node FQN(): String{
	var  stm_sets = RC!StateMachineDef.all();
	"line 13".println();
	stm_sets.println();
	
	//Case 1: the node is contained in a stm
	for(stm in stm_sets){
		if(stm.nodes.includes(self)){
			return self.name+"_"+ stm.FQN();
		}
	}
	
	//Case 2: the node is contained in a composite node
	for(nd in RC_model!Node.all()){
		if(nd.nodes.size>0){
			if(nd.nodes.includes(self)){
				return self.name+"_"+ nd.FQN();
			}
		}
	}	
}


//Fully Qualified Name for events
operation RC!Event FQN(): String{
	var  stm_sets = RC!StateMachineDef.all();
	"line 13".println();
	stm_sets.println();
	
	//Case 1: the event is contained in a stmdef
	for(stm in stm_sets){
		if(stm.events.includes(self)){
			return self.name+"_"+ stm.FQN();
		}
	}
	
	//Case 2: the node is contained in a controllerdef node
	for(ctl in RC!ControllerDef.all()){
		if(ctl.events.includes(self)){
			return self.name + "_" + ctl.FQN();
		}
	}	
}



//Fully Qualified Name for StateMachineDef
operation RC!StateMachineDef FQN(): String{

	//Case 1: the stm is contained in a controllerdef
	for(ctl in RC!ControllerDef.all()){
		if(ctl.machines.includes(self)){
			return self.name + "_" + ctl.FQN();
		}
	}
	
	//Case 2: the stm is contained in a package
	for(pkg in RC!RCPackage.all()){
		if(pkg.machines.includes(self)){
			if(pkg.name.isDefined()){
				return self.name + "_" + pkg.name;			
			}else{
				return self.name;	
			}
		}
	}	
	
	//a module can not have a stm outside a controller
}


//Fully Qualified Name for ControllerDef
operation RC!ControllerDef FQN(): String{
	//Case 1: the controller is contained in a module
	for(md in RC!RCModule.all()){
		if(md.nodes.includes(self)){
			return self.name + "_" + md.FQN();
		}
	}
	
	//Case 2: the controller is contained in a package
	for(pkg in RC!RCPackage.all()){
		if(pkg.controllers.includes(self)){
			if(pkg.name.isDefined()){
				return self.name + "_" + pkg.name;			
			}else{
				return self.name;	
			}
		}
	}
}

// Fully Qualified Name for RCModule
operation RC!RCModule FQN(): String{

	//Case 1: the module is contained in a package
	for(pkg in RC!RCPackage.all()){
		if(pkg.modules.includes(self)){
			if(pkg.name.isDefined()){
				return self.name + "_" + pkg.name;			
			}else{
				return self.name;	
			}
		}
	}		
}



////Fully Qualified Name for Node
//operation RC!Node FQN(RC_model: Any): String{
//	var  stm_sets = RC_model!StateMachineDef.all();
//	"line 13".println();
//	stm_sets.println();
//	
//	//Case 1: the node is contained in a stm
//	for(stm in stm_sets){
//		if(stm.nodes.includes(self)){
//			return self.name+"_"+ stm.FQN(RC_model);
//		}
//	}
//	
//	//Case 2: the node is contained in a composite node
//	for(nd in RC_model!Node.all()){
//		if(nd.nodes.size>0){
//			if(nd.nodes.includes(self)){
//				return self.name+"_"+ nd.FQN(RC_model);
//			}
//		}
//	}	
//}
//
//
//
//
//
////Fully Qualified Name for events
//operation RC!Event FQN(RC_model: Any): String{
//	var  stm_sets = RC_model!StateMachineDef.all();
//	"line 13".println();
//	stm_sets.println();
//	
//	//Case 1: the event is contained in a stmdef
//	for(stm in stm_sets){
//		if(stm.events.includes(self)){
//			return self.name+"_"+ stm.FQN(RC_model);
//		}
//	}
//	
//	//Case 2: the node is contained in a controllerdef node
//	for(ctl in RC_model!ControllerDef.all()){
//		if(ctl.events.includes(self)){
//			return self.name + "_" + ctl.FQN(RC_model);
//		}
//	}	
//}
//
//
//
//
////Fully Qualified Name for StateMachineDef
//operation RC!StateMachineDef FQN(RC_model: Any): String{
//
//	//Case 1: the stm is contained in a controllerdef
//	for(ctl in RC_model!ControllerDef.all()){
//		if(ctl.machines.includes(self)){
//			return self.name + "_" + ctl.FQN(RC_model);
//		}
//	}
//	
//	//Case 2: the stm is contained in a package
//	for(pkg in RC_model!RCPackage.all()){
//		if(pkg.machines.includes(self)){
//			if(pkg.name.isDefined()){
//				return self.name + "_" + pkg.name;			
//			}else{
//				return self.name;	
//			}
//		}
//	}	
//	
//	//a module can not have a stm outside a controller
//}
//
//
////Fully Qualified Name for ControllerDef
//operation RC!ControllerDef FQN(RC_model: Any): String{
//	//Case 1: the controller is contained in a module
//	for(md in RC_model!RCModule.all()){
//		if(md.nodes.includes(self)){
//			return self.name + "_" + md.FQN(RC_model);
//		}
//	}
//	
//	//Case 2: the controller is contained in a package
//	for(pkg in RC_model!RCPackage.all()){
//		if(pkg.controllers.includes(self)){
//			if(pkg.name.isDefined()){
//				return self.name + "_" + pkg.name;			
//			}else{
//				return self.name;	
//			}
//		}
//	}
//}
//
////Fully Qualified Name for RCModule
//operation RC!RCModule FQN(RC_model: Any): String{
//
//	//Case 1: the module is contained in a package
//	for(pkg in RC_model!RCPackage.all()){
//		if(pkg.modules.includes(self)){
//			if(pkg.name.isDefined()){
//				return self.name + "_" + pkg.name;			
//			}else{
//				return self.name;	
//			}
//		}
//	}		
//}







//channel decleration and channelset declaration for node container (NC)
operation RC!NodeContainer createchanParaNC()  {
	
	//1. channel internal__: NIDS
//	var internal_chanpara = createChannelPara("internal_chan_" + self.FQN());
	
	var NID_node_seq = Sequence<String>;
	NID_node_seq = Sequence{};
		
	for(n in self.nodes){
		NID_node_seq.add("NID_" + n.FQN());
	}
	
	//CSPM: datatype NIDS = NID_i0 | NID_s0 | ...
	var NIDS = createEnumType("NIDS_"+self.FQN(), NID_node_seq);
	
	var NIDS_para = NIDS.createEnumTypePara();
	
	//CSPM: channel internal__:NIDS
	var internal_chanpara = Sequence{"internal__"+self.FQN()}.createChannelPara("internal_chan_" + self.FQN(), NIDS.name.word);
	
//	for(n in self.nodes){
//		node_seq.add("internal__NID_" + n.FQN());
//	}
	//	var internal_chanpara = node_seq.createChannelPara("internal_chan_" + self.FQN());
	
	

	
	//2. Flow channel: interrupt, exited, exit, terminate
	var flow_chanpara = Sequence{"interrupt_"+self.FQN(), "exited_"+self.FQN(), "exit_"+self.FQN(), "terminate"}.createChannelPara("flowchan_" + self.FQN());
	// should be updated to "interrupt".FQN(self)


	//3. variable channels, each var has a channel declaration, as vars can have different types, while the channels in the chandecl.list should have the same type.
	
	var var_chanpara = createChannelPara("variable_chan_" + self.FQN());
	for(vl in self.variableList){
		if(vl.modifier = RC!VariableModifier#VAR){
//			var i=0;
			for(v in vl.vars){
				
				var type_expr = v.type.createTypeExpr();
				
				var var_seq = Sequence{"get_" + v.name + "_" + self.FQN(), 
									   "set_" + v.name + "_" + self.FQN(), 
									   "setL_" + v.name + "_" + self.FQN(), 
									   "setR_" + v.name + "_" + self.FQN()};
									   
				var_chanpara.declList.decls.add(var_seq.createChannelDecl(type_expr));
				
				
//				var_chanpara.declList.decls.at(i).addChan2ChanDecl("get_" + v.FQN(), type_expr);
//				var_chanpara.declList.decls.at(i).addChan2ChanDecl("set_" + v.FQN(), type_expr);
//				var_chanpara.declList.decls.at(i).addChan2ChanDecl("setL_" + v.FQN(), type_expr);
//				var_chanpara.declList.decls.at(i).addChan2ChanDecl("setR_" + v.FQN(), type_expr);
//				i++;
			}
		}
	}
	
	
	//4. Shared variable channels
	//TO DO
	
	
	//5. Local variable channels for defined operations that are required by the state machine
	//TO DO
	
	
	//6. Declaring state machine events as channels

	var evt_chanpara = createChannelPara("event_chan_" + self.FQN());
	
	//Case 1: to create the type for the state machine event channels (external), 
	//e.g., CSPM: trigger1:InOut.core_int;   NIDS is not involved.
	//Circus: trigger1_in ::int, trigger1_out ::int
	for(e in self.events){
				
		var evt_seq = Sequence{e.FQN() + "_in", //CSPM InOut enumtype is removed for Circus, so becomes 2 channels
							   e.FQN() + "_out"};
									   
		if(e.type=null){
			evt_chanpara.declList.decls.add(evt_seq.createChannelDecl());	
		}else{
			var type_expr = e.type.createTypeExpr();
			evt_chanpara.declList.decls.add(evt_seq.createChannelDecl(type_expr));
		}
	}
	
	//Case 2: to generate channels for the events to be used as transition triggers
	//e.g., CSPM: trigger1__:NIDS.InOut.core_int
	//Circus: trigger1_stm0_pkg0__in :: NIDS x int
	for(e in self.events){
		var evt_seq = Sequence{e.FQN() + "__in"//,
							 //e.FQN() + "__out" , this is removed because the out channel is not necessary, as e.NIDS channel is only used for transition triggers, and a trigger can only be an input.
							   };	
							   	
		if(e.type=null){
			evt_chanpara.declList.decls.add(evt_seq.createChannelDecl(NIDS.name.word));	
		}else{
			var type_expr = e.type.createTypeExpr();
			
			//to create the PRODUCT type for the state machine event channels (internal), 
			//e.g., CSPM: trigger1__:NIDS.InOut.core_int
			type_expr = createProdExpr(type_expr, NIDS.name.word.createTypeExpr());					   
			evt_chanpara.declList.decls.add(evt_seq.createChannelDecl(type_expr));
		}
	}
	
	//7. Declaring call and ret events for undefined operations as channels
	//TO DO
	
	
	//8. Declaring local channels for each node in the node container
	//shall these local ones be declared in state semantics?
	for(n in self.nodes){
		if(n.instanceOf(RC!Junction)){
			var junc_chan = Sequence{"enter_"+ n.FQN(),
									 "interrupt_"+ n.FQN()}.createChannelPara("junc_chan_" + n.FQN());
		} else{
			var st_chan = Sequence{"enter_"+ n.FQN(),
								   "entered_"+ n.FQN(),
								   "interrupt_"+ n.FQN(),
								   "enteredL_"+ n.FQN(),
								   "enteredR_"+ n.FQN()}.createChannelPara("st_chan_" + n.FQN());
		}
	}
	
	
	//9. Declaring NC channelsets: enterSS, enteredSS, internal_events, shared_variable_events, sem__events
	
	//enterSS
	var enterSSchannelset = createChannelSet(createBasicChannelSetExpr(enterSS(self)));
	var enterSSchannelsetPara = enterSSchannelset.createChanSetPara("enterSS_"+self.FQN());
	
	//enteredSS
	var enteredSSchannelset = createChannelSet(createBasicChannelSetExpr(enteredSS(self)));
	var enteredSSchannelsetPara = enteredSSchannelset.createChanSetPara("enteredSS_"+self.FQN());
	
	
	//internal_events
	var internal_stringset = enterSS(self).includingAll(enteredSS(self)).includingAll(Sequence{"interrupt_"+self.FQN(), "exited_"+self.FQN()});
	var internal_events_channelset = createChannelSet(createBasicChannelSetExpr(internal_stringset));
	var internal_events_channelsetPara = internal_events_channelset.createChanSetPara("internal_events_"+self.FQN());
	
	
	//shared_variable_events
	//TO DO
	
	
	//sem__events
	//Shall terminate be FQN? No
	var sem__events_stringset = Sequence{"terminate"};
	
	for(e in self.events){				
		sem__events_stringset.add(e.FQN() + "_in");
		sem__events_stringset.add(e.FQN() + "_out");
	}
		
	var sem__events_channelset = createChannelSet(createBasicChannelSetExpr(sem__events_stringset));
	var sem__events_channelsetPara = sem__events_channelset.createChanSetPara("sem__events_"+self.FQN());
	
	//10. Declaring State Local channelsets: enterSS_s0, enteredSS_s0, etc
	//shall these local ones be declared in state semantics?
	
}

 


//this is used for variable channel decleration, only RefType and ProductType are considered for variable's type
operation RC!Type createTypeExpr(): Z!Expr{
	if(self.isTypeOf(ProductType)){
		return self.createProdExpr();
	} else  {  
		return self.ref.name.createRefExpr(false, false);
	}
}
  
//this is used for variable channel decleration, a RefType is generated from the name of the enumeration type, e.g., NIDS
operation String createTypeExpr(): Z!Expr{
	return self.createRefExpr(false, false);
}

operation RC!ProductType createProdExpr(): Z!ProdExpr{
	var prodexpr = new 	Z!ProdExpr;
	prodexpr.exprList = new Z!ZExprList;
 	for(t in self.types){
 		prodexpr.exprList.exprs.add(t.createTypeExpr());
 	}
 	
 	return prodexpr;
}

operation createProdExpr(exp1: Z!Expr, exp2:Z!Expr): Z!ProdExpr{
	var prodexpr = new 	Z!ProdExpr;
	prodexpr.exprList = new Z!ZExprList;
	prodexpr.exprList.exprs = Sequence{exp1,exp2};
	
 	return prodexpr;
}


//to create an empty channelPara with a para name with the decl not defined and the type not identified
operation createChannelPara(
	para_name: String
	): Z!ChannelPara{
	var chanDeclPara = new Z!ChannelPara;
	chanDeclPara.declList = new Z!ZDeclList;
	
//	var decl = Set{}.createChannelDecl();
//	chanDeclPara.declList.decls = Sequence{decl};
	
	chanDeclPara.declList.decls = Sequence{};
	chanDeclPara.name = para_name.createZName();
	
	return chanDeclPara;
}





//type indicate the type of the channel, or is sync if is uptyped
operation Sequence<String> createChannelPara(
	para_name: String,
	type: String
	): Z!ChannelPara{
	var chanDeclPara = new Z!ChannelPara;
	chanDeclPara.declList = new Z!ZDeclList;
	
	var decl = self.createChannelDecl(type);
	chanDeclPara.declList.decls = Sequence{};
	chanDeclPara.declList.decls.add(decl);

	chanDeclPara.name = para_name.createZName();
	
	return chanDeclPara;
}

operation Sequence<String> createChannelPara(
	para_name: String
	): Z!ChannelPara{
	var chanDeclPara = new Z!ChannelPara;
	
	chanDeclPara.declList = new Z!ZDeclList;
	
	var decl = self.createChannelDecl();
	chanDeclPara.declList.decls = Sequence{decl};
		
	chanDeclPara.name = para_name.createZName();
	return chanDeclPara;
}

/*
operation Z!ChannelPara addChan2ChanPara(
	chan_name: String, 
	chan_type: String
	): Z!ChannelPara{
	

	self.declList.decls.at(0).addChannelDecl(chan_name, chan_type);
	return self;
}

operation Z!ChannelPara addChan2ChanPara(
	chan_name: String, 
	chan_type: Z!Expr
	): Z!ChannelPara{
	self.declList.decls.at(0).addChannelDecl(chan_name, chan_type);
	return self;
}
operation Z!ChannelPara addChan2ChanPara(
	chan_name: String
	): Z!ChannelPara{
	self.declList.decls.at(0).addChannelDecl(chan_name);
	return self;
}
*/

operation Sequence<String> createChannelDecl(): Z!ChannelDecl{
	var decl = new 	Z!ChannelDecl;
	
	//The first element is the (possibly empty) list of generic formal parameters
//	var fst_list = createNameList(Set{});
	decl.genFormals = createNameList(Sequence{});
	
	//the second element is the (possibly empty) list of declared channel names
//	var snd_list = createNameList(self);
	decl.channelNameList = createNameList(self);
	
	//expr attr indicate the type of the channel, and it's a RefExpr
	//if it's untyped, type = "SYNCH"
	if(self.size()>0){
		decl.expr = "SYNCH".createRefExpr(false, false);
	} else{
		//self.size() = 0 means this is an empty channel decl, so no type is identified.
	}
	
	
	return decl;
}


operation Sequence<String> createChannelDecl(type: String): Z!ChannelDecl{
	var decl = new 	Z!ChannelDecl;
	
	//The first element genFormals is the (possibly empty) list of generic formal parameters
	decl.genFormals = createNameList(Sequence{});
	
	//the second element is the (possibly empty) list of declared channel names
	decl.channelNameList = createNameList(self);

	//expr attr indicate the type of the channel, and it's a RefExpr
	//if it's untyped, type = "SYNCH"
	decl.expr = type.createRefExpr(false, false);
	
	return decl;
}

operation Sequence<String> createChannelDecl(type_expr: Z!Expr): Z!ChannelDecl{
	var decl = new 	Z!ChannelDecl;
	
	//The first element genFormals is the (possibly empty) list of generic formal parameters
	decl.genFormals = createNameList(Sequence{});
	
	//the second element is the (possibly empty) list of declared channel names
	decl.channelNameList = createNameList(self);

	//expr attr indicate the type of the channel, and it's a RefExpr
	//if it's untyped, type = "SYNCH"
	decl.expr = type_expr;
	
	return decl;
}




//CSP Rule 40

operation ncBehaviour(nc:RC!NodeContainer): Z!ProcessPara{
	nc.createchanParaNC(); // HERE is the place to declare all the channels for a state machine
	var hideset_string = enterSS(nc).includingAll(Sequence{"exit_" + nc.FQN(), "exited_" + nc.FQN(), "internal__"+nc.FQN()});
	
	var hidechannelset = createChannelSet(createBasicChannelSetExpr(hideset_string));
	var hidechannelsetPara = hidechannelset.createChanSetPara("ncCoreBeh_hideset_"+nc.FQN());
//	var ncBehaviourProc = ncCoreBehaviour(nc).createHideProcess(hideset_string).createRenameProcess(renameTriggerEventsPairL(nc), renameTriggerEventsPairR(nc));


	var ncBehaviourProc = ncCoreBehaviour(nc).createHideProcess(hidechannelsetPara.name.word).createRenameProcess(renameTriggerEventsPairL(nc), renameTriggerEventsPairR(nc));
	//TO DO: need to confirm the M2T part
	
//	var ncBehaviourProc = ncCoreBehaviour(nc).createHideProcess(hidechannelset).createRenameProcess(renameTriggerEventsPairL(nc), renameTriggerEventsPairR(nc));
	
	("line 175, renameTriggerEventsPairL(nc) = " + renameTriggerEventsPairL(nc)).println();
	var ncBehaviourProcPara =  ncBehaviourProc.createProcessPara("ncBehaviourProc_"+nc.FQN(), true);

	return ncBehaviourProcPara;
}




//CSP Rule 41
operation ncCoreBehaviour(nc:RC!NodeContainer): Z!CircusProcess{

	
	/***************start of tidsR(nc) calculation************************/
	
	//tidsR(nc) renaming is implemented as transitions renaming and nodes renaming 
	//firstly, to calculate the renaming pair for the transitions
	var tidsR_trans_pairL = new Sequence<String>;
	for(t in nc.transitions){
		tidsR_trans_pairL.add("interrupt_"+t.source.FQN());
	}
	var tidsR_trans_pairR = new Sequence<String>;
	for(t in nc.transitions){
//		tidsR_trans_pairR.add(tevent(t,nc.name));
		tidsR_trans_pairR.add(tevent_str(t));
	} 
	

	//Secondly, to calculate the renaming pair for the nodes
	var tidsR_nodes_pairL = new Sequence<String>; 
	for(n in nc.nodes.select(m|m.instanceOf(State))){
		tidsR_nodes_pairL.add("interrupt_" + n.FQN());
	}
	var tidsR_nodes_pairR = new Sequence<String>;
	for(n in nc.nodes.select(m|m.instanceOf(State))){
		tidsR_nodes_pairR.add("interrupt_"+nc.FQN());
	}
	

	//to combine the two sets of pair
	var tidsR_pairL = tidsR_trans_pairL.includingAll(tidsR_nodes_pairL);
	var tidsR_pairR = tidsR_trans_pairR.includingAll(tidsR_nodes_pairR);
	
	/***************end of tidsR(nc)************************/
	
	
	
	//Rename composedNodes(nc.nodes) with tidsR(nc)
	var composedNodeProcTidsRenamed = composedNodes(nc.nodes).createRenameProcess(tidsR_pairL, tidsR_pairR);
	
	
	//create transition process: Q
	var transProc = nc.createTransitionsAsCircusProcess();
	
	//a process paragraph is created for transProc because transProc is defined standalone in auto-gen CSPM 
	var transProcPara = transProc.createProcessPara("trans_proc_" + nc.FQN(), true);
	
	
	//this step creates the string set, but not a channelset, because this can SIMPLIFY the coding. 
	//we will generate a channelset after all channels are collected (by union) for the channelset
	var cs_stringset = flowevts(nc).includingAll(transSync(nc));
	cs_stringset.add("terminate");
	("line903: cs_stringset.type = " +cs_stringset).println();
	
	
	/***************begin of C.2.2 metanotatin************************/
	
	var ncCoreBehProc = createMetaParallelProcess(nc, 
												  composedNodeProcTidsRenamed, 
												  vars(nc.nodes), 
												  vars(nc.nodes), 
												  cs_stringset, 
												  vtguards(nc), 
												  Set{}, 
												  transProcPara.name.createCallProcess()
												  );
	/***************end of C.2.2 metanotatin************************/
	
	
	return ncCoreBehProc;
}



//used inCSP Rule 41 - operation ncCoreBehaviour  
operation vtguards(nc: RC!NodeContainer):  Set<String>{
	var varset = new Set<String>;
	varset = Set{};
	for(t in nc.transitions){
		varset = varset.includingAll(usedVariables(t.condition));
	}
	return varset;
}

	
//CSP Rule 46
operation vars(nodeset:Set<RC!Node>): Set<String>{
	"Rule 46 is called".println();
	var varset = Set<String>;
	varset = Set{};

	for(n in nodeset){
		varset = varset.includingAll(vars(n));
	}
	return varset;
}


//CSP Rule 47
operation vars(ts: Set<RC!Transition>):Set<String>{
	"Rule 47 is called".println();
	var varset = Set<String>;
	for(t in ts){
		varset = varset.includingAll(vars(t));//Rule 49
	}
	return varset;
}


//CSP Rule 48
operation vars(node: RC!Node):Set<String>{
	"Rule 48 is called".println();
	var varset = Set<String>;
	varset = Set{};
	if(node.instanceOf(RC!State)){
		for(a in node.actions){
			varset = varset.includingAll(vars(a.action));//Rule 50
		}
		"line 285".println();
		varset = varset.includingAll(vars(node.nodes))//Rule 46
				       .includingAll(vars(node.transitions));//Rule 47
	} else{
		varset = Set{};
	}
	return varset;
}

//CSP Rule 49
operation vars(t: RC!Transition):Set<String>{
	"Rule 49 is called".println();
	var varset = Set<String>;
	if(t.condition.isDefined()){
		varset = varset.includingAll(vars(t.condition));//Rule 50
	}
	if(t.action.isDefined()){
		varset = varset.includingAll(vars(t.action));//Rule 50
	}
	if(t.deadline.isDefined()){
		varset = varset.includingAll(vars(t.deadline));
	}
	
	return varset;
}

//CSP Rule 50
operation vars(stmt: RC!Statement):Set<String>{
	var varset = Set<String>;
	varset = Set{};
	
	if(stmt.instanceOf(RC!Assignment)){
//		varset = usedVariables(stmt.left).includingAll(usedVariables(stmt.right));
//		this line above nc(stmt.left.name) is commented out, because usedVariables (Rule 45) does not cover VarRef, a subclass of Assignable
		
		varset = Set{stmt.left.name.name + "_" + nc(stmt.left.name).FQN()}.includingAll(usedVariables(stmt.right));
		//stmt.left is an Assignable, stmt.left.name is a Variable
		//nc(stmt.left.name) returns the basiccontext that defines this variable
		
		//TO DO: to confirm: "stmt.left.name.name" works for one var name, but is there stmt.left has multiple names?
		("line 1071, stmt.left.name.name + nc(stmt.left.name).FQN() = " + stmt.left.name.name + "_" + nc(stmt.left.name).FQN()).println();
	} else
	if(stmt.instanceOf(RC!Call)){
		for(arg in stmt.args){
			varset = usedVariables(arg);
		}
		varset = varset.includingAll(requiredVariables(stmt.`operation`));
	} else
	if(stmt.instanceOf(RC!IfStmt)){
		varset = usedVariables(stmt.expression).includingAll(vars(stmt.then)).includingAll(vars(stmt.`else`));
	} else
	if(stmt.instanceOf(RC!CommunicationStmt) and (stmt.communication._type=CommunicationType#SYNC or stmt.communication._type=CommunicationType#OUTPUT)){
		varset = usedVariables(stmt.communication.value);
	} else
	if(stmt.instanceOf(RC!CommunicationStmt) and (stmt.communication._type=CommunicationType#INPUT)){
//		var para_str = stmt.communication.parameter.name + "_" + container.FQN();
		var para_str = stmt.communication.parameter.name + "_" + nc(stmt.communication.parameter).FQN();
		//parameter is a Variable
		
		varset = Set{para_str};
	} else
	
	if(stmt.instanceOf(RC!ParStmt)){
		varset = vars(stmt.stmt);
	} else
	
	if(stmt.instanceOf(RC!SeqStatement)){
		varset = vars(stmt.statements);
	} else
	
	if(stmt.instanceOf(RC!TimedStatement)){
		varset = vars(stmt.stmt).includingAll(vars(stmt.deadline));
	}
		
	return varset;
}

//TO DO
operation requiredVariables(op: RC!OperationSig): Set<String>{
	var varset = new Set<String>;
	varset = Set{};
	
	//TO DO
	
	return varset;
}



//CSP Rule 51
operation vars(seq: Sequence<RC!Statement>):Set<String>{
	"Rule 51 is called".println();
	var varset = Set<String>;
	for(stmt in seq){
		varset = varset.includingAll(vars(stmt));
	}

	return varset;
}

//CSP C.2.2 metanotation
operation createMetaParallelProcess(
	nc: RC!NodeContainer, 
	P: Z!CircusProcess, 
	pr: Set<String>, 
	pw: Set<String>, 
	cs: Set<String>, 
	qr: Set<String>, 
	qw: Set<String>, 
	Q: Z!CircusProcess
	): Z!CircusProcess{


	
	//step 1 - rename P: (1) create assigementpairs, (2) rename P 

	
	//share <-- share
	var PRenaming_pairR = Sequence{"share"};
	var PRenaming_pairL = Sequence{"share"};
	
	//share <-- setR(v)
	var pr_qw = intersect(pr,qw);
	
	for(v in pr_qw){
		PRenaming_pairR.add("share");
		PRenaming_pairL.add("setR_"+v);//R207 setR(v)
	}
	
	//set(v) <-- setL(v)
	var pw_qr = intersect(pw,qr);
	for(v in pw_qr){
		PRenaming_pairR.add("set_"+v);//Rule 201
		PRenaming_pairL.add("setL_"+v);//R204 setL(v)
		
		//TO confirm 
		//IF this is the place to give variable a FQN, the benefit of not FQN in operations vars is the vars are simplified in this way, i.e., we don't need to add .FQN() for each vars
		//the drawback is that we need to be careful to not omit any places that needs FQN
	}
	
	var PRenamed = P.createRenameProcess(PRenaming_pairR, PRenaming_pairL);
	
	

	//step 2 - rename Q: (1) create assigementpairs, (2) rename Q
				
	//share <-- share
	var QRenaming_pairR = Sequence{"share"};
	var QRenaming_pairL = Sequence{"share"};
	
	//share <-- setL(v)
	var qr_pw = intersect(qr,pw);
	for(v in qr_pw){
		QRenaming_pairR.add("share");
		QRenaming_pairL.add("setL_"+v);//R204 setL(v)
	}
	
	//set(v) <-- setR(v)
	var qw_pr = intersect(pw,qr);
	for(v in qw_pr){
		PRenaming_pairR.add("set_"+v);//Rule 201
		PRenaming_pairL.add("setR_"+v);//R207 setR(v)
	}
	
	var QRenamed = Q.createRenameProcess(QRenaming_pairR, QRenaming_pairL);
	
	
	//step 3 - create parallel process: (1) define channel set 

	
	var channel_names = cs.includingAll(setLC(intersect(pw,qr))).includingAll(setRC(intersect(qw,pr)));
	channel_names.add("share");
	//TO DO, each channel in channelset_stringSet needs to be declared as a channel.
	//channelset_stringSet.createChannel();
	
	var channelset = createChannelSet(createBasicChannelSetExpr(channel_names)).createChanSetPara("parallel_chanset_ncCoreBeh_" + nc.FQN());
	//this channelset is the one in CSPM: [| union(union(union(flowevts,transSync),{terminate}),{|share__						 			,setL_a,setR_a|}) |]
	
	//step 4 - create parallel process	P{|channelset|}Q
	
	var PparQ = createParallelProcess("parallel_chanset_ncCoreBeh_" + nc.FQN(), PRenamed,QRenamed);
	
	
	//step 5 - rename parallel process: (1) create assigementpairs, (2) rename P{|channelset|}Q
	
	var PQRenaming_pairR = new Sequence<String>;
	var PQRenaming_pairL = new Sequence<String>;
	for(v in pr_qw){
		PQRenaming_pairR.add("setR_"+v);
		PQRenaming_pairL.add("set_"+v);
	}
	for(v in qr_pw){
		PQRenaming_pairR.add("setL_"+v);
		PQRenaming_pairL.add("set_"+v);
	}
	
	var PparQRenamed = PparQ.createRenameProcess(PQRenaming_pairR, PQRenaming_pairL);
	
	return PparQRenamed;
}


//used in  C.2.2 metanotation's operation "createMetaParallelProcess"
operation intersect(
	setA: Set<Any>, 
	setB: Set<Any>
	): Set<Any>{
	var intersection = new Set<Any>;
	for (elementA in setA) {
        if (setB.includes(elementA)) {
            intersection.add(elementA);
        }
    }
	return intersection;	
}

//used in CSP Rule 41
//this creates the string set, but not a channelset, because this can SIMPLIFY the coding. 
//we will generate a channelset after all channels are collected (by union) for the channelset
operation flowevts(nc: RC!NodeContainer): Set<String>{
	var flowevts = enterSS(nc).
				   includingAll(Set{"exit_"+nc.FQN(),
				   					"exited_"+nc.FQN(),
				   					"interrupt_"+nc.FQN()}
				   				).asSet();
	return flowevts;
}


//used in CSP Rule 40 and operation flowevts
//this creates the string set, but not a channelset, because this can SIMPLIFY the coding. 
//we will generate a channelset after all channels are collected (by union) for the channelset
operation enterSS(nc: RC!NodeContainer): Sequence<String>{
	var seq = new Sequence<String>;
	for(n in nc.nodes){
//		set.add(nc.name+"."+n.name+"::enter"); //stm0.i0::enter ?
		seq.add("enter_" + n.FQN()); 
	}
	return seq;
}


operation enteredSS(nc: RC!NodeContainer): Sequence<String>{
	var seq = new Sequence<String>;
	for(n in nc.nodes.select(m|m.instanceOf(RC!State))){
		seq.add("entered_" + n.FQN()); 
	}
	return seq;
}



//used in Rule 41
operation transSync(nc: RC!NodeContainer): Set<String>{
	var set = new Set<String>;
	for(t in nc.transitions){
		set.add(tevent_str(t));
	}
	return set;
}


//CSP Rule 206, used in C.2.2 (Rule 41)
operation setLC(nameset: Set<String>):Set<String>{
	var set = new Set<String>;
	for(n in nameset){
		set.add("SetL_"+n);
	}
	return set;
}

//CSP Rule 209, used in C.2.2 (Rule 41)
operation setRC(nameset: Set<String>):Set<String>{
	var set = new Set<String>;
	for(n in nameset){
		set.add("SetR_"+n);
	}
	return set;
}


//CSPM example:
/****************************
[[ stop__.x____ 	<- stop,
   trigger1__.x____ <- trigger1,
   event1__.x____ 	<- event1
   | x____ <- NIDS
]]
*******************************/
//CSP Rule 42 - part1, used in Rule 40
//by 5th June 2024, this operation is only used in Rule 40
//and this is the only place involving "event1__.x____ <- event1 | x____ <- NIDS"
//in Isabelle, we use "event1_stm0_pkg0__in\<cdot>x" to represent the above
operation renameTriggerEventsPairL(nc:RC!NodeContainer): Sequence<String>{
	var pairL = new Sequence<String>;
	
	for(t in nc.transitions.select(l|l.trigger.isDefined())){
		
		pairL.add(t.trigger.event.FQN()+"__in" +"\\<cdot>x" );
		//in Isabelle, event1\<cdot>x means the set of events that take all values of the first type of event1  when the tirgger's type is a product.
		//what about the case the trigger's type is not a product, but only NIDS?
		//TBC
		
		
//		pairL.add(t.trigger.event.FQN()+"__in"  +".NID_"+ t.source.FQN() );		
	}
	return pairL;
}

//CSP Rule 42 - part2
operation renameTriggerEventsPairR(nc:RC!NodeContainer): Sequence<String>{
	var pairR = new Sequence<String>;
	for(t in nc.transitions.select(l|l.trigger.isDefined())){
		pairR.add(t.trigger.event.FQN()+"_in");
	}
	return pairR;
}


//This operation is not used yet
//channelset is declared, and is referred here as a name (RefExp)
operation Z!CircusProcess createHideProcess(
	cs_name: String//, 
//	nc: RC!NodeContainer
	):Z!HideProcess{
	"line 608 createHideProcess is called".println();
	var hideProc = new Z!HideProcess;
	hideProc.channelSet =  createChannelSet(cs_name.createRefExpr(false,false));
	
	hideProc.circusProcess = self;
	hideProc.type().println();
 	return hideProc;
}

//channelset is not declared, and is declared within hideProcess, but has no name (BasicChannelSetExpr)
operation Z!CircusProcess createHideProcess(
	channel_names: Sequence<String>//, 
//	nc: RC!NodeContainer
	):Z!HideProcess{

	"line 622 createHideProcess is called".println();
	var hideProc = new Z!HideProcess;
	hideProc.channelSet = createChannelSet(createBasicChannelSetExpr(channel_names));
	
	hideProc.circusProcess = self;
 	return hideProc;
}


//the parameter is a channelset instead of string set
operation Z!CircusProcess createHideProcess(
	cs: Z!CircusChannelSet//, 
//	nc: RC!NodeContainer
	):Z!HideProcess{

	"line 622 createHideProcess is called".println();
	var hideProc = new Z!HideProcess;
//	hideProc.channelSet = createChannelSet(createBasicChannelSetExpr(channel_names));
	hideProc.channelSet = cs;
	hideProc.circusProcess = self;
 	return hideProc;
}

operation Z!CircusProcess createRenameProcess(
	nameSetL: Sequence<String>, 
	nameSetR: Sequence<String>
	): Z!RenameProcess{
	var proc = new Z!RenameProcess;
	proc.circusProcess = self;
	proc.assignmentPairs = createAssignmentPairs(nameSetL, nameSetR);
	
	return proc;
}

//this is not directly used, but in createRenameProcess
operation createAssignmentPairs(
	nameSetL: Sequence<String>, 
	nameSetR: Sequence<String>
	): Z!AssignmentPairs{
	var pairs = new Z!AssignmentPairs;
	var lhs = new Z!ZNameList;
	var rhs = new Z!ZExprList;
	
	for(sname in nameSetL){
		lhs.names.add(sname.createZName());
	}
	pairs.lhsElement = lhs;
	
	for(tname in nameSetR){
		rhs.exprs.add(tname.createRefExpr(false,false));
	}
	pairs.rhsElement = rhs;
	
	return pairs;
}

//was used in R41 tidsR(nc), now replaced by the below updated version (the parameter 'context' was removed)
/*
//this version makes the FQN locally instead of using FQN
operation tevent(t: RC!Transition, context: String): String{
 	
 	var tevent_string;
 	
	if(t.trigger = null){
		tevent_string = "internal." + context +"." + t.source.name;
	} 
	
	else {
		tevent_string = t.trigger.event.name + "__." + context+"." + t.source.name + "_in";
	}
	
	return tevent_string;
}
*/

// CSP Rule 43 variation
// used in R41 tidsR(nc) //TO DO: 't.source.name' should be replaced by 't.source.FQN()' later on.
operation tevent_str(t: RC!Transition): String{
 	
 	var tevent_string;
 	
	if(t.trigger = null){
		tevent_string = "internal__" + nc(t).FQN()  + ".NID_" + t.source.FQN();
	} 
	
	else {
		tevent_string = t.trigger.event.FQN() + "__in"   + "." + t.source.FQN();//TBC: + "." + t.source.FQN() part
//		tevent_string = t.trigger.event.name + "__." + t.source.name + "_in";
	}
	
	return tevent_string;
}

//CSP Rule 43 variation
//TO DO: to confirm the Z type, shall trigger event be both a channel AND a communication?
//this version returns Communication
operation  tevent(t: RC!Transition): Z!Communication{
 	"line 1397, tevent to return communication is called".println();
 	var chan_name;
 	var chan_type = "SYNCH";

	if(t.trigger = null){
		chan_name = "internal__" + nc(t).FQN()  + ".NID_" + t.source.FQN();//TBC
//		chan_name = "internal." + t.source.name;
	} 
	
	else {
		chan_name = t.trigger.event.FQN() + "__in"      + "." + t.source.FQN();//TBC
//		chan_name = t.trigger.event.name + "__." + t.source.name + "_in";
	}
	
	var commu = createSynchCommunication(chan_name);
	
	return commu;
}


//to obtain the nodecontainer that contains the transition t
operation nc(t: RC!Transition): RC!NodeContainer{
	for(nc in RC!NodeContainer.all()){
		if(nc.transitions.includes(t)){
			return nc;
		}
	}
}

operation nc(nd: RC!Node): RC!NodeContainer{
	for(nc in RC!NodeContainer.all()){
		if(nc.nodes.includes(nd)){
			return nc;
		}
	}
}

//to return the nodecontainer of the variable
//TO DO: the required var
operation nc(v: RC!Variable): RC!BasicContext{

	//Case 1: v belongs to a STMDef
	for(nc in RC!StateMachineDef.all()){
		for(vl in nc.variableList){
			if(vl.modifier = RC!VariableModifier#VAR and vl.vars.includes(v)){
				return nc;
			}
		}
	}
	
	//Case 2: v belongs to a OperationDef
	for(nc in RC!OperationDef.all()){
		for(vl in nc.variableList){
			if(vl.modifier = RC!VariableModifier#VAR and vl.vars.includes(v)){
				return nc;
			}
		}
	}
	
	//Case 3: v belongs to a ControllerDef
	for(nc in RC!ControllerDef.all()){
		for(vl in nc.variableList){
			if(vl.modifier = RC!VariableModifier#VAR and vl.vars.includes(v)){
				return nc;
			}
		}
	}
	
	//Case 4: v belongs to a PlatformDef
	for(nc in RC!PlatformDef.all()){
		for(vl in nc.variableList){
			if(vl.modifier = RC!VariableModifier#VAR and vl.vars.includes(v)){
				return nc;
			}
		}
	}
	
	
	//Case 5: v belongs to a Interface
	for(nc in RC!Interface.all()){
		for(vl in nc.variableList){
			if(vl.modifier = RC!VariableModifier#VAR and vl.vars.includes(v)){
				return nc;
			}
		}
	}
}


operation nc(stm: RC!Statement): RC!NodeContainer{
	for(nc in RC!NodeContainer.all()){
		
		for(st in nc.nodes.select(s|s.instanceOf(RC!State))){
			if(st.actions.size()>0){
				for(action in st.actions){
					if(action.action = stm){
						return nc;
					}
				}
			}
		}	
		
		for(tr in nc.transitions){
			if(tr.action = stm){
				return nc;
			}			
		}
	}
}




//CSP Rule 44
operation usedVariables(stmt:RC!Statement):Set<String>{
	var varSet = new Set<String>;
	if(stmt.instanceOf(RC!Assignment)){
		varSet = usedVariables(stmt.right);
	} else
	if(stmt.instanceOf(RC!Call)){
		for(arg in stmt.args){
			varSet = varSet.includingAll(usedVariables(arg));
		}
	} else
	//stmt.then and stmt.else are handled in the IfStmt incontext semantics
	if(stmt.instanceOf(RC!IfStmt)){
		varSet = usedVariables(stmt.expression);
	} else
	if(stmt.instanceOf(RC!CommunicationStmt) and (stmt.communication._type=CommunicationType#SYNC or stmt.communication._type=CommunicationType#OUTPUT)){
		varSet = usedVariables(stmt.communication.value);
	} else
//	if(stmt.instanceOf(RC!SeqStatement)){
//		for(s in stmt.statements){
//			varSet = varSet.includingAll(usedVariables(s));
//		}
//	} else
//	if(stmt.instanceOf(RC!ParStmt)){
//		varSet = usedVariables(stmt.stmt);
//	} else
	if(stmt.instanceOf(RC!TimedStatement)){
		varSet = usedVariables(stmt.stmt).includingAll(usedVariables(stmt.deadline));
	} else
	{//SeqStatement falls in this case
	}
	
	return varSet;
}



//used in operation usedVariables(stmt:RC!Statement)
//TO DO: this is not a complete implementation because of lamda expr
//TO BE FIXED LATER for LAMDA
//as the lamda expression is not well considered.
//the local variable in lamda expr should not be considered in this function
//CSP Rule 45
operation usedVariables(expr:RC!Expression): Set<String>{
	var set = new Set<String>;
	if(expr = null
	 //when expr is concreate value (int, float, string, boolean, ect.), as these do not fall into any if case, therefore, set = {}
	 //or expr.instanceOf(IntegerExp) or expr.instanceOf(FloatExp) or expr.instanceOf(StringExp) or expr.instanceOf(BooleanExp)
	 ){
	} else
	if(expr.instanceOf(RefExp)){
		var value = expr.ref;
		if(value.instanceOf(RC!Variable) and value.modifier= VariableModifier#VAR){
			set.add(value.name + "_" + nc(value).FQN());
			//here we use operation nc() to return the basiccontext that defines this variable,
			//therefore we do not need to pass the parameter 'container' to the usedVariables operaiton as below
//			set.add(value.name + "_" + container.FQN());
		}

	} else
	{
		"line814".println();
		 expr.eContents.println();
		 "line816".println();
		for(obj in expr.eContents){
			if(obj.instanceOf(RC!Expression)){
//				set = set.includingAll(usedVariables(obj));
				set = set.includingAll(usedVariables(obj));
			}
		}
		
	}
	
	return set;
}




//CSP Rule 52
operation composedNodes(nodes: Set<Node>): Z!CircusProcess{
	
	var procForComposeNodes;
	
	if(nodes.size()=0){//SStop /\ terminate -> Skip, this is an action, need to be converted into process
		var action = createAction2("InterruptAction", "SSTOP".createCallAction(), createPrefixingAction(createSynchCommunication("terminate"), createSkipAction()));
		
		var actionParaSeq = new Sequence<Z!ActionPara>;
		actionParaSeq = Sequence{action.createActionPara("action")};
		procForComposeNodes = actionParaSeq.createBasicProcess("action");
	}else{
		
//		var ndProcSet = new Set<CircusProcess>;
		var ndProcNameSet = new Set<String>;
		
		for(nd in nodes){
			var proc_name = "state_proc_" + nd.FQN() ;//TO DO: need to give the fully qualified name?
			if(nd.instanceOf(Junction)){
				
				//to create the process for this node as a standalone process paragraph
				nd.createJunctionAsBasicProcess().createProcessPara(proc_name, true);
				ndProcNameSet.add(proc_name);
				
				//we don't need the process set, but the name set of the processes
				//because the parallel process is for callProcess, so the line below is commented out.
				//ndProcSet.add(nd.createJunctionAsBasicProcess());
			} else
			if(nd.instanceOf(Final)){
				
				nd.createFinalAsBasicProcess().createProcessPara(proc_name, true);
				ndProcNameSet.add(proc_name);
//				ndProcSet.add(nd.createFinalAsBasicProcess());
			} else
			if(nd.instanceOf(State)){
				if(nd.nodes.size()=0){
					nd.createSimpleStateAsBasicProcess().createProcessPara(proc_name, true);
					ndProcNameSet.add(proc_name);
//					ndProcSet.add(nd.createSimpleStateAsBasicProcess());
				} else{
					//TO DO: to uncomment when createCompositeStateAsBasicProcess is defined
					//ndProcSet.add(nd.createCompositeStateAsBasicProcess()); 
				}
				
			}
		}
		
//		//to create channelset as a channel set paragraph	
//		var cs = createChannelSet(createBasicChannelSetExpr(Set{"share", "terminate"})).createChanSetPara("cs");
		
		if(nodes.size()<2){
			throw "There are less than 2 nodes, so the parallel process can not be composed.";
		} else{
		
			//we can directly use the node process ndProcSet.at(0),ndProcSet.at(1) to create parallel process directly, but to be consistent with the auto-gen CSPM, we use callProcess here
			procForComposeNodes = createParallelProcess(Set{"share", "terminate"}, ndProcNameSet.at(0).createCallProcess(),ndProcNameSet.at(1).createCallProcess());
			ndProcNameSet.removeAt(0);
			ndProcNameSet.removeAt(0);
						
			while(ndProcNameSet.size()>0){

				procForComposeNodes = createParallelProcess(Set{"share", "terminate"}, procForComposeNodes,ndProcNameSet.at(0).createCallProcess());			
				ndProcNameSet.removeAt(0);
			}

		}
		
	}
	
	return procForComposeNodes;
}

operation String createCallProcess(): Z!CallProcess{
	var proc = new Z!CallProcess;
	proc.callExpr = self.createRefExpr(false,false);
	proc.callUsage = Z!CallUsage#Parameterised;
	
	return proc;
}

operation Z!ZName createCallProcess(): Z!CallProcess{
	var proc = new Z!CallProcess;
	proc.callExpr = self.word.createRefExpr(false,false);
	proc.callUsage = Z!CallUsage#Parameterised;
	
	return proc;
}

operation Z!CircusProcess createProcessPara(name: String, isBasicProc: Boolean): Z!ProcessPara{
	var para = new Z!ProcessPara;
	para.name = name.createZName();
	para.circusProcess = self;
	para.isBasicProcess = isBasicProc;
	
	return para;
}



//channelset is a reference to a channelset name, therefore it is an RefExpr
operation createParallelProcess(
	cs_name: String, 
	left: Z!CircusProcess, 
	right: Z!CircusProcess
	):Z!ParallelProcess{
	
	var proc = new Z!ParallelProcess;
	proc.channelSet = createChannelSet(cs_name.createRefExpr(false,false));
	proc.leftProcess = left;
	proc.rightProcess = right;
	
	return proc;
}


//channelset is declared in the process directly using the channel names, so has no channelset name
//therefore it is an BasicChannelSetExpr
operation createParallelProcess(
	channel_names: Set<String>, 
	left: Z!CircusProcess, 
	right: Z!CircusProcess
	):Z!ParallelProcess{
	
	var proc = new Z!ParallelProcess;
//	proc.channelSet = createChannelSet(cs_name.createRefExpr(false,false));
	proc.channelSet = createChannelSet(createBasicChannelSetExpr(channel_names));
	proc.leftProcess = left;
	proc.rightProcess = right;
	
	return proc;
}


//to create BasicChannelSetExpr used in channel set declaration
operation createBasicChannelSetExpr(channel_names:Sequence<String>): Z!BasicChannelSetExpr{
	var expr = new Z!BasicChannelSetExpr;
	var commuList = new Sequence<Z!Communication>;
	for(n in channel_names){
		commuList.add(createChannelSetCommunication(n));
	} 
	var communicationList = new Z!CircusCommunicationList;
	expr.communicationList = communicationList;
	expr.communicationList.communications = commuList;
	return expr;
}

operation createBasicChannelSetExpr(channel_names:Set<String>): Z!BasicChannelSetExpr{
	var expr = new Z!BasicChannelSetExpr;
	var commuList = new Sequence<Z!Communication>;
	for(n in channel_names){
		commuList.add(createChannelSetCommunication(n));
	} 
	var communicationList = new Z!CircusCommunicationList;
	expr.communicationList = communicationList;
	expr.communicationList.communications = commuList;
	return expr;
}
//to create communication of channelset type to be used in the BasicChannelSetExpr
operation createChannelSetCommunication(
	channel_name:String
	): Z!Communication{
	
	var commu = new Z!Communication;
	commu.commUsage = Z!CommUsage#Normal;
	commu.indexed = false;
	commu.multiSych = 0;
	commu.channelExpr = channel_name.createRefExpr(false,false);
	commu.fieldList = new Z!CircusFieldList; 
	
	commu.commPattern = Z!CommPattern#ChannelSet;
	commu.fieldList.fields = Sequence{};		
		
	return commu;
}

operation createChannelSet(expr: Z!Expr):Z!CircusChannelSet{
	var cs = new Z!CircusChannelSet;
	cs.expr = expr;
	return cs;

}




operation Z!CircusChannelSet createChanSetPara(name: String): Z!ChannelSetPara{
	var para = new Z!ChannelSetPara;
	para.name = name.createZName();
	para.channelSet = self;
	
	return para;
}


//CSP Rule 53, modified: update action Trans into a prefixingaction, then updated as a process: (enter.initial(nc.nodes) -> Trans)
operation RC!NodeContainer createTransitionsAsCircusProcess(): Z!CircusProcess{
	
	var trans;

	var tran_seq = Sequence<Z!CircusAction>;
	tran_seq = Sequence{};
	for(t in self.transitions){
		"line188".println();
		("tran_seq = " + tran_seq).println();
		tran_seq.add(t.createTransitionAsCircusAction());
	}
	var choice1_action1_left = tran_seq.createSequenceAsExtchoiceAction();

	
	var choice1_action1_right = createPrefixingAction(createSynchCommunication("share"), createSkipAction());
	
 	var choice1_action1 = createAction2("ExtChoiceAction", choice1_action1_left, choice1_action1_right);
	"line 199".println();
	("trans " + trans).println();
	var choice1 = createAction2("SeqAction", choice1_action1, "trans".createCallAction());
	
	
	/* Start of Choice 2 creation*/
	//Stop /\ (exit -> Skip)
	var choice2_action1_action2 = createAction2("InterruptAction", "SSTOP".createCallAction(), createPrefixingAction(createSynchCommunication("exit"), createSkipAction()));
	var choice2_action1 = createPrefixingAction(createSynchCommunication("interrupt." + self.name), choice2_action1_action2);
	
	//exited -> end -> Skip
	var choice2_action2_action2 = createPrefixingAction(createSynchCommunication("exited"), createPrefixingAction(createSynchCommunication("terminate"), createSkipAction()));
	
	//SStop /\ (exited -> end -> Skip)
	var choice2_action2 = createAction2("InterruptAction", "SSTOP".createCallAction(), choice2_action2_action2);
	var choice2 = createAction2("SeqAction", choice2_action1, choice2_action2);
	/* End of Choice 2 creation*/
	
	
	//terminate -> Skip
	var choice3 = createPrefixingAction(createSynchCommunication("terminate"), createSkipAction());
		
	var trans = createAction2("ExtChoiceAction", choice1, createAction2("ExtChoiceAction", choice2, choice3));
	("trans: "+trans).println();
	
	
	var vguards = self.vguards(); 
	"line309".println();
	vguards.println();
	var Trans = readStateA(vguards, trans);
	//Trans is an actioin and can not be a process, because it will be prefixed.
	//end of CSP Rule53
	
	
	//to integrate the prefix "enter.initial"
	//and to convert the action into a Process
	var initial_name = nc.nodes.selectOne(n|n.instanceOf(Initial)).name;
	"line496".println();
	nc.nodes.selectOne(n|n.instanceOf(Initial)).println();
	nc.nodes.selectOne(n|n.instanceOf(Initial)).name.println();
	var commu = createSynchCommunication("enter." + nc.name + "." + initial_name);
	
	var prefixAction = createPrefixingAction(commu, Trans);
	
	var actionParaSeq = new Sequence<Z!ActionPara>;
	actionParaSeq = Sequence{prefixAction.createActionPara("prefixedTransAction_"+nc.name)};
	var proc = actionParaSeq.createBasicProcess("prefixedTransAction_"+nc.name);
		
	return proc;
}


//CSP Rule 54
//to create circus action for each transition
operation RC!Transition createTransitionAsCircusAction(): Z!CircusAction{
	var circusAction;
	if(self.source.type().name = "State"){
					
		//action1: trigger; action2: interruptAction1 ; action3: interruptAction(SStop, SeqAction )
		
		var action1 = trigger(self);
		
		//to create action2: exit
		var rightAction1 = createPrefixingAction(createSynchCommunication("exit"), createSkipAction());
		var action2 = createAction2("InterruptAction", "SSTOP".createCallAction(), rightAction1);
		
		//to create action3_inner_1: exited
		var prefixedAction = self.createTrActionAsCircusAction();
		
		
		var action3_inner_1 = createPrefixingAction(createSynchCommunication("exited"), prefixedAction);
		
		
		//to create action3_inner_2: enter
		var action3_inner_2 = createPrefixingAction(createSynchCommunication("enter." + self.target.name), createSkipAction());
		
		var action3_right = createAction2("SeqAction", action3_inner_1, action3_inner_2);
		
		//SStop /\ ( (exited-> [[t.action]]) ; (enter_t.target -> Skip))
		var action3 = createAction2("InterruptAction", "SSTOP".createCallAction(), action3_right);
		
		
		circusAction = createAction2("SeqAction", action1, createAction2("SeqAction", action2, action3));
		
		if(self.condition != null){
			var pred = self.condition.createExpr().createMemPredEquality();
			circusAction = createGuardedAction(pred, circusAction);
		} 
	} else 
	
	if(self.source.type().name != "State"){
		//action1: prefixingAction
		
		
		var prefixedAction = self.createTrActionAsCircusAction();
		
		var action1 = createPrefixingAction(tevent(self), prefixedAction);
		
		var action2 = createPrefixingAction(createSynchCommunication("enter." + self.target.name), createSkipAction());
		
		circusAction = createAction2("SeqAction", action1, action2);
				
		if(self.condition != null){
			var pred = self.condition.createExpr().createMemPredEquality();
			circusAction = createGuardedAction(pred, circusAction);
		} 
	} 
	
	return circusAction;
}


//equality is s relation operator application (C.5.12): MemPred
operation Z!Expr createMemPredEquality(): Z!MemPred{
	var pred =  new Z!MemPred;
	pred.leftExpr = self;
	
	var set = Set{"True"};
	pred.rightExpr = set.createSetExpr();
	pred.mixFix = true;
	
	return pred;
}


operation  Set<String> createSetExpr(): Z!SetExpr{
	var setExpr = new Z!SetExpr;
	var exprList = new Z!ZExprList;
	var exprs = new Sequence<Z!Expr>;
	
	for(m in self){
		exprs.add(m.createRefExpr(false,false));
	}
	exprList.exprs = exprs;
	setExpr.exprList = exprList;
	return setExpr;
}



 

//CSP Rule 55
operation  trigger(t: RC!Transition): Z!PrefixingAction{
	var triggerAction;
	var commu;
	var callAction;
	var channel_name;
	
	if(t.trigger = null){
	
		commu = createSynchCommunication("internal." + t.source.name);
		triggerAction = createPrefixingAction(commu, createSkipAction());
			
	} else 
	
	//trigger event can only be input or simple type
	if(t.trigger._type = CommunicationType#INPUT){
		
		var channel_name = t.trigger.event.name + "__." + t.source.name + "_in";
		var var_name = t.trigger.parameter.name;
		commu = createInputCommunication(channel_name, var_name);

		var inner_channel_name = "set_" + t.trigger.parameter.name;
		var expr_string = t.trigger.parameter.name;
		var inner_commu = createOutputCommunicationFromString(inner_channel_name, expr_string);
//		var inner_commu = t.trigger.createCommuAsCommunication(inner_channel_name, "OUTPUT");
					
		var rightAction = createPrefixingAction(inner_commu, createSkipAction());
		var leftAction = "SSTOP".createCallAction();
		callAction = createAction2("InterruptAction", leftAction, rightAction);
		
		triggerAction = createPrefixingAction(commu, callAction);
	} else
	
	if(t.trigger._type = CommunicationType#SIMPLE){
		channel_name = t.trigger.event.name + "__." + t.source.name + "_in";
		commu = createSynchCommunication(channel_name);
		triggerAction = createPrefixingAction(commu, createSkipAction());
	} 
	return triggerAction;
}






//CSP Rule 57
operation RC!Junction createJunctionAsBasicProcess(): Z!BasicProcess{
	var actionParaSeq = new Sequence<Z!ActionPara>;
	
		
	var Inactive = createAction2("InterruptAction", "SSTOP".createCallAction(), createAction2("ExtChoiceAction", "Activation".createCallAction(), "Termination".createCallAction()));
	
	actionParaSeq = Sequence{Inactive.createActionPara("Inactive")};
	
		
	var Activation = createPrefixingAction(createSynchCommunication("enter_"+self.name), "Active".createCallAction());
	actionParaSeq.add(Activation.createActionPara("Activation"));
	
	var Termination = createPrefixingAction(createSynchCommunication("terminate"), createSkipAction());
	actionParaSeq.add(Termination.createActionPara("Termination"));
	
	var seqAction1 = createAction2("InterruptAction", "SSTOP".createCallAction(), createPrefixingAction(createSynchCommunication("interrupt_"+self.name), createSkipAction()));
	
	var Active = createAction2("SeqAction", seqAction1, "Inactive".createCallAction());
	actionParaSeq.add(Active.createActionPara("Active"));
	
	var mainActionname = "Inactive";
	
	var basicProcess = actionParaSeq.createBasicProcess(mainActionname);
	return basicProcess;
}




//CSP Rule 58
operation RC!Final createFinalAsBasicProcess(): Z!BasicProcess{
	var actionParaSeq = new Sequence<Z!ActionPara>;
	
		
	var Inactive = createAction2("InterruptAction", "".createCallAction(), createAction2("ExtChoiceAction", "Activation".createCallAction(), "Termination".createCallAction()));
	
	actionParaSeq = Sequence{Inactive.createActionPara("Inactive")};
	
		
	var Activation = createPrefixingAction(createSynchCommunication("enter_"+self.name), "Entering".createCallAction());
	actionParaSeq.add(Activation.createActionPara("Activation"));
	
	var Termination = createPrefixingAction(createSynchCommunication("terminate"), createSkipAction());
	actionParaSeq.add(Termination.createActionPara("Termination"));
	
	var Entering = createPrefixingAction(createSynchCommunication("entered_" + self.name), "Active".createCallAction());
	actionParaSeq.add(Entering.createActionPara("Entering"));
	
	
	
	var rightAction = createAction2("ExtChoiceAction", "Termination".createCallAction(), createPrefixingAction(createSynchCommunication("interrupt_"+self.name), "Interrupted".createCallAction()));
	
	var Active = createAction2("InterruptAction", "SSTOP".createCallAction(), rightAction);
	actionParaSeq.add(Active.createActionPara("Active"));
	
	var rightAction2 = createPrefixingAction(createSynchCommunication("exit"), createPrefixingAction(createSynchCommunication("exited"), "Inactive".createCallAction()));
	
	var Interrupted = createAction2("InterruptAction", "SSTOP".createCallAction(), rightAction2);
	actionParaSeq.add(Interrupted.createActionPara("Interrupted"));
	
	var mainActionname = "Inactive";
	
	var basicProcess = actionParaSeq.createBasicProcess(mainActionname);
	return basicProcess;
}




//CSP Rule 59
operation RC!State createSimpleStateAsBasicProcess(): Z!BasicProcess{
	var actionParaSeq = new Sequence<Z!ActionPara>;
	
		
	var Inactive = createAction2("InterruptAction", "SSTOP".createCallAction(), createAction2("ExtChoiceAction", "Activation".createCallAction(), "Termination".createCallAction()));
	var InactivePara = Inactive.createActionPara("Inactive");
	actionParaSeq.add(InactivePara);
	
	"line115".println();
	actionParaSeq.println();
	var Activation = createPrefixingAction(createSynchCommunication("enter_"+self.name), "Active".createCallAction());
	actionParaSeq.add(Activation.createActionPara("Activation"));
	
	var Termination = createPrefixingAction(createSynchCommunication("terminate"), createSkipAction());
	actionParaSeq.add(Termination.createActionPara("Termination"));
	
	var Active = createAction2("SeqAction", self.createStateActionAsCircusAction("EntryAction"), createAction2("SeqAction", "Behaviour".createCallAction(), "Exiting".createCallAction()));
	actionParaSeq.add(Active.createActionPara("Active"));
	
	
	var Behaviour = createPrefixingAction(createSynchCommunication("entered_" + self.name), "During".createCallAction());
	actionParaSeq.add(Behaviour.createActionPara("Behaviour"));
	
	var duringLeft = createAction2("SeqAction", self.createStateActionAsCircusAction("DuringAction"), "SSTOP".createCallAction());
	"line324".println();
	var duringRight = createPrefixingAction(createSynchCommunication("interrupt_" + self.name), createSkipAction());
	"line326".println();
	var During = createAction2("InterruptAction", duringLeft, duringRight);
	"line328".println();
	actionParaSeq.add(During.createActionPara("During"));
	
	
	
	var exitingAction1 = createAction2("InterruptAction", "SSTOP".createCallAction(), createPrefixingAction(createSynchCommunication("exit"), createSkipAction()));
	var exitingAction2 = self.createStateActionAsCircusAction("ExitAction");
	var exitingAction3 = createPrefixingAction(createSynchCommunication("exited"), "Inactive".createCallAction());
	var Exiting = createAction2("SeqAction", exitingAction1, createAction2("SeqAction", exitingAction2, exitingAction3));
	actionParaSeq.add(Exiting.createActionPara("Exiting"));
	
	var mainActionname = "Inactive";
	
	var basicProcess = actionParaSeq.createBasicProcess(mainActionname);
	return basicProcess;
}





operation Z!CircusAction createActionPara(name: String): Z!ActionPara{
	var para = new Z!ActionPara;
	para.name = name.createZName();
	para.circusAction = self;
	
	return para;
}


//to convert action list into a process
operation Sequence<Z!Para> createBasicProcess(mainActionName: String): Z!BasicProcess{
	
//	var list.paras = new Sequence<Z!Para>;
//	list.paras = self;
	var basicProcess = new Z!BasicProcess;
	
	basicProcess.mainAction = mainActionName.createCallAction();
	
	var list = new Z!ZParaList;
	basicProcess.paraList = list;
	basicProcess.paraList.paras = new Sequence<Z!Para>;
	basicProcess.paraList.paras = self;
		
	return basicProcess;
}




operation Sequence<Z!CircusAction> createSequenceAsExtchoiceAction(): Z!ExtChoiceAction{
	var extchoiceAction;
	var size = self.size();
	var i = 0;
	extchoiceAction = createAction2("ExtChoiceAction", self.at(0), self.at(1));
	i = i + 2;
	if(size > 2){
		while(i<size){
			extchoiceAction = createAction2("ExtChoiceAction", extchoiceAction, self.at(i));
			i = i + 1;
		}
	}
	return extchoiceAction;
}


//This is not used yet
operation Sequence<Z!CircusAction> createSequenceAsSeqAction(): Z!SeqAction{
	var seqAction;
	var size = self.size();
	var i = 0;
	seqAction = createAction2("SeqAction", self.at(0), self.at(1));
	i = i + 2;
	if(size > 2){
		while(i<size){
			seqAction = createAction2("SeqAction", seqAction, self.at(i));
			i = i + 1;
		}
	}
	return seqAction;
}


operation RC!NodeContainer vguards(): Set<String>{
	var vguards = new Set<String>;
	for (tr in self.transitions){
		vguards= vguards.includingAll(usedVariables(tr.condition));
	}

	return vguards;
}




//TO DO to confirm the Z type
//this version returns ChannelDecl
/*
operation  tevent(t: RC!Transition): Z!ChannelDecl{
 	
 	var chan_name;
 	var chan_type;

	if(t.trigger = null){
		chan_name = "internal." + t.source.name;
		chan_type = "SYNCH";
	} 
	
	//TO DO: to confirm if this "else" is necessary 
	//as trigger is only allowed when source= state 
	else {
		chan_name = t.trigger.event.name + "__." + t.source.name + "_in";
		chan_type = "SYNCH";
	}
	
	var channel = chan_name.createChannelDecl(chan_type);
	
	return channel;
}
*/






operation String createZName(): Z!ZName{
	var zname = new Z!ZName;
	zname.word = self;
	return zname;
}


operation createNameList(stringSeq: Sequence<String>): Z!ZNameList{
	var nl = new Z!ZNameList;
	nl.names = new Sequence<ZName>;
	nl.names = Sequence{};
	
	for(str in stringSeq){
		nl.names.add(str.createZName());
	}
	
	return nl;
}

/*
//used in addChannelDecl
operation Z!ZNameList addName2NameList(name: String){
	self.names.add(name.createZName());
	return self;
}
*/

//not used, replaced by above which take Set<String> as parameter
/*
operation createNameList(nl_string: String): Z!ZNameList{
	var nl = new Z!ZNameList;
	nl.names = new Sequence<ZName>;
"line 185".println();
nl_string.println();
nl_string.length.println();
	
	//if the nl_string is empty string, then the returned list is an empty list.
	//i.e., nl.names = Sequence{}
	if(nl_string.length>1){
		var nl_seq = nl_string.split(",");
		"line191".println();
		nl_seq.println();
		for(name in nl_seq){
			nl.names.add(name.createZName());
		}
	} 

	return nl;
}
*/


operation createShareAsCommunication(): Z!Communication{
	var commu = new Z!Communication;
	
	var chanExpr = new Z!RefExpr;
	var chanExpr = "share".createRefExpr(false,false);
	commu.channelExpr = chanExpr;
	commu.commPattern.name = "Synch";
	commu.commUsage.name = "Normal";
	commu.indexed = false;
	commu.multiSych = 0;
	
	return commu;
}

//TO DO: shall it be an actionPara or action?
operation createSStopActionPara(): Z!ActionPara{
	var actionPara = new Z!ActionPara;
	
	actionPara.name = "SStop".createZName();
	
	var commu = createShareAsCommunication();
	var callAction = "SStop".createCallAction();
	
	//this is a PrefixingAction
	
	actionPara.circusAction = createPrefixingAction(commu, callAction);
	
	return actionPara;
}

operation createPrefixingAction(
	commu: Z!Communication, 
	action: Z!CircusAction
	): Z!PrefixingAction{
	
	var prefixingAction = new Z!PrefixingAction;
	
	prefixingAction.communication  = commu;
	
	prefixingAction.circusAction = action;
	
	return prefixingAction;
}




operation String createAction1(type: String): Z!Action1{
	var action1 = new Z!Action1;
	
	return action1;
}

//binary circus action: not covering PrefixingAction
//TO DO: to complete other types of Action2
operation createAction2(
	type: String, 
	fst_action: Z!CircusAction, 
	snd_action: Z!CircusAction
	): Z!Action2{
	
	var action2;
	if(type = "InterruptAction"){
		//action2 = createInterruptAction(fst_action, snd_action);
		action2 = new Z!InterruptAction;
	} else
	if(type = "SeqAction"){
		action2 = new Z!SeqAction;
	} else
	if(type = "ExtChoiceAction"){
		action2 = new Z!ExtChoiceAction;
	} 	
	
	action2.leftAction = fst_action;

	action2.rightAction = snd_action;
//	action2.actionList = new Z!CircusActionList;
	
//	action2.actionList.circusActions = Sequence{action2.leftAction, action2.rightAction};
		
	return action2;
}


operation String createCallAction(): Z!CallAction{
	var callAction = new Z!CallAction;
	callAction.name = self.createZName();
	
	return callAction;
}



operation String createCallAction(list: Sequence<Z!Expr>): Z!CallAction{
	var callAction = new Z!CallAction;
	callAction.name = self.createZName();
	callAction.exprList =  new Z!ZExprList;
	callAction.exprList.exprs = list;
	
	return callAction;
}




operation RC!Transition createTrActionAsCircusAction(): Z!CircusAction{
	if(self.action != null){
		//return self.action.createStmtAsAction();
		return self.action.createStmtInContextAsAction();
	} else{
		return createSkipAction();
	}
}



//CSP Rule 62
operation readState(varSet: Set<String>, action: Z!CircusAction):Z!CircusAction{
	if(varSet.size()=0){
		return action;
	} else {
		
		var var_name = varSet.at(0);

		var commu = createInputCommunication("get_"+var_name, var_name);
		varSet.removeAt(0);	
		var prefixAction = createPrefixingAction(commu, readState(varSet,action));
		var leftAction = "SSTOP".createCallAction();
		
		var action1 = createAction2("InterruptAction", leftAction, prefixAction);
		return action1;
	}
}


//CSP Rule 63
operation readStateAtomic(varSet: Set<String>, action: Z!CircusAction):Z!CircusAction{
	if(varSet.size()=0){
		return action;
	} else {
		
		var var_name = varSet.at(0);
		var commu = createInputCommunication("get_"+var_name, var_name);
		varSet.removeAt(0);	
		var prefixAction = createPrefixingAction(commu, readStateAtomic(varSet,action));
		
		return prefixAction;
	}
}


//CSP Rule 64
operation readStateA(varSet: Set<String>, action: Z!CircusAction):Z!CircusAction{
	if(varSet.size()=0){
		return action;
	} else {
		
		var var_name = varSet.at(0);

		var commu = createInputCommunication("get_"+var_name, var_name);
		varSet.removeAt(0);	
		var prefixAction = createPrefixingAction(commu, readStateAtomic(varSet,action));
		var leftAction = "SSTOP".createCallAction();
		
		var action1 = createAction2("InterruptAction", leftAction, prefixAction);
		return action1;
	}
}




//to create a internal input communication 
//used in readState()
operation createInputCommunication(
	chan_name: String,
	var_name:String
	): Z!Communication{
	
	var commu = new Z!Communication;

	commu.commUsage = Z!CommUsage#Normal;
	commu.indexed = false;
	commu.multiSych = 0;
	commu.channelExpr = chan_name.createRefExpr(false,false);
	
	commu.commPattern = Z!CommPattern#Input;
	commu.fieldList = new Z!CircusFieldList; 
		
	var field = new Z!InputField;
	field.varialbeName = var_name.createZName();
	commu.fieldList.fields = Sequence{field};
	
//	if(type = "INPUT"){ 
//		commu.commPattern = Z!CommPattern#Input;
//
//		var field = new Z!InputField;
//		field.varialbeName = var_name.createZName();
//		commu.fieldList.fields = Sequence{field};
//	} 
	

	
	return commu;
}


//to create a internal output communication, can be outputfield !, or dotfield .
//used in Rule 69 for output and Sync type of RoboChart Communiation
operation createOutputCommunication(
	chan_name: String,
	expr:RC!Expression,
	type: String
	): Z!Communication{
	
	var commu = new Z!Communication;

	commu.commUsage = Z!CommUsage#Normal;
	commu.indexed = false;
	commu.multiSych = 0;
	commu.channelExpr = chan_name.createRefExpr(false,false);

	commu.fieldList = new Z!CircusFieldList; 
		
	
	commu.commPattern = Z!CommPattern#Output;		
	var field = new Z!DotField;
	field.expr = expr.createExpr();
		
	if(type = "OUTPUT"){ 
		field.outputField = true;
	} else
	if(type = "SYNC"){ 
		field.outputField = false;
	}
	
	commu.fieldList.fields = Sequence{field};
	
	return commu;
}



//to create a internal sync communication 
operation createSynchCommunication(
	channel_name:String
	): Z!Communication{
	
	var commu = new Z!Communication;
	commu.commUsage = Z!CommUsage#Normal;
	commu.indexed = false;
	commu.multiSych = 0;
	commu.channelExpr = channel_name.createRefExpr(false,false);
	commu.fieldList = new Z!CircusFieldList; 
	
	commu.commPattern = Z!CommPattern#Synch;
	commu.fieldList.fields = Sequence{};		
		
	return commu;
}




//CSP Rule 65
operation RC!Statement createStmtInContextAsAction(): Z!CircusAction{

	return readState(usedVariables(self), self.createStmtAsAction());
}

//CSP Rule 65_1
operation RC!Statement createStmtAsAction(): Z!CircusAction{
	if(self.instanceOf(RC!Assignment)){
		return self.createAssignmentStmtAsAction();
	} else
	if(self.instanceOf(RC!Call)){
		return self.createCallStmtAsAction();
	} else
	if(self.instanceOf(RC!Skip)){
		return self.createSkipStmtAsAction();
	} else
	if(self.instanceOf(RC!CommunicationStmt)){
		return self.createCommuStmtAsAction();
	} else
	if(self.instanceOf(RC!ParStmt)){
		return self.createParStmtAsAction();
	} else
	if(self.instanceOf(RC!IfStmt)){
		return self.createIfStmtAsAction();
	} else
	if(self.instanceOf(RC!SeqStatement)){
		return self.createSeqStmtAsAction();
	} else
	{}
}




//CSP Rule 66
operation RC!Assignment createAssignmentStmtAsAction(): Z!InterruptAction{
	
	/*
	assignment is an interrupt actio in Circus
	left action is SStop
	right action is a prefixing action
	*/
	
	/* CallAction permits a name to be an action.
	*/
	var leftAction = "SSTOP".createCallAction();
	var chan_name = "set_" + self.left.name.name;
	var prefix = createOutputCommunication(chan_name, self.right, "OUTPUT");
	
	var rightAction = createPrefixingAction(prefix, createSkipAction());
//	var rightAction = createPrefixingAction(self.createCommunication("",""), createSkipAction()); //PrefixingAction is a type of Action1, so can not use createAction2()

	var circusAction = createAction2("InterruptAction", leftAction, rightAction);
	
	return circusAction;
}



//CSP Rule 67
operation RC!Call createCallStmtAsAction(): Z!CircusAction{
	
	var list = new Sequence<Z!Expr>;
	
	for(elem in self.args){
		list.add(elem.createExpr());
	}
	var circusAction = self.`operation`.name.createCallAction(list);
	
	return circusAction;
}



//CSP Rule 68
operation RC!IfStmt createIfStmtAsAction(): Z!IfGuardedCommand{
	
	var if_expr = self.expression;
		"line999".println();
	self.expression.println();
//		var ifAction = createGuardedAction(pred_expr, self.then.createStmtAsAction());
	var if_pred = self.expression.createExpr().createMemPredEquality();
	
	var ifActionInContext = createGuardedAction(if_pred, self.then.createStmtInContextAsAction());
	
	var else_expr = new RC!Not;
	else_expr.exp = clone(if_expr);
	//else_pred.exp = self.expression;

	var pred_else = else_expr.createExpr().createMemPredEquality();
	
	var elseActionInContext = createGuardedAction(pred_else, self.`else`.createStmtInContextAsAction());
	
	var actions = Sequence{ifActionInContext, elseActionInContext};
	
	
	var action = createIFGuardedCommand(actions);
	
	return action;
}


operation createIFGuardedCommand(actions: Sequence<Z!GuardedAction>): Z!IfGuardedCommand{
	var action = new Z!IfGuardedCommand;
	action.actionList = new Z!CircusActionList;
	action.actionList.circusActions = actions;
	
	return action;
}


operation clone(exp : RC!Expression) : RC!Expression   {
	var emfTool = new Native("org.eclipse.epsilon.emc.emf.tools.EmfTool");
	var ecoreUtil = emfTool.ecoreUtil;
	var cloned = ecoreUtil.copy(exp);
	return cloned;
}

operation clone(stmdef : RC!StateMachineDef) : RC!StateMachineDef   {
	var emfTool = new Native("org.eclipse.epsilon.emc.emf.tools.EmfTool");
	var ecoreUtil = emfTool.ecoreUtil;
	var cloned = ecoreUtil.copy(stmdef);
	return cloned;
}


/*
operation if_pred(actions: Sequence<Z!GuardedAction>): Z!IfGuardedCommand{
	var action = new Z!IfGuardedCommand;
	action.actionList = new Z!CircusActionList;
	action.actionList.circusActions = actions;
	
	return action;
}
*/
operation createGuardedAction(
	pred: Z!Pred, 
	action: Z!CircusAction
	): Z!GuardedAction{
	var guardedaction = new Z!GuardedAction;
	
	guardedaction.pred = pred;
	guardedaction.circusAction = action;
	return guardedaction;
}





//
//operation String createRCRefExp():RC!RefExp{
//
// 	var refExp = new RC!RefExp;
// 	refExp.ref = new RC!Variable;
// 	refExp.ref.name = self;
// 	
// 	return refExp;
//}


//CSP Rule 69
operation RC!CommunicationStmt createCommuStmtAsAction(): Z!CircusAction{

	
	if(self.communication._type.name = "INPUT"){
		"this is an INPUT type communication".println();
		return self.communication.createCommuINPUTAsAction();
	} else

	if(self.communication._type.name = "OUTPUT" or self.communication._type.name = "SYNC"){
		"this is an OUTPUT or SYNC type communication".println();
		return self.communication.createCommuOUTPUT_SYNCAsAction();
//		if(self.communication.value.isTypeOf(RC!RefExp)){
//			return self.communication.createCommuOUTPUT_SYNCRefAsAction();
//		} else{
//			return self.communication.createCommuOUTPUT_SYNCConcreteAsAction();
//		}
	} else
	
	if(self.communication._type.name = "SIMPLE"){
		"this is an SIMPLE type communication".println();
		return self.communication.createCommuSIMPLEAsAction();
	} 

}

//CSP Rule 69 - RC commu.type = Input
operation RC!Communication createCommuINPUTAsAction(): Z!InterruptAction{
	/*
	CommunicationStmt is an interrupt action in Circus
	left action is SStop
	right action is a prefixing action
	*/
	var leftAction = "SSTOP".createCallAction();
	

//	/*to create inner-layer prefixing of the prefixingAction,i.e., the setting part
//	e.g., set_input!input
//	we need to create an internal RC!Communication of OUTPUT type first*/
//	var inner_RC_commu = new RC!Communication;//set_input!input
//	
//	inner_RC_commu.event = new RC!Event;
//	inner_RC_commu.event.name = "set_"+ self.parameter.name;
//	
//	inner_RC_commu.value =  self.parameter.name.createRCRefExp();
//
//	inner_RC_commu._type = CommunicationType#OUTPUT;
//	
//	/*End of internal RC!Communication creation*/
		
//	var inner_prefix = inner_RC_commu.createCommunication(inner_RC_commu.event.name,"OUTPUT");

	var chan_name = "set_" + self.parameter.name;
	var expr_string = self.parameter.name;
	var inner_prefix = createOutputCommunicationFromString(chan_name, expr_string);
	
//	var expr = self.parameter.name.createRefExpr(false,false);
//	var inner_prefix = createOutputCommunication(chan_name, expr, "OUTPUT");
//	var inner_prefix = createOutputCommunicationFromString("set_" + self.parameter.name, self.parameter.name);


	var inner_prefix_action = createPrefixingAction(inner_prefix, createSkipAction());
	var inner_interrupt_action = createAction2("InterruptAction", "SSTOP".createCallAction(),inner_prefix_action);
	
	var outer_prefix = self.createCommuAsCommunication(self.event.name + "_in","INPUT");
	var outer_prefix_action = createPrefixingAction(outer_prefix, inner_interrupt_action);
	
	var circusAction = createAction2("InterruptAction", leftAction, outer_prefix_action);
	
	return circusAction;
}




operation createOutputCommunicationFromString(
	chan_name: String,
	expr_string:String
	): Z!Communication{
	
	var commu = new Z!Communication;

	commu.commUsage = Z!CommUsage#Normal;
	commu.indexed = false;
	commu.multiSych = 0;
	commu.channelExpr = chan_name.createRefExpr(false,false);

	commu.fieldList = new Z!CircusFieldList; 
		
	
	commu.commPattern = Z!CommPattern#Output;		
	var field = new Z!DotField;
	field.expr = expr_string.createRefExpr(false,false);
	field.outputField = true;
//	if(type = "OUTPUT"){ 
//		field.outputField = true;
//	} else
//	if(type = "Sync"){ 
//		field.outputField = false;
//	}
	
	commu.fieldList.fields = Sequence{field};
	
	return commu;
}




//CSP Rule 69 - RC commu.type = Output/Sync
operation RC!Communication createCommuOUTPUT_SYNCAsAction(): Z!InterruptAction{
	
	/*
	CommunicationStmt is an interrupt action in Circus
	left action is SStop
	right action is a prefixing action
	*/
	
	

	/*to create prefixing of the prefixingAction,i.e., the setting part
	e.g., status_out!input, status_out.input
	*/
//	var inner_RC_commu = new RC!Communication;//set_input!input
//	
//	inner_RC_commu.event = new RC!Event;
//	inner_RC_commu.event.name = self.event.name + "_out";
//	inner_RC_commu.value = self.value.ref.name.createRCRefExp();
//	inner_RC_commu._type = self._type;

	
//	var inner_prefix = inner_RC_commu.createCommunication(inner_RC_commu.event.name,self._type.name);
	
	var prefix = createOutputCommunication(self.event.name + "_out", self.value, self._type.name);
	
	var prefix_action = createPrefixingAction(prefix, createSkipAction());
	var interrupt_action = createAction2("InterruptAction", "SSTOP".createCallAction(), prefix_action);
		
	return interrupt_action;
}


//CSP Rule 69 - 3:  RC comm.type = simple
operation RC!Communication createCommuSIMPLEAsAction(): Z!InterruptAction{

	var prefix = self.createCommuAsCommunication(self.event.name+"_out","SIMPLE");

	var prefix_action = createPrefixingAction(prefix, createSkipAction());
	
	var circusAction = createAction2("InterruptAction", "SSTOP".createCallAction(), prefix_action);
	
	return circusAction;	

}


//not necessary
//status_out!6; status_out.6
//operation RC!Communication createCommuOUTPUT_SYNCConcreteAsAction(): Z!InterruptAction{
//	
	/*
	CommunicationStmt is an interrupt action in Circus
	left action is SStop
	right action is a prefixing action
	*/
//	var leftAction = "SSTOP".createCallAction();
//			
//	var prefix = self.createCommunication(self.event.name + "_out",self._type.name);
//	var prefix_action = createPrefixingAction(prefix, createSkipAction());
//	
//	var circusAction = createAction2("InterruptAction", leftAction, prefix_action);
//	
//	return circusAction;
//}


//operation Any createCommunication(
//			channel_name:String, 
//			type:String
//			):Z!Communication{
//	var commu;
//	
//	if(self.EClass().name = "Assignment"){
//		commu = self.createAssignmentAsOutputCommunication();
//	} else
//	if(self.EClass().name = "Communication"){
//		commu = self.createCommuAsCommunication(channel_name, type);
//		("line 511, this commu pattern is "+ commu.commPattern).println();
//	}
//	return commu;
//}



operation String createInputField(): Z!InputField{
	var field = new Z!InputField;
	field.varialbeName = self.createZName();
	//var name = new String;
//	if(self._type = CommunicationType#INPUT){
//		inputField.varialbeName = self.parameter.name.createZName();
//	} else
//	if(self._type = CommunicationType#OUTPUT){
//		inputField.varialbeName = self.value.ref.name.createZName();
//	} 
	
	return field;
}


operation RC!Expression createOutputField(): Z!DotField{
	var field = new Z!DotField;
	field.expr = self.createExpr();
	field.outputField = true;
	return field;
}


operation RC!Expression createDotField(): Z!DotField{
	var field = new Z!DotField;
	field.expr = self.createExpr();
	field.outputField = false;
	return field;
}
 
////this is used for the communication statement
//operation RC!Communication createOutputField(): Z!DotField{
//	var field = new Z!DotField;
//	var expr;
//	if(self._type = CommunicationType#INPUT){
//	("self.parameter: "+self.parameter).println();
//		expr = self.parameter.name.createRefExpr(false,false);
//	} else
//	if(self._type = CommunicationType#OUTPUT or self._type = CommunicationType#SYNC){
//
////		if(self.value.type().name = "RefExp"){
////			expr = self.value.ref.name.createRefExpr(false,false);		
////		} else{
////			//expr = self.value.createNumExpr(); //the output can be any expr, not only a var or a concreate number
////			expr = self.value.createExpr();
////		}
//		expr = self.value.createExpr();
//	
//	}
//	field.expr = expr;
//	field.outputField = true;
//	
//	return field;
//}


//operation RC!Communication createDotField(): Z!DotField{
//	var dotField = new Z!DotField;
//	dotField.outputField = false;
//	
//	dotField.expr = self.value.createExpr();
////	if(self.value.type().name = "RefExp"){
////		dotField.expr = self.value.ref.name.createRefExpr(false,false);		
////	} else{
////		dotField.expr = self.value.createNumExpr();
////	}
//	
//	return dotField;
//}




//operation RC!Communication createInputField(): Z!InputField{
//	var inputField = new Z!InputField;
//	var name = new String;
//	if(self._type = CommunicationType#INPUT){
//		inputField.varialbeName = self.parameter.name.createZName();
//	} else
//	if(self._type = CommunicationType#OUTPUT){
//		inputField.varialbeName = self.value.ref.name.createZName();
//	} 
//	
//	return inputField;
//}



//operation RC!Assignment createAssignmentAsOutputCommunication():Z!Communication{
//	var commu = new Z!Communication;
//	
//	commu.commUsage = Z!CommUsage#Normal;
//	commu.indexed = false;
//	commu.multiSych = 0;
//	commu.commPattern = Z!CommPattern#Output;	
//	("line 588 commPattern = "+commu.commPattern).println();
//	commu.channelExpr = ("set_" + self.left.name.name).createRefExpr(false,false);
//	
//	commu.fieldList = new Z!CircusFieldList;
//	commu.fieldList.fields = Sequence{self.right.createOutputField()};
//
//	return commu;
//}


//RoboChart Commu to Circus Commu
operation RC!Communication createCommuAsCommunication(
	channel_name:String,
	type:String
	): Z!Communication{
	
	var commu = new Z!Communication;

	commu.commUsage = Z!CommUsage#Normal;
	commu.indexed = false;
	commu.multiSych = 0;
	commu.channelExpr = channel_name.createRefExpr(false,false);
	commu.fieldList = new Z!CircusFieldList; 
	
	if(type = "INPUT"){ 
		commu.commPattern = Z!CommPattern#Input;
		commu.fieldList.fields = Sequence{self.parameter.name.createInputField()};
//		commu.fieldList.fields = Sequence{self.createInputField()};
	} else
	
	if(type = "OUTPUT"){ 
		commu.commPattern = Z!CommPattern#Output;
		commu.fieldList.fields = Sequence{self.value.createOutputField()};
	} else
	
	if(type = "SIMPLE"){ 
		commu.commPattern = Z!CommPattern#Synch;
		commu.fieldList.fields = Sequence{};		
	} else
	
	if(type = "SYNC"){
		commu.commPattern = Z!CommPattern#Output;
		commu.fieldList.fields = Sequence{self.value.createDotField()};		
	} 
	
	return commu;
}



//CSP Rule 70
operation RC!SeqStatement createSeqStmtAsAction(): Z!CircusAction{
	var seq = self.statements;
	return seq.createSeqAsAction();

}

//CSP Rule 70 - auxilary
operation OrderedSet<Any> createSeqAsAction(): Z!CircusAction{
	var seq = self.clone();
	if(seq.size()= 0){
		return null; //TO DO: need to confirm
	} else
	if(seq.size()= 1){
		//return seq.at(0).createStmtAsAction();
		return seq.at(0).createStmtInContextAsAction();
		
	} else	
	if(seq.size()>1){
//		var leftAction = seq.at(0).createStmtAsAction();
		var leftAction = seq.at(0).createStmtInContextAsAction();
		seq.removeAt(0);
		var rightAction = seq.createSeqAsAction();
		return createAction2("SeqAction", leftAction, rightAction);

	}
}




//CSP Rule 71
operation RC!Skip createSkipStmtAsAction(): Z!InterruptAction{

	var leftAction = "SSTOP".createCallAction();
	var rightAction = createSkipAction();
	var circusAction = createAction2("InterruptAction", leftAction, rightAction);
	
	return circusAction;
}


//CSP Rule 72
//parenthesis is removed in Circus
operation RC!ParStmt createParStmtAsAction(): Z!CircusAction{
	return self.stmt.createStmtInContextAsAction();
}




//CSP Rule 73
operation RC!State createStateActionAsCircusAction(actionType:String): Z!CircusAction{
	
	if(self.stateActionDefined(actionType)){
		var index = self.indexOfStateAction(actionType);
		
		return self.actions.at(index).action.createStmtInContextAsAction();
	} else{
		return createSkipAction();
	}
}

//this is to check if the specific type (actionType) of state action is defined
operation RC!State stateActionDefined(actionType: String): Boolean{
	var bool = false;
	if(self.actions.size()>0){
		for(act in self.actions){
			if(act.type().name = actionType){
				bool = true;
			}
		}
	} 
	return bool;
}




operation RC!State indexOfStateAction(actionType: String): Integer{
	var index = 0;
	
	for(act in self.actions){
		if(act.type().name = actionType){
			return index;
		} else{
			index++;
		}
	}
	
}



//TO DO: to confirm if this is used: No
//operation RC!Communication createCommuAsAction(): Z!CircusAction{
//
//	if(self._type.name = "INPUT"){
//		"this is an INPUT type communication".println();
//		return self.createCommuINPUTAsAction();
//	} else
//
//	if(self._type.name = "OUTPUT" or self.communication._type.name = "SYNC"){
//		"this is an OUTPUT or SYNC type communication".println();
//		return self.createCommuOUTPUT_SYNCRefAsAction();
////		if(self.value.isTypeOf(RefExp)){
////			return self.createCommuOUTPUT_SYNCRefAsAction();
////		} else{
////			return self.createCommuOUTPUT_SYNCConcreteAsAction();
////		}
//	} else
//	
//	if(self._type.name = "SIMPLE"){
//		"this is an SIMPLE type communication".println();
//		return self.createCommuSIMPLEAsAction();
//	} 
//
//}






operation createSkipAction(): Z!SkipAction {
	var skipAction = new Z!SkipAction;
	return skipAction;
}



operation String createRefExpr(explicit: Boolean, mixFix: Boolean): Z!RefExpr{
	var refExpr = new Z!RefExpr;
	refExpr.mixFix = mixFix;
	refExpr.explicit = explicit;
	refExpr.name = self.createZName();
//	refExpr.name.word = self;
	
	return refExpr;

}

operation RC!BooleanExp createBooleanExpr(): Z!RefExpr{
	var boolExpr = new Z!RefExpr;
	boolExpr.mixFix = false;
	boolExpr.explicit = false;
	boolExpr.name = new Z!ZName;
	if(self.value = "true"){
		boolExpr.name.word ="True";
	} else {
		boolExpr.name.word ="False";
	}
	
	return boolExpr;
}


operation RC!FloatExp createFloatExpr(): Z!RefExpr{
	var floatExpr = new Z!RefExpr;
	floatExpr.mixFix = false;
	floatExpr.explicit = false;
	floatExpr.name = new Z!ZName;
	floatExpr.name.word = self.value.asString();
		
	return floatExpr;
}

operation  RC!IntegerExp createNumExpr(): Z!NumExpr{
	var numExpr = new Z!NumExpr;
	numExpr.numeral = new Z!ZNumeral;
	numExpr.numeral.value = self.value;
	
	return numExpr;
}
	
/*
operation RC!Minus createMinusExpr(){
				
	var minus_left = self.left.createNumExpr();
	var minus_right = self.right.createNumExpr();
				
	var minusExpr = new Z!ApplExpr;
	minusExpr.mixFix = true;
				
	minusExpr.leftExpr = "_-_".createRefExpr(false,false);

				
	minusExpr.rightExpr = new Z!TupleExpr;
	minusExpr.rightExpr.exprList = new Z!ZExprList;
	minusExpr.rightExpr.exprList.exprs = Sequence{minus_left, minus_right};
	minusExpr.rightExpr.exprList.exprs.println();
}
*/

/*
operation RC!LessOrEqual createLessOrEqualExpr() {
	var left = self.left.createNumExpr();
	var right = self.right.createNumExpr();
	var lessOrEqualExpr = new Z!ApplExpr;
	lessOrEqualExpr.mixFix = true;
				
	lessOrEqualExpr.leftExpr = "_leq_".createRefExpr(false,false);
							
	lessOrEqualExpr.rightExpr = Sequence{left, right}.createTupleExpr();
}
*/

operation Any createApplExpr(operator: String): Z!ApplExpr{
	var expr = new Z!ApplExpr;
	expr.mixFix = true; //CZT: C.6.21 (Function Operator Application). For example: S + T.
	
	var operand_left = self.left.createExpr();
	var operand_right = self.right.createExpr();

	expr.leftExpr = operator.createRefExpr(false,false);

	expr.rightExpr = Sequence{operand_left, operand_right}.createTupleExpr();	
//	var left = operator.createRefExpr(false,false);
//	var right = Sequence{operand_left, operand_right}.createTupleExpr();	

//	expr.exprList = new Z!ZExprList;
//	expr.exprList.exprs = Sequence{left, right};
	
	return 	expr;
}





//covers Neg, Not
//TO DO: is there other unaryApplExpr?
operation Any createUnaryApplExpr(operator: String): Z!ApplExpr{

	var expr = new Z!ApplExpr;
	expr.mixFix = true;
	
	expr.leftExpr = operator.createRefExpr(false,false);
	
	if(self.isTypeOf(Neg) or self.isTypeOf(Not)){
		expr.rightExpr = self.exp.createExpr();
	} 
		
//	expr.exprList = new Z!ZExprList;
//	expr.exprList.exprs = Sequence{expr.leftExpr, expr.rightExpr};

	return 	expr;
}

operation RC!LessThan createLessThanExpr():Z!ApplExpr{
	return self.createApplExpr("_less_");
}


operation RC!GreaterThan createGreaterThanExpr():Z!ApplExpr{
	return self.createApplExpr("_greater_");
}


operation RC!LessOrEqual createLessOrEqualExpr():Z!ApplExpr{
	return self.createApplExpr("_leq_");
}

operation RC!GreaterOrEqual createGreaterOrEqualExpr():Z!ApplExpr{
	return self.createApplExpr("_geq_");
}

operation RC!Equals createEqualsExpr():Z!ApplExpr{
	return self.createApplExpr("_equals_");
}

operation RC!Different createNequalExpr():Z!ApplExpr{
	return self.createApplExpr("_nequals_");
}


operation RC!And createAndExpr():Z!ApplExpr{
	return self.createApplExpr("_And_");
}

operation RC!Or createOrExpr():Z!ApplExpr{
	return self.createApplExpr("_Or_");
}



operation RC!Iff createIffExpr():Z!ApplExpr{
	return self.createApplExpr("_Equivalence_");
}

operation RC!Implies createImpliesExpr():Z!ApplExpr{
	return self.createApplExpr("_Implies_");
}


operation RC!Plus createPlusExpr():Z!ApplExpr{
	return self.createApplExpr("_+_");
}

operation RC!Minus createMinusExpr():Z!ApplExpr{
	return self.createApplExpr("_-_");
}

operation RC!Mult createMultExpr():Z!ApplExpr{
	return self.createApplExpr("_*_");
}

operation RC!Div createDivExpr():Z!ApplExpr{
	return self.createApplExpr("_div_");
}

operation RC!Modulus createModExpr():Z!ApplExpr{
	return self.createApplExpr("_mod_");
}


operation RC!Not createNotExpr():Z!ApplExpr{
	return self.createUnaryApplExpr("Not_");
}	
 	
operation RC!Neg createNegExpr():Z!ApplExpr{
	return self.createUnaryApplExpr("-_");
}	




//TO DO: shall this be an ApplExpr instead??
operation RC!IfExpression createCondExpr():Z!CondExpr{

}


//TO DO: what class in Z?
operation RC!VarExp createVarExpr():Z!Expr{

}

//TO DO: what class in Z?
operation RC!CallExp createCallExpr():Z!Expr{

}




operation RC!Expression createExpr():Z!Expr{
	if(self.isTypeOf(RC!LessThan)){
		return self.createLessThanExpr();
	} else 
	if(self.isTypeOf(RC!GreaterThan)){
		return self.createGreaterThanExpr();
	} else 
	if(self.isTypeOf(RC!LessOrEqual)){
		return self.createLessOrEqualExpr();
	} else 
	if(self.isTypeOf(RC!GreaterOrEqual)){
		return self.createGreaterOrEqualExpr();
	} else 
	if(self.isTypeOf(RC!Equals)){
		return self.createEqualsExpr();
	} else 
	if(self.isTypeOf(RC!Different)){
		return self.createNequalExpr();
	} else 
	if (self.isTypeOf(RC!And)){
		return self.createAndExpr();
	} else 
	if (self.isTypeOf(RC!Or)){
		return self.createOrExpr();
	} else 
	if (self.isTypeOf(RC!Not)){
		return self.createNotExpr();
	} else 
	if (self.isTypeOf(RC!Plus)){
		return self.createPlusExpr();
	} else 
	if (self.isTypeOf(RC!Minus)){
		return self.createMinusExpr();
	} else 
	if (self.isTypeOf(RC!Mult)){
		return self.createMultExpr();
	} else 
	if (self.isTypeOf(RC!Div)){
		return self.createDivExpr();
	} else
	if (self.isTypeOf(RC!Modulus)){
		return self.createModExpr();
	} else
	if (self.isTypeOf(RC!Neg)){
		return self.createNegExpr();
	} else
	if(self.isTypeOf(RC!Iff)){
	 return self.createIffExpr();
	} else
	if(self.isTypeOf(RC!Implies)){
		return self.createImpliesExpr();
	} else

	if(self.isTypeOf(RC!IntegerExp)){
		return self.createNumExpr();
	} else
	
	if(self.isTypeOf(RC!RefExp)){
		return self.ref.name.createRefExpr(false, false);
	} else
	
	if(self.isTypeOf(RC!BooleanExp)){
		return self.createBooleanExpr();
	} else
	
	if(self.isTypeOf(RC!FloatExp)){
		return self.createFloatExpr();
	} else
	if(self.isTypeOf(RC!ParExp)){
		return self.exp.createExpr();
	} 
//	else
//	
//	//TO DO
//	if(self.isTypeOf(RC!IfExpression) or self.isTypeOf(RC!CallExp)  or self.isTypeOf(RC!ResultExp) or self.isTypeOf(RC!Selection) or self.isTypeOf(RC!EnumExp) or self.isTypeOf(RC!ArrayExp) or self.isTypeOf(RC!TupleExp) or self.isTypeOf(RC!ClockExp) or self.isTypeOf(RC!SeqExp) ){
//		return self.createUnaryExpr();
//	} 

}



operation Sequence<Any> createTupleExpr(): Z!TupleExpr{
	var tupleExpr = new Z!TupleExpr;
	tupleExpr.exprList = new Z!ZExprList;
	tupleExpr.exprList.exprs = self;
	return tupleExpr;

}


//operation RC!Expression createUnaryExpr(): Z!Expr {
	
	//TO DO: to complete the following unaryExpr of RoboChart
	/*
	

	if(self.isTypeOf(CallExp)){
		//self.callExpString().println();
		return self.callExpString();
	} else 
	
	if(self.isTypeOf(ResultExp)){
		return "result";
	} else 
	
	if(self.isTypeOf(Selection)){
		return self.member.name+"("+self.receiver.value.ref.name+"!"+self.receiver.parameters.at(0).ref.name+")";
	} else 
	
	if(self.isTypeOf(EnumExp)){
		return self.literal.name;
	} else 
	
	if(self.isTypeOf(SeqExp)){
		return self.sequenceString();
	} else 
	
	if(self.isTypeOf(ArrayExp)){
		return self.value.ref.name + "."+self.parameters.at(0).value;
		//e.g., vel[1] -> vel.1
	} else 
	
	if(self.isTypeOf(TupleExp)){
		return "("+ self.values.at(0).oneSideOfBianryString()+", "+self.values.at(1).oneSideOfBianryString() +")";
		//e.g., (3,4)
	} else 
	
	if(self.isTypeOf(ClockExp)){
		return "clock";
	}
*/
//}