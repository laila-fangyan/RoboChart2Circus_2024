[%
/*
"TOTAL SIZE".println();
RC!RCPackage.size().println();
var statemachine_name: String;
for (p in RC!RCPackage)
{ 
"PRINT .machines.SIZE".println();
p.machines.size().println();
"PRINT p.machines.at(0).name;".println();
statemachine_name=p.machines.at(0).name;
statemachine_name.println();
}*/
// the code for generating fun with pre and post conditions is kept in 'back up old version/ thy_generationR2.egl'




var stm_name: String;
for (stm in RC!StateMachineDef.allInstances)
{ 
stm_name=stm.name;
}

 var javaDate = new Native("java.text.SimpleDateFormat")("ddMMyyyy_hhmmss").
  format(new Native("java.util.Date"));
 var javaDateString = new String;
 javaDateString= javaDate.toString();

%]
theory [%=stm_name%]_[%=javaDateString%]
imports "Z_Machines.Z_Machine"
begin

subsection \<open> Introduction \<close>

text \<open> This theory file is to model the [%=stm_name%] state machine in Z Machine notations.\<close>

notation undefined ("???")

subsection \<open> type definition \<close>

datatype ('s, 'e) tag =
  State (ofState: 's) | Event (ofEvent: 'e)

abbreviation "is_Event x \<equiv> \<not> is_State x"

type_synonym ('s, 'e) rctrace = "('s, 'e) tag list"

definition wf_rcstore :: "('s, 'e) rctrace \<Rightarrow> 's \<Rightarrow> 's option \<Rightarrow> bool" where
[z_defs]: "wf_rcstore tr st final = (
     length(tr) > 0 
   \<and> tr ! ((length tr) -1) = State st 
   \<and> (final \<noteq> None \<longrightarrow> (\<forall>i<length tr. tr ! i = State (the final) \<longrightarrow> i= (length tr) -1)) 
   \<and> (filter is_State tr) ! (length (filter is_State tr) -1) = State  st)"
   
[%
for (p in RC!RCPackage) {
if (p.name="Chemical" or p.name="lre_beh" or p.name = "EM" or p.name = "SMPackage"){
 
 
 
 
 
 
 
//////////////////////////////////////////////////////////////////////////////////////////////////
//query the states  to generate enumtype
"Query the states".println();
//we assume there is ONLY ONE state machine in the package
//p.machines.at(0).nodes.size().println();
 
var k=0;
//var state_set: OrderedSet;
//type 'Set' is not working as it add the new element in random order, 
//not always add to the end but may insert in the middle somewhere
var enum_output: String;
var set_output: String;

var enum_output_event: String;
var set_output_event: String;

 p.machines.println();




//for (vrl in p.machines.at(0).variableList)
//{var i=0;
//while(i< vrl.vars.size()){

//var variable_string: String;
//if(vrl.vars.at(i).modifier.literal="VAR"){
//if(vrl.vars.at(i).type.isTypeOf(TypeRef)){
//variable_string=vrl.vars.at(i).name+ " :: \"" + vrl.vars.at(i).type.ref.name +"\"";
//}
//else if(vrl.vars.at(i).type.isTypeOf(ProductType)){
//"^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^".println();
//vrl.vars.at(i).name.println();
//vrl.vars.at(i).type.types.at(0).ref.name.println();
//vrl.vars.at(i).type.types.at(1).ref.name.println();
//"^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^".println();
//variable_string=vrl.vars.at(i).name+ " :: \"" + vrl.vars.at(i).type.domain.ref.name +" list\"";
//}}i++;} }



//search for all the states
 for (n in p.machines.at(0).nodes){
 enum_output= enum_output+ n.zmState() +" | ";
set_output= set_output+ n.zmState() +", ";}
 
//to add the context for thy file "enumtype St = "
//to cut the last vertical bar
enum_output= "enumtype St = " + enum_output.substring(0,(enum_output.length()-2));
%]
[%=enum_output%]
[%set_output= "definition [z_defs]: \"St = {" + set_output.substring(0,(set_output.length()-2))+"}\"";
%]
[%=set_output%] 


[%
//to generate enum for events
for (e in p.machines.at(0).events)
{ 
"print out the event names".println();
e.name.println();
 enum_output_event =  enum_output_event+ e.name +" | ";
set_output_event = set_output_event+ e.name +", ";
}

enum_output_event= "enumtype Evt = " + enum_output_event.substring(0,(enum_output_event.length()-2));
%]
[%=enum_output_event%]
[%set_output_event= "definition \"Evt = {" + set_output_event.substring(0,(set_output_event.length()-2))+"}\"";
%]
[%=set_output_event%] 


[%
//////////////////////////////////////////////////////////////////////////////////////////////////
//query the TYPES
"////////////////////////////////////////////////////////////////////////////////".println();
"Query the types".println();
/////////////////////////////////////////////////////////////////////
//for Enumaration type
for (e in p.types)
{
e.type().name.println();
("e.name: " + e.name).println();
 if(e.type().name="Enumeration"){
 var enumtype_output: String;
 var enumtype_set_output: String;
 var i=0;
while(i<e.literals.size()){
//("literal "+ i +": " + e.literals.at(i).name).println();
enumtype_output=enumtype_output+ e.literals.at(i).name +" | ";
enumtype_set_output=enumtype_set_output+ e.literals.at(i).name +", ";
i++;
}
enumtype_output="enumtype "+ e.name + " = "+ enumtype_output.subString(0, (enumtype_output.length()-3));
("final enumtype_output: " +enumtype_output).println();
%]
[%=enumtype_output%]

[%enumtype_set_output="definition \""+ e.name + " = {"+ enumtype_set_output.subString(0, (enumtype_set_output.length()-2))+ "}\"";
("final enumtype_set_output: " +enumtype_set_output).println();%]
[%=enumtype_set_output%]
[%
 }
}

/////////////////////////////////////////////////////////////////////
//for Primitive type
//I repeat "for(e in p.types)" for primitive, record, instead of put all types under one "for(e in p.types)"
//the reason is that I need to generate primitive type first, then the record type which use the primitive type
//in RoboChart these two types can be defined in either order
//but in thy primitive for the record has to be defined first, then be used in record

"query for primitive type".println();
for (e in p.types)
{
 if(e.type().name="PrimitiveType"){
  var primitiveType_output: String;
  primitiveType_output="type_synonym " + e.name + "= \"nat\"";
  primitiveType_output.println();%]
[%=primitiveType_output%]
[%}
 }


/////////////////////////////////////////////////////////////////////
//for Record type
"/////////////////////////////////////////////////////////////////////".println();
"query for record type".println();
for (e in p.types)
{
 if(e.type().name="RecordType")
{%]record [%=e.name%] =
[% // var recordType_output: String;
  var i=0;
while(i<e.fields.size()){
(e.fields.at(i).name + " :: " + e.fields.at(i).Type.ref.name).println();%]
  [%=e.fields.at(i).name%] :: [%=e.fields.at(i).Type.ref.name%]
[%//recordType_output=e.fields.at(i).name + " :: " + e.fields.at(i).Type.ref.name;
i++;
}
("record_default " + e.name).println();%]
record_default [%=e.name%]
[%//recordType_output="record " + e.name + "= "+ recordType_output;
//("recordType_output: " + recordType_output).println();
 }
}
  
/////////////////////////////////////////////////////////////////////
//for Constants
"/////////////////////////////////////////////////////////////////////".println();
"query for constants definition".println(); 
var const_string: String;
//PART 1: transfer all constants in Robochart
for (vrl in p.machines.at(0).variableList)
{
"vrl".println();
vrl.println();

("vrl.vars.size(): "+vrl.vars.size()).println();
 "".println();
//("vrl.var): "+vrl.vars).println();
//vrl.modifier.literal.println();
//vrl.vars.at(i).modifier.literal.println();
//vrl.vars.at(i).modifier.literal.at(0).println();
var i=0;
while(i< vrl.vars.size()){
//vrl.vars.at(i).at(0).type.println();


if(vrl.vars.at(i).modifier.literal="CONST"){

if(vrl.vars.at(i).type.isTypeOf(TypeRef) or vrl.vars.at(i).type.isTypeOf(ProductType)){
const_string="consts "+vrl.vars.at(i).name+ " :: \"" + vrl.vars.at(i).type.zmType() +"\"";
("const_string: " +const_string).println();
 "".println();
}
if(vrl.vars.at(i).type.isTypeOf(SeqType)){
if(vrl.vars.at(i).type.domain.isTypeOf(ProductType)){
vrl.vars.at(i).name.println();

vrl.vars.at(i).type.println();
//ProductType []

vrl.vars.at(i).type.domain.println();
//ProductType []

vrl.vars.at(i).type.domain.type.name.println();
//ProductType

vrl.vars.at(i).type.domain.isTypeOf(ProductType).println();
//true

vrl.vars.at(i).type.domain.types.type().println();
//real
vrl.vars.at(i).type.domain.types.at(0).ref.name.println();
//real
const_string="consts "+ vrl.vars.at(i).name+ " :: \""+ vrl.vars.at(i).type.domain.productString() +" list\"";

} else {
const_string="consts "+vrl.vars.at(i).name+ " :: \"" + vrl.vars.at(i).type.domain.type.zmType() +" list\"";}
}
%][%=const_string%]
  [%
} i++;} }
 
 ////PART 2: generate consts for input events as the possible input set
 //e.g., reqV?reqV, we need a consts as a set of velocity for input, the name is to uppercase the 1st letter of var
 //the name is defined the same as the input var, but Capitalized
 //we need to search all the input events in each transition
 //this is a repeating for generate params section for each transition
 for (tr in p.machines.at(0).transitions){ 

 //CASE 1 input event in transition.trigger
if(tr.trigger.isDefined() and tr.trigger._type.isDefined() and tr.trigger._type.name="INPUT")
{
if(tr.trigger.parameter.type.isTypeOf(TypeRef) or tr.trigger.parameter.type.isTypeOf(ProductType)){
const_string= "consts " + tr.trigger.parameter.name.firstToUpperCase() + " :: \"" + tr.trigger.parameter.type.zmType() + " set\"";
}
else 
////it does not work with if(vrl.vars.at(i).at(0).type=SeqRef), so use the keyword 'domain'
if(tr.trigger.parameter.type.isTypeOf(SeqType)){
const_string= "consts Seq" + tr.trigger.parameter.name.firstToUpperCase() + " :: \"((" + tr.trigger.parameter.type.domain.zmType() + ") list) set\"";

}%][%=const_string%]
  [%
}

//CASE 2 input event in transition.action, and there is only one action
if(tr.action.isDefined() and tr.action.isTypeOf(CommunicationStmt) and  tr.action.communication._type.name="INPUT"){

if(tr.action.communication.parameter.type.isTypeOf(TypeRef) or tr.action.communication.parameter.type.isTypeOf(ProductType)){
const_string= "consts " + tr.action.communication.parameter.name.firstToUpperCase() + " :: \"" + tr.action.communication.parameter.type.zmType() + " set\"";

} 
else if(tr.action.parameter.type.isTypeOf(SeqType)){
const_string= "consts Seq" + tr.action.communication.parameter.name.firstToUpperCase() + " :: \"(" + tr.action.communication.parameter.type.zmType() + " list) set\"";
}
%][%=const_string%]
  [%
}


//CASE 3 input event in transition.action, and there are MULTIPLE actionS
if(tr.action.isDefined() and tr.action.isTypeOf(SeqStatement)){
var i=0;
while(i<tr.action.statements.size())
{
if(tr.action.statements.at(i).isTypeOf(CommunicationStmt) and  tr.action.statements.at(i).communication._type.name="INPUT"){
if(tr.action.statements.at(i).communication.parameter.type.isTypeOf(TypeRef) or tr.action.statements.at(i).communication.parameter.type.isTypeOf(ProductType)){

const_string= "consts " + tr.action.statements.at(i).communication.parameter.name.firstToUpperCase() + " :: \"" + tr.action.statements.at(i).communication.parameter.type.zmType()+ " set\"";
} 
else if(tr.action.parameter.type.isTypeOf(SeqType)){
const_string= "consts Seq" + tr.action.statements.at(i).communication.parameter.name.firstToUpperCase() + " :: \"(" + tr.action.statements.at(i).communication.parameter.type.zmType() + " list) set\"";
}
%][%=const_string%]
  [%
}i++;
}}


//CASE 4 input event in tr.target.action, and there is only one action
/////////////////////
// SHALL  (tr.target.actions.at(0).isTypeOf(EntryAction) or tr.target.actions.at(0).isTypeOf(DuringAction)  BE REMOVED? YES
//TO DO: I CAN DELETE IT RIGHT NOW, BUT NEED TO REGRESSION TEST, SO WAIT FOR LATER
//WHEN GENERATING CONSTANTS, NO NEED TO DISDINGISH ENTRY FOR TARGET STATE  AND DURING AND EXIT FOR SOURCE STATE, BUT IN THE OPERATION, WHEN GENERATE PARAMS, IT IS NEEDED, AS WE ONLY LOOK AT THIS TRANSITION.
////////////////////////////////////
if(tr.target.actions.isDefined()and tr.target.actions.notEmpty() and  (tr.target.actions.at(0).isTypeOf(EntryAction) or tr.target.actions.at(0).isTypeOf(DuringAction)) ){

if(tr.target.actions.at(0).action.isTypeOf(CommunicationStmt) and tr.target.actions.at(0).action.communication._type.name="INPUT"){


if(tr.target.actions.at(0).action.communication.parameter.type.isTypeOf(TypeRef) or tr.target.actions.at(0).action.communication.parameter.type.isTypeOf(ProductType) ){

const_string= "consts " + tr.target.actions.at(0).action.communication.parameter.name.firstToUpperCase()+ " :: \"" + tr.target.actions.at(0).action.communication.parameter.type.zmType() +" set\"";

} 
else if(tr.target.actions.at(0).action.communication.parameter.type.isTypeOf(SeqType)){

const_string= "consts Seq" + tr.target.actions.at(0).action.communication.parameter.name.firstToUpperCase()+ " :: \"(" + tr.target.actions.at(0).action.communication.parameter.domain.type.zmType() +" list) set\"";
}%][%=const_string%]
  [%
}

//CASE 5: input event in tr.target.action, action.isTypeOf(SeqStatement), this is for multiple actions
else if(tr.target.actions.at(0).action.isTypeOf(SeqStatement)){

var i=0;
while(i<tr.target.actions.at(0).action.statements.size())
{

if(tr.target.actions.at(0).action.statements.at(i).isTypeOf(CommunicationStmt) and tr.target.actions.at(0).action.statements.at(i).communication._type.name="INPUT"){
if(tr.target.actions.at(0).action.statements.at(i).communication.parameter.type.isTypeOf(TypeRef) or tr.target.actions.at(0).action.statements.at(i).communication.parameter.type.isTypeOf(ProductType)){

const_string= "consts " + tr.target.actions.at(0).action.statements.at(i).communication.parameter.name.firstToUpperCase()+ " :: \"" + tr.target.actions.at(0).action.statements.at(i).communication.parameter.type.zmType() +" set\"";

} 
else if(tr.target.actions.at(0).action.statements.at(i).parameter.type.isTypeOf(SeqType)){

const_string= "consts Seq" + tr.target.actions.at(0).action.statements.at(i).communication.parameter.name.firstToUpperCase()+ " :: \"(" + tr.target.actions.at(0).action.statements.at(i).communication.parameter.type.zmType() +" list) set\"";
}
%][%=const_string%]
  [%
}

i++;
}

}
}
 
 }
 
 

/////////////////////////////////////////////////////////////////////
//query for functions to generate ABSTRACT func
"/////////////////////////////////////////////////////////////////////".println();
"query for functions".println();%]

text \<open> function definition \<close>

[%
//function card is not used in the GasAnalysis, so I FILTER IT OUT
//another MAJOR reason is that card.type()=SetType
//SetType is the parent of SeqType, 
//so it has property 'domain' too
//currently, I am using the difference in the property between SeqType and other TypeRef
//but both SetType and SeqType has domain.
//For GasAnalysis use case, it is okay,
//but for other use cases, if both types are used, I then have to find another way to differentiate them

//TO Transform functions into CONSTS for the UNSPECIFIED Functions
//for (f in p.functions.select(s|s.name!="card" and s.preconditions.isEmpty() and s.postconditions.isEmpty))
//the 2 lines above is for generating abstract fun when unspecified.
//in this version, we convert all fun of specified and unspeicified into abstract
for (f in p.functions.select(s|s.name!="card"))
{ 

var func_type:String;
var function_string: String;

if(f.type.isTypeOf(ProductType) or f.type.isTypeOf(TypeRef)){
func_type=f.type.zmType();
} else if(f.type.isTypeOf(SeqType)){
if(f.type.domain.isTypeOf(ProductType)){
func_type="("+ f.type.domain.zmType()+")";}
else if(f.type.domain.isTypeOf(TypeRef)){
func_type=f.type.domain.zmType();
}
}
//f.name.println();
//f.type.ref.name.println();
//f.parameters.size().println();
//f.parameters.at(0).name.println();
//be CAREFUL, type and type() are different
//type is the property, to return the type defined in the use case
//type() is the method, to return the class in the metamodel
//they return different value: SeqType, parameter
//f.parameters.at(0).type.println();
//f.parameters.at(0).type().println();
//f.parameters.at(0).type().name.println();


//CASE 1: single parameter
//pattern: consts f.name :: " parameter_type => f.type"
if(f.parameters.size()=1){

//TO DO
//here I only consider the parameter type to be SeqType
// I have not consider the function type to be SetType
if(f.parameters.at(0).type.isTypeOf(SeqType)){
"this is a SeqType".println();
if(f.parameters.at(0).type.domain.isTypeOf(ProductType)){
function_string="consts "+f.name+ " :: \" "+ f.parameters.at(0).type.domain.zmType()+" list \\<Rightarrow> "+ func_type+"\"";
} else {
("consts "+f.name+ " :: \" "+ f.parameters.at(0).type.domain.zmType() +" list \\<Rightarrow> "+ func_type+"\"").println();
function_string="consts "+f.name+ " :: \" "+ f.parameters.at(0).type.domain.zmType() +" list \\<Rightarrow> "+ func_type+"\"";}
} 
 if(f.parameters.at(0).type.isTypeOf(TypeRef) or f.parameters.at(0).type.isTypeOf(ProductType)){
("consts "+f.name+ " :: \" "+ f.parameters.at(0).type.zmType() +" \\<Rightarrow> "+ func_type+"\"").println();
//function_string= "consts "+f.name+ " :: \" "+ f.parameters.at(0).type.ref.name +" \\<Rightarrow> "+ f.type.ref.name+"\"";
function_string= "consts "+f.name+ " :: \" "+ f.parameters.at(0).type.zmType() +" \\<Rightarrow> "+ func_type+"\"";
}
}
//CASE 2: multiple parameters, we will need pXp pattern in ZM
//pattern: consts f.name :: " parameter_type (X parameter_type)* => f.type"
else if(f.parameters.size()>1){

// generate the first part of parameter
if(f.parameters.at(0).type.isTypeOf(SeqType)){
if(f.parameters.at(0).type.domain.isTypeOf(ProductType)){
function_string= f.parameters.at(0).type.domain.zmType()+" list";
} else {
function_string= f.parameters.at(0).type.domain.zmType() +" list";}
} 
 if(f.parameters.at(0).type.isTypeOf(TypeRef) or f.parameters.at(0).type.isTypeOf(ProductType)){
function_string= f.parameters.at(0).type.zmType();
} 


// generate the rest part of parameter: (X parameter_type)*
var i=1;
while(i<f.parameters.size()){


if(f.parameters.at(i).type.isTypeOf(SeqType)){
"SeqType domain: ".println();
if(f.parameters.at(i).type.domain.isTypeOf(ProductType)){
function_string= function_string+" \\<times> " +f.parameters.at(i).type.domain.productString()+ " list";
} else {
f.parameters.at(i).type.domain.ref.name.println();
function_string=function_string+" \\<times> " + f.parameters.at(i).type.domain.zmType()+ " list";}
} 
if(f.parameters.at(i).type.isTypeOf(TypeRef)){
f.parameters.at(i).type.zmType().println();
function_string=function_string+" \\<times> " + f.parameters.at(i).type.zmType();
} 
if(f.parameters.at(i).type.isTypeOf(ProductType)){
function_string=function_string+" \\<times> " + f.parameters.at(i).type.zmType();
}

i++;
}
function_string="consts "+f.name+ " :: \" "+function_string+" \\<Rightarrow>"+ func_type+"\"";
"OUTPUT FUNCTION STRING:".println();
function_string.println();

}

%]
[%=function_string%]
[%

//if(f.preconditions.isDefined()){
//f.preconditions.println();}
//if(f.postconditions.isDefined()){
//f.postconditions.println();}
//"OUTPUT:".println();
//("consts "+f.name + " :: \""+
}
%]

subsection \<open> State Space \<close>
[%/////////////////////////////////////////////////////////////////////
//query for the statemachine and variables and consts TO generate zstore
"/////////////////////////////////////////////////////////////////////".println();
"variable query TO generate zstore".println();
var stm_name: String;
for (stm in p.machines){ 
//("stm.name: "+stm.name).println();
stm_name=stm.name;
}%]

zstore [%=stm_name%] =
[%
//Part 1 of zstore is variables from variableLsit
"&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&".println();
for (vrl in p.machines.at(0).variableList)
{
"vrl".println();
vrl.println();

("vrl.vars.size(): "+vrl.vars.size()).println();
 "".println();
//("vrl.var): "+vrl.vars).println();
//vrl.modifier.literal.println();
//vrl.vars.at(i).modifier.literal.println();
//vrl.vars.at(i).modifier.literal.at(0).println();
var i=0;
while(i< vrl.vars.size()){
//vrl.vars.at(i).at(0).type.println();
var variable_string: String;
if(vrl.vars.at(i).modifier.literal="VAR"){
if(vrl.vars.at(i).type.isTypeOf(TypeRef) or vrl.vars.at(i).type.isTypeOf(ProductType)){
variable_string=vrl.vars.at(i).name+ " :: \"" + vrl.vars.at(i).type.zmType() +"\"";
//("variable_string: " +variable_string).println();
}
else if(vrl.vars.at(i).type.isTypeOf(SeqType)){
if(vrl.vars.at(i).type.domain.isTypeOf(ProductType)){
variable_string=vrl.vars.at(i).name+ " :: \" " + vrl.vars.at(i).type.domain.productString() +" list\"";} else 
variable_string=vrl.vars.at(i).name+ " :: \"" + vrl.vars.at(i).type.domain.zmType() +" list\"";
}
}%]  [%=variable_string%]
  [%i++;} }
%]  st::"St"
  tr :: "(St, Evt) tag list"
  trg:: "Evt option"
  triggers:: "Evt set"
  where inv: 
    "wf_rcstore tr st (Some final)"

subsection \<open> Operations \<close>

zoperation Trigger= 
params trigger \<in> "triggers"
pre "triggers \<noteq> {}"
update "[
        trg\<Zprime>= Some trigger
        ]"
        
[%







/////////////////////////////////////////////////////////////////////
//query for the transitions TO zoperations
"/////////////////////////////////////////////////////////////////////".println();
"transitions query TO generate zoperations".println();
//zoperations_string is used for zmachine section
//zoperations_set is used for the lemma of structural invariant section
var zoperations_string:String;
var zoperations_set: OrderedSet;
var zop_name: String;

//this para_string is a set to contain all the parameter in para segment, and will be used for lemma generation

for (tr in p.machines.at(0).transitions){ 
var para_string: OrderedSet;

"START NEW TRANSITION QUERY".println();
("tr.name: "+tr.name).println();

//firstToUpperCase() is used to convert all the state names start with captical letter
//the reason is that the name of operation in ZM has to be capitalized, otherwise return errors.
zop_name=tr.source.name.firstToUpperCase()+"To"+tr.target.name.firstToUpperCase();
zop_name.println();
var indexOfOp=1;

//for multiple transitions between same source and target, we add index
//e.g., MOMToOCM_2
while (zop_name.isSubstringOf(zoperations_string)){
zop_name =tr.source.name.firstToUpperCase()+"To"+tr.target.name.firstToUpperCase()+"_"+indexOfOp.asString();
indexOfOp++;
}

//**************************************************************
//to define a tuple for this transition to link the hasPara with the zop
//this is for the lemma generation. If a zoperation has a para, then we need l in the lemma
//if zoperation has no para, then we add () in the lemma
var zop_tuple = new Tuple;
zop_tuple.name = zop_name;
zop_tuple.hasPara = false;
zop_tuple.paras = para_string;


zoperations_string=zoperations_string+" "+ zop_name;

%]
zoperation [%=zop_name%] =
  over [%=stm_name%]
[%
//////////////////////////////////////////////////////
//query for the transitions TO generate params section using Input type events
//zop_tuple is used to generate parameter in the update section
//CASE 1 input event in transition.trigger
//we assume there is only one input event as trigger
var params_string:String;

params_string="";
if(tr.trigger.isDefined() and tr.trigger._type.isDefined() and tr.trigger._type.name="INPUT")
{


if(tr.trigger.parameter.type.isTypeOf(TypeRef) or tr.trigger.parameter.type.isTypeOf(ProductType)){
params_string=params_string+ tr.trigger.parameter.name+"_input \\<in> \"" + tr.trigger.parameter.name.firstToUpperCase() +"\" ";
}
else 
////it does not work with if(vrl.vars.at(i).at(0).type=SeqRef), so use the keyword 'domain'
if(tr.trigger.parameter.type.isTypeOf(SeqType)){
params_string= params_string+ tr.trigger.parameter.name+"_input \\<in> \"Seq" + tr.trigger.parameter.name.firstToUpperCase() +"\" ";
}

zop_tuple.hasPara = true;
zop_tuple.paras.add(tr.trigger.parameter.name);
}

//CASE 2 input event in transition.action, and there is only one action
if(tr.action.isDefined() and tr.action.isTypeOf(CommunicationStmt) and  tr.action.communication._type.name="INPUT"){



if(tr.action.communication.parameter.type.isTypeOf(TypeRef) or tr.action.communication.parameter.type.isTypeOf(ProductType)){
params_string=params_string + tr.action.communication.parameter.name+"_input \\<in> \"" + tr.action.communication.parameter.name.firstToUpperCase()+"\" ";
} 
else if(tr.action.parameter.type.isTypeOf(SeqType)){
params_string=params_string + tr.action.communication.parameter.name+"_input \\<in> \"Seq" + tr.action.communication.parameter.name.firstToUpperCase() +"\" ";
}
zop_tuple.hasPara = true;
zop_tuple.paras.add(tr.action.communication.parameter.name);
}


//CASE 3 input event in transition.action, and there are MULTIPLE actionS
if(tr.action.isDefined() and tr.action.isTypeOf(SeqStatement)){
var i=0;
while(i<tr.action.statements.size())
{
if(tr.action.statements.at(i).isTypeOf(CommunicationStmt) and  tr.action.statements.at(i).communication._type.name="INPUT"){
if(tr.action.statements.at(i).communication.parameter.type.isTypeOf(TypeRef) or tr.action.statements.at(i).communication.parameter.type.isTypeOf(ProductType)){
params_string=params_string + tr.action.statements.at(i).communication.parameter.name+"_input \\<in> \"" + tr.action.statements.at(i).communication.parameter.name.firstToUpperCase() +"\" ";
} 
else if(tr.action.parameter.type.isTypeOf(SeqType)){
params_string=params_string + tr.action.statements.at(i).communication.parameter.name+"_input \\<in> \"Seq" + tr.action.statements.at(i).communication.parameter.name.firstToUpperCase() +"\" ";
}

zop_tuple.hasPara = true;
zop_tuple.paras.add(tr.action.statements.at(i).communication.parameter.name);


}i++;
}}


//CASE 4 input event in tr.target.action, and there is only one action
if(tr.target.actions.isDefined() and  tr.target.actions.notEmpty()and (tr.target.actions.at(0).isTypeOf(EntryAction) or tr.target.actions.at(0).isTypeOf(DuringAction)) ){

if(tr.target.actions.at(0).action.isTypeOf(CommunicationStmt) and tr.target.actions.at(0).action.communication._type.name="INPUT"){


if(tr.target.actions.at(0).action.communication.parameter.type.isTypeOf(TypeRef) or tr.target.actions.at(0).action.communication.parameter.type.isTypeOf(ProductType)){
params_string=params_string + tr.target.actions.at(0).action.communication.parameter.name + "_input \\<in> \"" + tr.target.actions.at(0).action.communication.parameter.name.firstToUpperCase() +"\" ";
} 
else if(tr.target.actions.at(0).action.communication.parameter.type.isTypeOf(SeqType)){
params_string=params_string + tr.target.actions.at(0).action.communication.parameter.name + "_input \\<in> \"Seq" + tr.target.actions.at(0).action.communication.parameter.name.firstToUpperCase() +"\" ";
}
zop_tuple.hasPara = true;
zop_tuple.paras.add(tr.target.actions.at(0).action.communication.parameter.name);
}

//CASE 5: input event in tr.target.action, action.isTypeOf(SeqStatement), this is for multiple actions
else if(tr.target.actions.at(0).action.isTypeOf(SeqStatement)){

var i=0;
while(i<tr.target.actions.at(0).action.statements.size())
{

if(tr.target.actions.at(0).action.statements.at(i).isTypeOf(CommunicationStmt) and tr.target.actions.at(0).action.statements.at(i).communication._type.name="INPUT"){
if(tr.target.actions.at(0).action.statements.at(i).communication.parameter.type.isTypeOf(TypeRef) or tr.target.actions.at(0).action.statements.at(i).communication.parameter.type.isTypeOf(ProductType)){
params_string=params_string + tr.target.actions.at(0).action.statements.at(i).communication.parameter.name+"_input \\<in> \"" + tr.target.actions.at(0).action.statements.at(i).communication.parameter.name.firstToUpperCase() +"\" ";
} 
else if(tr.target.actions.at(0).action.statements.at(i).parameter.type.isTypeOf(SeqType)){
params_string=params_string + tr.target.actions.at(0).action.statements.at(i).communication.parameter.name+"_input \\<in> \"Seq" + tr.target.actions.at(0).action.statements.at(i).communication.parameter.name.firstToUpperCase() +"\"";
}

zop_tuple.hasPara = true;
zop_tuple.paras.add(tr.target.actions.at(0).action.statements.at(i).communication.parameter.name);
}

i++;
}

}
}


/////////////////////////////////////////////////
//TO DO: ADD SOURCE STATE OF ENTRY EVENTS
////////////////////////////////////////////////



if(zop_tuple.hasPara){%]
  params [%=params_string %]
[%
}




zoperations_set.add(zop_tuple);


//////////////////////////////////////////////////////
//query the transitions TO generate pre section
//SUBSECTION 1: state constraint: current state st(source) 
var pre_string: String;


pre_string="pre \"st= "+tr.source.zmState();

//SUBSECTION 2: transition condition -> pre
if (tr.condition.isDefined() )
{
("tr.condition: " + tr.condition).println();

pre_string=pre_string+" \\<and> "+ tr.condition.binaryExpString();

}

//this var is to collect all the events and the target states for 'tr'
//and we start from trigger event here
//the complete order is: trigger_event, tran_action_event, tgt_st_action_entry_event, tgt_st_action_during_event, tgt_St
var tr_string:String;

//SUBSECTION 3:transition trigger of Simple/input/output event  -> this should be converted to a 'pre' section AND add the event into tr string.
if(tr.trigger.isDefined()and tr.trigger.event.isDefined() ){


pre_string=pre_string+" \\<and> trg=Some "+ tr.trigger.event.name;
tr_string= "@ [Event "+tr.trigger.event.name+"]";
}


//SUBSECTION 4:transition reset  to pre (TIME property)
if(not tr.reset.isEmpty() ){
tr.name.println();
tr.reset.clock.name.println();
pre_string=pre_string+" \\<and> clock=0";
}



pre_string=pre_string+"\"";
pre_string.println();
%]
  [%=pre_string%]
[%

//////////////////////////////////////////////////////
//query for the transitions TO generate UPDATE section
//SUBSECTION 0:state update----ROMOVED, kept in old version


//we assume there is always update section in zoperation
//because we create zoperation according to the transitions
//the only exception is the Shine operation for the animation purpose
//if we allow zoperation without update section
//then we need to add an IF condition on top of the update section
//if(cond1 and cond2 and cond3) {}

%]
  update "[st\<Zprime>= [%=tr.target.zmState()%]
  		  [%

if(zop_tuple.hasPara){
for (p in zop_tuple.paras){
%]
         ,[%=p%]\<Zprime> =[%=p%]_input
[%}}


//SUBSECTION 2:source state exit ation to "tr" of update section
//TO DO (2023.3.13)
//THIS IS OMITTED BECAUSE THERE IS NO EXIT ACTION IN ALL THE EXAMPLES.


//SUBSECTION 2:transition action to update
if (tr.action.isDefined() )
{
//("tr.action: " + tr.action).println();
var tr_action_string:String;

//CASE 1: "SeqStatement" means there are MORE THAN ONE actions.
//output type events are negleted HERE, and covered in tr section
if(tr.action.isTypeOf(SeqStatement)){
//tr.action.statements.println();
//"tr.action.statements.size():".println();
var i=0;
while(i<tr.action.statements.size())
{

//here I only consider the assignment action
//so there is only one condition on the top as if(tr.action.statements.at(i).isTypeOf(Assignment)),
//and  no "else if" followed
//if the use case has other type of action that needs transformation
//I will add a new IF section after this IF 
if(tr.action.statements.at(i).isTypeOf(Assignment)){
//"left type:".println();

//tr.action.statements.at(i).left.type().println();
//"left type:".println();
//tr.action.statements.at(i).right.type().println();
"tr.action.assignment left.name.name: ".println();
tr.action.statements.at(i).left.name.name.println();


//In GasAnalysis there are 3 different assignment in the transition actions
//The left is always the same: type is VarRef, the query code is left.name.name
//but for the assignment.right we now have 3 types:
//SeqExp, EnumExp, CallExp
// so we need three IF to cover these 3 different types
//if there are new types later on, we need to add more

//CASE a, there is no input event in this transition
//this is the default setting: "not zop_tuple.hasPara"
tr_action_string=","+tr.action.statements.at(i).left.name.name+"\\<Zprime> = "+tr.action.statements.at(i).right.oneSideOfBianryString();

//CASE b, there is input event, we need to use var_input instead of var
for (p in zop_tuple.paras){
if(p.isSubstringOf(tr_action_string))
//then it means input var is used as parameter in an assignment
{tr_action_string=tr_action_string.replace(p, (p+"_input"));
}
} 

} else if(tr.action.statements.at(i).isTypeOf(CommunicationStmt)){
//TO DO: DO I NEED THIS 'IF' BELOW?
//WHY DID I EXCLUDE SYNC TYPE? 2023.3
if(tr.action.statements.at(i).communication._type.name="SIMPLE" or tr.action.statements.at(i).communication._type.name="INPUT" or tr.action.statements.at(i).communication._type.name="OUTPUT"){
tr_string=tr_string+"@ [Event "+tr.action.statements.at(i).communication.event.name +"]";
}

}
i++;


}
//"tr.action.statements.at(0)".println();
//tr.action.statements.at(0).println();
//"tr.action.statements.at(1):".println();
//tr.action.statements.at(1).println();

}


//CASE 2: single action in tr.actions, type = CommunicationStmt
//in GA use case, the single action is the type of CommunicationStmt
//all are events,
//this else if is to map L808 'if(tr.action.isTypeOf(SeqStatement))' for the situation of multiple actions
//besides this else if,  can be more else IF
//but in the GA and movement example, we only need this else IF
//so more ELSE IF can be added later for new cases
else if(tr.action.isTypeOf(CommunicationStmt)){
//TODO
//currently, I don't consider the output or input event in the actions.
//the input event can exist in transition action, but 
// is considered in the 'para' segment 

if(tr.action.communication._type.name="SIMPLE" or tr.action.communication._type.name="INPUT" or tr.action.communication._type.name="OUTPUT"){
tr_string=tr_string+"@ [Event "+tr.action.communication.event.name +"]";
}
}

//CASE 3 single action in tr.actions, type = assignment
else if(tr.action.isTypeOf(Assignment)){
//case a, no input event involved, i.e. we do not need an input parameter as a function parameter
tr_action_string=","+tr.action.left.name.name+"\\<Zprime> = "+tr.action.right.oneSideOfBianryString();
//CASE b, there is input event, we need to use var_input instead of var
for (p in zop_tuple.paras){
if(p.isSubstringOf(tr_action_string))
//then it means input var is used as parameter in an assignment
{tr_action_string=tr_action_string.replace(p, (p+"_input"));
}
} 
}
%]
         [%=tr_action_string%]
[%
}


/////////////////////////////////////////////////////////////////////
//query for the target state enter action TO generate update section
//TO DO
//currently, only cover the types of actions used in GasAnalysis
//i.e. the assignment with right=callexp
//I need to generate an operation for tr.action and tr.target.action
//to cover as many types as possible and to simplify the codes
//in this version, tr.action has more types than tr.target.aciton

// we can not use if(tr.target.actions.isDefined()), it returns True no matter there is state actions or not.
if(tr.target.actions.isDefined() and tr.target.actions.notEmpty() and (tr.target.actions.at(0).isTypeOf(EntryAction) or tr.target.actions.at(0).isTypeOf(DuringAction)) ){

("tr.target.actions.size:" +tr.target.actions.size()).println();
("tr.target.actions:" +tr.target.actions.at(0)).println();
//tr.target.actions.at(0).isTypeOf(Assignment).println();
//tr.target.actions.at(0).isTypeOf(Statement).println();
//tr.target.actions.at(0).isTypeOf(Action).println();
tr.target.actions.at(0).type().println();
tr.target.actions.at(0).action.println();

var target_action_string: String;

//CASE 1: action.isTypeOf(Assignment)

if(tr.target.actions.at(0).action.isTypeOf(Assignment)){
//to get the left parameter
tr.target.actions.at(0).action.left.name.name.println();
//tr.target.actions.at(0).action.right.args.size().println();

//CASE a, there is no input event involved in this target action
//this is the default setting: "not zop_tuple.hasPara"
target_action_string=tr.target.actions.at(0).action.left.name.name+"\\<Zprime> ="+tr.target.actions.at(0).action.right.oneSideOfBianryString();


//CASE b, there is input event involved, we need to use var_input instead of var
for (p in zop_tuple.paras){
if(p.isSubstringOf(target_action_string))
//then it means input var is used as parameter in an assignment
{target_action_string=target_action_string.replace(p, (p+"_input"));
}
} 

%]
         ,[%=target_action_string%]
[%
}
//CASE 2: action.isTypeOf(Call)
//the action is an operation
else if(tr.target.actions.at(0).action.isTypeOf(Call)){
target_action_string=tr.target.actions.at(0).action.callString();
%]
          ,[%=target_action_string%]
[%
}


//CASE 3: action.isTypeOf(CommunicationStmt)
//the action is an event
else if(tr.target.actions.at(0).action.isTypeOf(CommunicationStmt)){

if(tr.target.actions.at(0).action.communication._type.name="SIMPLE" or tr.target.actions.at(0).action.communication._type.name="INPUT" or tr.target.actions.at(0).action.communication._type.name="OUTPUT"){
target_action_string="event_"+tr.target.actions.at(0).action.communication.event.name +"\\<Zprime> = True";


tr_string=tr_string+"@ [Event "+tr.target.actions.at(0).action.communication.event.name +"]";
}
}

//CASE 4: action.isTypeOf(SeqStatement), this is for multiple actions
else if(tr.target.actions.at(0).action.isTypeOf(SeqStatement)){

var i=0;
while(i<tr.target.actions.at(0).action.statements.size())
{
if(tr.target.actions.at(0).action.statements.at(i).isTypeOf(Assignment)){

//CASE a, there is no input event involved in this target action
target_action_string=tr.target.actions.at(0).action.statements.at(i).left.name.name+"\\<Zprime> ="+tr.target.actions.at(0).action.statements.at(i).right.oneSideOfBianryString();

//CASE b, there is input event involved, we need to use var_input instead of var
for (p in zop_tuple.paras){
if(p.isSubstringOf(target_action_string))
//then it means input var is used as parameter in an assignment
{target_action_string=target_action_string.replace(p, (p+"_input"));
}
} 
%]
          ,[%=target_action_string%]
[%}
else if(tr.target.actions.at(0).action.statements.at(i).isTypeOf(Call)){
//TODO
target_action_string=tr.target.actions.at(0).action.statements.at(i).callString();
%]
          ,[%=target_action_string%]
[%}

else if(tr.target.actions.at(0).action.statements.at(i).isTypeOf(CommunicationStmt)){
if(tr.target.actions.at(0).action.statements.at(i).communication._type.name="SIMPLE" or tr.target.actions.at(0).action.statements.at(i).communication._type.name="INPUT" or tr.target.actions.at(0).action.statements.at(i).communication._type.name="OUTPUT"  ){
tr_string=tr_string+"@ [Event "+tr.target.actions.at(0).action.statements.at(i).communication.event.name  +"]";

}
}

else if(tr.target.actions.at(0).action.statements.at(i).isTypeOf(Wait)){
//TODO
target_action_string="clock\\<Zprime> = clock + "+tr.target.actions.at(0).action.statements.at(i).duration.binaryExpString();
%]
          ,[%=target_action_string%]
[%
}

i++;
}
}
}
%]         ,tr\<Zprime> =tr [%=tr_string%] @ [State [%=tr.target.zmState()%]]
         ,trg\<Zprime> = None
[% // next to generate 'trigger'   TODO
var triggers_string;
var numOfNewTrig=0;
//t in for loop is the new transition to be identified
//tr in select method is the transition we are processing for zop
//we need to find the new transitions that take the target state of the current
//transition as the source state of other transitions
for(t in p.machines.at(0).transitions.select(t|t.source.name=tr.target.name)){
if  (t.trigger.isDefined()and t.trigger.event.isDefined() and numOfNewTrig=0)
{numOfNewTrig++;
triggers_string=t.trigger.event.name;}
else if  (t.trigger.isDefined()and t.trigger.event.isDefined() and numOfNewTrig>=1)
{numOfNewTrig++;
triggers_string=triggers_string+", "+t.trigger.event.name;}
}     
%]         ,triggers\<Zprime> = {[%=triggers_string%]}
         ]"
        
[%
//'}' in the line below is the close end of transition for loop
}
%]

  
definition Init :: "[%=stm_name%] subst" where
  [z_defs]:
  "Init = 
  [st\<leadsto> ,
   tr\<leadsto> ,
   trg\<leadsto> ,
   triggers\<leadsto> ,
   ]"
(*To be filled in by user*)
  
  
zmachine [%=stm_name%]Machine =
  init Init
  invariant [%=stm_name%]_inv
  operations [%=zoperations_string%] 



subsection \<open> Structural Invariants \<close>

lemma Init_inv [hoare_lemmas]: "Init establishes [%=stm_name%]_inv"
  by zpog_full

[%
var n=0;
while (n<zoperations_set.size())
{
if(zoperations_set.at(n)!="initial"){
if(zoperations_set.at(n).hasPara){

%]
lemma [%=zoperations_set.at(n).name%]_inv [hoare_lemmas]: "[%=zoperations_set.at(n).name%] [%=zoperations_set.at(n).paras.toparathString()%] preserves [%=stm_name%]_inv"
  by (zpog_full; auto)
  
[%
} else if(not zoperations_set.at(n).hasPara){
%]
lemma [%=zoperations_set.at(n).name%]_inv [hoare_lemmas]: "[%=zoperations_set.at(n).name%]() preserves [%=stm_name%]_inv"
  by (zpog_full; auto)
  
[%

}

}
n++;
}


%]

subsection \<open> Safety Requirements \<close>

zexpr R1 is ""

lemma  "Init establishes R1"
  by zpog_full

[%
var n=0;
while (n<zoperations_set.size())
{
if(zoperations_set.at(n)!="initial"){
if(zoperations_set.at(n).hasPara){

%]
lemma "[%=zoperations_set.at(n).name%] [%=zoperations_set.at(n).paras.toparathString()%] preserves R1 under [%=stm_name%]_inv"
  by (zpog_full; auto)
  
[%
} else if(not zoperations_set.at(n).hasPara){
%]
lemma "[%=zoperations_set.at(n).name%]() preserves R1 under [%=stm_name%]_inv"
  by (zpog_full; auto)
  
[%

}

}
n++;
}
%]

definition [z_defs]: "[%=stm_name%]_axioms = ()"

lemma [%=stm_name%]_deadlock_free: "[%=stm_name%]_axioms  \<Longrightarrow> deadlock_free [%=stm_name%]Machine" 
  unfolding [%=stm_name%]Machine_def
  by deadlock_free
 [%
// '}' in the line below is the close end of package scope: if (p.name="Chemical")
} 
}
%]
end

[%
operation OrderedSet toparathString(): String{
var str:String;
str=self.at(0);
var i=1;
while(i<self.size()){
str= str+", "+self.at(i);
i++;
}
str="("+str + ")";
return str;
}
%]








[*convert initial state name from i1 to initial, final j1 to final*]
[%
operation RC!Node zmState(): String{
  if(self.isTypeOf(Initial)){
  return "initial";
  } else if(self.isTypeOf(Final)){
    return "final";
  } else{
  return self.name;
  }
  }%]
  

[*convert initial state name from i1 to Initial, final j1 to Final, BUT replaced by firstToUpperCase()
so this operation is useless.*]
[%
operation RC!Node zmStateCapt(): String{
  if(self.isTypeOf(Initial)){
  return "Initial";
  } else if(self.isTypeOf(Final)){
    return "Final";
  } else{
  return self.name;
  }
  }%]
  
  
[*convert boolean type to bool type, real to integer*]
[%
operation RC!Type zmType(): String{
  if(self.isTypeOf(ProductType)){
  return "("+self.types.at(0).zmType() + "\\<times>" + self.types.at(1).zmType()+")";
  } else if(self.ref.name="boolean"){
  return "bool";
  } else if(self.ref.name="real"){
  return "integer";
  } else  {  
  return self.ref.name;
  }
  }%]
  
  
  
[%
operation RC!Expression binaryExpString(): String{
//"self.type".println();
//self.type.println();
if(self.isTypeOf(LessThan)){
return self.lessThanString();}
else if(self.isTypeOf(GreaterThan)){
return self.greaterThanString();}
else if(self.isTypeOf(LessOrEqual)){
return self.lessOrEqualString();}
else if(self.isTypeOf(GreaterOrEqual)){
return self.greaterOrEqualString();}
else if(self.isTypeOf(Equals)){
return self.equalsString();}
else if(self.isTypeOf(Different)){
return self.notequalsString();}
else if (self.isTypeOf(And)){
return self.andString();}
else if (self.isTypeOf(Or)){
return self.orString();}
else if (self.isTypeOf(Not)){
return self.notString();}
else if (self.isTypeOf(Plus)){
return self.plusString();}
else if (self.isTypeOf(Minus)){
return self.minusString();}
else if (self.isTypeOf(Mult)){
return self.multString();}
else if(self.isTypeOf(IntegerExp) or self.isTypeOf(RefExp) or self.isTypeOf(BooleanExp) or self.isTypeOf(CallExp)  or self.isTypeOf(ResultExp) or self.isTypeOf(Selection) or self.isTypeOf(EnumExp) or self.isTypeOf(ArrayExp) or self.isTypeOf(TupleExp) or self.isTypeOf(ClockExp) or self.isTypeOf(SeqExp) ){
return self.oneSideOfBianryString();}
else if(self.isTypeOf(ParExp)){
return self.exp.binaryExpString();
}
}
%]
[%

operation RC!Expression lessThanString(): String{
return self.left.binaryExpString() +"<" + self.right.binaryExpString();
}
%]

[%
operation RC!Expression lessOrEqualString(): String{
return self.left.binaryExpString() +"\\<le>" + self.right.binaryExpString();
}
%]

[%
operation RC!Expression greaterThanString(): String{
return self.left.binaryExpString() +">" + self.right.binaryExpString();
}
%]

[%
operation RC!Expression greaterOrEqualString(): String{
return self.left.binaryExpString() +"\\<ge>" + self.right.binaryExpString();
}
%]

[%
operation RC!Expression equalsString(): String{
return self.left.binaryExpString() +"= (" + self.right.binaryExpString()+")";
}
%]

[%
operation RC!Expression notequalsString(): String{
return self.left.binaryExpString() +" \\<noteq> (" + self.right.binaryExpString()+")";
}
%]

[%
operation RC!Expression andString(): String{
return self.left.binaryExpString() +" \\<and> " + self.right.binaryExpString();
}
%]

[%
operation RC!Expression orString(): String{
return "("+self.left.binaryExpString() +" \\<or> " + self.right.binaryExpString()+")";
}
%]

[%
operation RC!Expression notString(): String{
return "\\<not>" + self.exp.binaryExpString();
}
%]

[%
operation RC!Expression plusString(): String{
return "("+self.left.binaryExpString() +" + " + self.right.binaryExpString()+")";
}
%]

[%
operation RC!Expression minusString(): String{
return "("+self.left.binaryExpString() +" - " + self.right.binaryExpString()+")";
}
%]


[%
operation RC!Expression multString(): String{
return "("+self.left.binaryExpString() +" * " + self.right.binaryExpString()+")";
}
%]
[%
//DONE
//to return the string of left or right expression string of the binary expression
//currently covers 3 types: Integer, RefExp, CallExp
operation RC!Expression oneSideOfBianryString(): String{
if(self.isTypeOf(IntegerExp)){
return self.value.toString();
}

if(self.isTypeOf(BooleanExp)){
return self.value.toString().firstToUpperCase();
}

else if(self.isTypeOf(RefExp)){
//self.ref.name.println();
return self.ref.name;
}
else if(self.isTypeOf(CallExp)){
//self.callExpString().println();
return self.callExpString();
}
else if(self.isTypeOf(ResultExp)){
return "result";
}
else if(self.isTypeOf(Selection)){
return self.member.name+"("+self.receiver.value.ref.name+"!"+self.receiver.parameters.at(0).ref.name+")";
}

else if(self.isTypeOf(EnumExp)){
return self.literal.name;
}
else if(self.isTypeOf(SeqExp)){
return self.sequenceString();
}

else if(self.isTypeOf(ArrayExp)){
return self.value.ref.name + "."+self.parameters.at(0).value;
//e.g., vel[1] -> vel.1
}

else if(self.isTypeOf(TupleExp)){
return "("+ self.values.at(0).oneSideOfBianryString()+", "+self.values.at(1).oneSideOfBianryString() +")";
//e.g., (3,4)
}

else if(self.isTypeOf(ClockExp)){
return "clock";
}
}
 
 %]
  
 
  
  
  
[*to generate the CallExp expression string for the statement of CallExp type, i.e. functions*]
[% 
operation RC!CallExp callExpString(): String{
var args_string: String;
var callExp_string: String;
//to get the parameter on the right

if(self.args.at(0).isTypeOf(RefExp)){
args_string= self.args.at(0).ref.name;
}
else 
//this branch is for callexp used in functions where we have the keyword result
if(self.args.at(0).isTypeOf(ResultExp)){
args_string= "result";
}
else
if(self.args.at(0).isTypeOf(Selection)){
args_string=self.args.at(0).member.name+"("+self.args.at(0).receiver.value.ref.name+"!"+self.args.at(0).receiver.parameters.at(0).ref.name+")";
}

//for the case that there are more than 2 args, we need insert ',' between args
var j=1;
while(j<self.args.size()){
//"self.args.at(j).type:".println();
//self.args.at(j).type.println();


if(self.args.at(j).isTypeOf(RefExp)){
args_string=args_string+ ", "+ self.args.at(j).ref.name;
}
else 
//this branch is for callexp used in functions where we have the keyword result
if(self.args.at(j).isTypeOf(ResultExp)){
args_string=args_string+ ", "+ "result";
}
else
if(self.args.at(j).isTypeOf(Selection)){
self.args.at(j).receiver.println();
//ArrayExp []
//self.args.at(j).receiver.value.type.println();
//self.args.at(j).receiver.value.ref.name.println();
//gs
//self.args.at(j).receiver.parameters.at(0).ref.name.println();
//x
//self.args.at(j).member.name.println();
//i
args_string= args_string+ ", "+self.args.at(j).member.name+"("+self.args.at(j).receiver.value.ref.name+"!"+self.args.at(j).receiver.parameters.at(0).ref.name+")";
//i(gs!x)
}

//????shall j++ inside or outside?
j++;
}

callExp_string=self.`function`.ref.name+"("+args_string+")";
return callExp_string;
}
  %]
  
  
  
  
  

[*to generate the Call expression string for the statement of Call type, i.e. operations*]
[% 
operation RC!Call callString(): String{
var args_string: String;
var call_string: String;
//to get the parameter on the right
if(self.args.size()=0){
args_string="";
}
else if(self.args.size()>0){
if(self.args.at(0).isTypeOf(RefExp)){
args_string= self.args.at(0).ref.name;
}
else if(self.args.at(0).isTypeOf(IntegerExp)){
args_string= self.args.at(0).value.toString();
}
else if(self.args.at(0).isTypeOf(EnumExp)){
args_string= self.args.at(0).literal.name;
}
else 
//this branch is for callexp used in functions where we have the keyword result
if(self.args.at(0).isTypeOf(ResultExp)){
args_string= "result";
}
else
if(self.args.at(0).isTypeOf(Selection)){
args_string=self.args.at(0).member.name+"("+self.args.at(0).receiver.value.ref.name+"!"+self.args.at(0).receiver.parameters.at(0).ref.name+")";
}

//for the case that there are more than 2 args, we need insert ',' between args
var j=1;
while(j<self.args.size()){
//"self.args.at(j).type:".println();
//self.args.at(j).type.println();


if(self.args.at(j).isTypeOf(RefExp)){
args_string=args_string+ ", "+ self.args.at(j).ref.name;
}
else if(self.args.at(j).isTypeOf(IntegerExp)){
args_string= args_string+ ", "+ self.args.at(j).value.toString();
}
else if(self.args.at(j).isTypeOf(EnumExp)){
args_string= args_string+ ", "+ self.args.at(j).literal.name;
}
else 
//this branch is for callexp used in functions where we have the keyword result
if(self.args.at(j).isTypeOf(ResultExp)){
args_string=args_string+ ", "+ "result";
}
else
if(self.args.at(j).isTypeOf(Selection)){
self.args.at(j).receiver.println();
//ArrayExp []
//self.args.at(j).receiver.value.type.println();
//self.args.at(j).receiver.value.ref.name.println();
//gs
//self.args.at(j).receiver.parameters.at(0).ref.name.println();
//x
//self.args.at(j).member.name.println();
//i
args_string= args_string+ ", "+self.args.at(j).member.name+"("+self.args.at(j).receiver.value.ref.name+"!"+self.args.at(j).receiver.parameters.at(0).ref.name+")";
//i(gs!x)
}

//????shall j++ inside or outside?
j++;
}
}
call_string=self.`operation`.name+"("+args_string+")";
return call_string;
}
  %]
  


  
[%
operation RC!SeqExp sequenceString(): String{

if(self.values.size()=0){
return  "[]";
} 
else if(self.values.size()>0) {
var m=1;
var sequence_string="["+self.values.at(0);
while (m<self.values.size()){
sequence_string=sequence_string+", "+self.values.at(m);
m++;
}
sequence_string=sequence_string+"]";
return sequence_string;
}
}
%]


[%
operation RC!ProductType productString(): String{
var strings: String;
strings= "("+self.types.at(0).zmType() + "\\<times>" + self.types.at(1).zmType()+")" ;
 return strings;
}
%]


