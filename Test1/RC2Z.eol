/****************************
Due to Rule 60 Semantics of composite states,
we have to transform most of the RoboChart components into actions instead of processes
The old EOL version (RC2Z_V0_state_as_proc.eol) is the implementation that convert 
RoboChart elements into processes. This version is kept for record and no longer used.

The principle for transformation as processes or actions

- ProcessPara
R1
R12
R17
R19 (Basic Process)
- Process
R14
R15
R18

- R19 ControllerDef is a basic process, including several parts:
	Defined operations as action: [[opdef]]stm
	Required operations as action: CALL__opname -> Skip
	Within part
	main action is set as within part

- ActionPara
R13 ?
R20
R25 stm
R29 stateful
R31 VarMemory
R33 sharedVarMemory
R35 Memory
R37 sharedMemory(not yet implemented)
R39/40 Node container
R41 ncCoreBehaviour (including C.2.2)
R52 composeNodes
R53 transitions

R57-R60 a set of ActionParas

The actions in the ActionParas are revoked using actionPara.name.word.CallAction()
In this way, the actions in the ActionPara are presented standalone, and only their names are used in the higher level action/procss to enhance model readability.



- Action
R21
R22
R54 transition 
R55
R62-73

only actions not actionparas are generated for these rule, so their complete model will be part of the higher level action/process model.

01.Sep.2024
******************************/


/****************************
All memories are PARAMITERIZED 

R12 modMemory
R18 SingleBuffer
R20 ctrlMemory
R35 individual variable memory
R37 individual shared variable memory



CSP Exception in Rule 1 and Rule 19
option 1: to create Exception action/process in Circus metamodel.
		  This is not adopted as we wish to keep the work be consistent with Circus AST

option 2: to remove Exception by pushing end event into the process

06.Sep.2024
******************************/


/****************************
when using rct as source model, if the source is set as both read on load and store on disposal, the model is deleted every time the program run
this issue is avoided when use exported EMF models
One thing to notice:
when change in rct directly, after create local vars for the shared vars, as long as the required interface in stm is deleted, all the vars in statement point to the local declared vars automatically.
But when do EOL transformation, it is not the case.
Even if we delete all stm.rinterfaces, the vars in statements still point to the interfaces.
So we need to replace all the vars expr by expr with the one in the allLocalVariables.

This is a tedious process, but can not be avoided.
We will need the usedVariablesModel again and modify it to implement the FQN replacement.

30.06.2024
******************************/



//var pkg =  RC!RCPackage.all().selectOne(p|p.name = "Chemical");
var pkg =  RC!RCPackage.all().selectOne(p|p.name = "pkg0" or p.name = "Chemical");
pkg.println();

//for(stm in RC!StateMachineDef.all().selectOne(s|s.name = "stm0" or s.name = "GasAnalysis_stm")){
//	stm.nodes.println();
////	for(nd in stm.nodes){
////		if(nd.instanceOf(RC!Junction)){
////			nd.createJunctionAsActionParas();
////		}
////		if(nd.instanceOf(RC!Final)){
////			nd.createFinalAsActionParas();
////		}
////		if(nd.instanceOf(RC!State) and not nd.instanceOf(RC!Final)){
////			nd.createSimpleStateAsActionParas();
////		}
////	}
//	
////	composeNodes(stm.nodes);
////	ncCoreBehaviour(stm);
////	ncBehaviour(stm);
////	stateful(stm);
////	varMemory(stm);
////sharedVarMemory(stm);
//
//
//
//	for(p in Z!ActionPara.all){
//		actionParaSeq.add(createCallOpActionPara(op));
//	}
//	createStateMachineDefAsActionPara(stm);
//	
//	var actionParaSeq = new Sequence<Z!ActionPara>;
//	for(p in Z!Para.all().select(p| p.instanceOf(Z!ActionPara))){
//		actionParaSeq.add(p);
//	}
//
//	var mainActionname = "stm_mainaction_" + stm.FQN();
//	
//	var basicProcess = actionParaSeq.createBasicProcess(mainActionname).createProcessPara("stm_" + stm.FQN(), false);
//}


for(c in RC!ControllerDef.all().selectOne(c|c.name = "C1")){
//	for(op in c.lOperations){
//		("line 87, op = " + op).println();
//		if(op.nodes.size()>0){
//			createOperationDefAsActionPara(op);
//		}
//	}

	createControllerAsProcessPara(c);
}
replaceRef();

//To transform RoboChart user defined types
createTypeDeclPara(pkg);


createFunctionDefsAsAxParas(pkg);


/** TEMPORARILY COMMENTTED OUT 
//To copy the shared vardecls as local vardecls, then replace all the shared with local, then FQN in localdecls



for(stm in RC!StateMachineDef.all()){
	declareSharedVarAndConstAsLocalVar(stm);
	Shared2FQLocalVariablesAndConst(stm);
	
	
	for(evt in stm.events){
	evt.name.println();
	evt.name = evt.name + "_" + stm.FQN();
	evt.name.println();
	}
	
	declareConstants(stm);
	
	ncBehaviour(stm);
	
	createCallOps(stm);//this is no more needed because I will use call definition directly in the process instead of using CALL__op
}


//var nc = RC!StateMachineDef.all().at(0);



//ncBehaviour(nc);
 END OF TEMPORARILY COMMENTTED OUT ***/
var zsect = createZSect("circus_theory", Sequence{}, Sequence{"Boolean_operators"});
	
for(p in Z!Para.all().select(p|p.instanceOf(Z!ChannelSetPara) or p.instanceOf(Z!ChannelPara) or p.instanceOf(Z!FreePara)  or p.instanceOf(Z!GivenPara)  or p.instanceOf(Z!AxPara) or p.instanceOf(Z!ProcessPara) //or p.instanceOf(Z!ActionPara)
)){
	zsect.addPara2ZSect(p);	
}


createSpec(zsect);

 
/*

//RC!StateMachineDef.all().println();
//This is only used for M2T validation of ApplExpr
for(n in nc.nodes.select(s|s.name = "s3")){
	("n.name = "+ n.name).println();
	var expr = n.actions.at(0).action.right.createExpr();
	createApplExprList(Sequence{expr});
	
}

//This is only used for M2T validation of createPredList
for (t in nc.transitions.select(t|t.name = "t1")){
	if(t.condition != null){
		var pred = t.condition.createExpr().createMemPredEquality();
//		circusAction = createGuardedAction(pred, circusAction);
		createPredList(Sequence{pred});
	} 
}

*/

//
//
//
/**************************************************************
 EOL Operations that supports the transformation procedures above 

***************************************************************/
//
/*RoboChart example:

type Chem
type Intensity
datatype GasSensor {
	c : Chem
	i : Intensity
}
enumeration Angle { Left Right Back Front }
*/
operation createTypeDeclPara(pkg:RC!RCPackage){
	for(tp in pkg.types){
	
		if(tp.instanceOf(RC!PrimitiveType)){
			var givenPara = new Z!GivenPara;
			givenPara.nameList = createNameList(Sequence{tp.name});
			
		}
		
		if(tp.instanceOf(RC!RecordType)){
			var recordpara = new Z!AxPara;
			recordpara.box = Z!Box#SchBox;
			recordpara.zSchText = new Z!ZSchText;
			
			var declList = new Z!ZDeclList;
			declList.decls.add(tp.createConstDecl());
			
			recordpara.zSchText.declList = declList;
		
		}
		
		if(tp.instanceOf(RC!Enumeration)){
			var literal_seq = new Sequence<String>;
			for(l in tp.literals){
				literal_seq.add(l.name);
			}
			var freetype = createEnumType(tp.name, literal_seq);
			
			var freetypePara =  freetype.createEnumTypePara();		
		}
	
	}
}


operation RC!RecordType createConstDecl(): Z!ConstDecl{
	var constDecl = new Z!ConstDecl;
	constDecl.name = self.name.createZName();
	
	constDecl.expr = self.fields.createSchExprFromFields();

	return constDecl;
}

//used in createConstDecl
//to create A schema construction expression for record type transformation 
operation Set<RC!Field> createSchExprFromFields(): Z!SchExpr{
	var schExpr = new Z!SchExpr;
	
	schExpr.schText = new Z!ZSchText;
	var declList = new Z!ZDeclList;
	
	for(f in self){
		declList.decls.add(f.createVarDecl());
	}
	schExpr.schText.declList = declList;
	
	return schExpr;

}

//used in createSchExprFromFields
operation RC!Field createVarDecl(): Z!VarDecl{
	var varDecl = new Z!VarDecl;
	
	varDecl.nameList = createNameList(Sequence{self.name});
//	varDecl.expr = self.type.ref.name.createRefExpr(false, false);
	varDecl.expr = self.type.createTypeExpr();
	return varDecl;
}




operation createFunctionDefsAsAxParas(pkg:RC!RCPackage){
	for(f in pkg.functions.select(f|f.name != "card")){
		createAxParaForFunc(f);
	}
}

operation declareSharedVarAndConstAsLocalVar(nc: RC!NodeContainer){
	var vlset = Set<RC!VariableList>;
	vlset = Set{};
	
	//To collect vars in required interfaces, and to delare as new vars
	for(ri in nc.rinterfaces){
//		var cloned = new RC!Variable;
	
		for(vl in ri.variableList){
			vlset.add(clone(vl));
		
//			for(v in vl.vars){
//				var cloned = clone(v);//without clone, the var in Interface will be removed.
//				if(v.modifier = RC!VariableModifier#CONST){
//					cloned.modifier = RC!VariableModifier#CONST;
//				}
//				varset.add(cloned);
//			}
		}
	}
	
	var varset = new Set<RC!Variable>;
	for(varlist in vlset){
		for(v in varlist.vars){
			varset.add(v);
		}
	}
	("line 224 varset = "  + vlset).println();
	
	//to add newly delared vars into the stm.variableList, such they become local vars
//	if(nc.variableList.size()>0 and nc.variableList.select(l|l.modifier = RC!VariableModifier#VAR).size()>0){
//		nc.variableList.select(l|l.modifier = RC!VariableModifier#VAR).at(0).vars = nc.variableList.at(0).vars.includingAll(varset);
//	} else {
		
		
		if(varset.select(v|v.modifier = RC!VariableModifier#VAR).size()>0){
			var vl_var = new RC!VariableList;
			vl_var.modifier = RC!VariableModifier#VAR;
			nc.variableList.add(vl_var);
			for(v in varset.select(v|v.modifier = RC!VariableModifier#VAR)){
				vl_var.vars.add(v);
			}
		}
		
		
		//one case is not covered: when local var has the same name as the shared/requried const
		if(varset.select(v|v.modifier = RC!VariableModifier#CONST).size()>0){
			var vl_const = new RC!VariableList;
			vl_const.modifier = RC!VariableModifier#CONST;
			nc.variableList.add(vl_const);
			for(v in varset.select(v|v.modifier = RC!VariableModifier#CONST)){
				vl_const.vars.add(v);
			}
		}


//	nc.rinterfaces.clear();//this is commented out, becasue we need to know the shared vars through the rinterface so that we can declare the EXT channel
	//it makes no difference removing rinterfaces or not in terms of the update of the vars used in all the statement, because all the varrefs need to be replaced one by one in the actual stmt/expr
}


//to replace each  shared var with local var in the node container
operation Shared2FQLocalVariablesAndConst(nc: RC!NodeContainer){
	for(st in nc.nodes.select(s|s.instanceOf(RC!State))){
		for(act in st.actions){
			Shared2LocalVariablesAndConstInStmt(act.action,nc);
		}
	}
	
	for(tr in nc.transitions){
		if(tr.trigger.isDefined() and tr.trigger._type=CommunicationType#INPUT){
			//tr.trigger.type = Communication
			tr.trigger.parameter = allLocalVariablesandConst(nc).selectOne(v|v.name = tr.trigger.parameter.name // and v.modifier = RC!VariableModifier#VAR 
			);
		}
		
		if(tr.condition.isDefined()){
			Shared2LocalVariablesAndConstInExpr(tr.condition,nc);
		}
		
		if(tr.action.isDefined()){
			Shared2LocalVariablesAndConstInStmt(tr.action,nc);
		}
	}
	
	
	//here to convert all the names to FQN
	FQAllLocalVariables(nc);
}

operation FQAllLocalVariables(nc: RC!NodeContainer){

	for(v in allLocalVariablesandConst(nc)){
		v.name = v.name + "_" + nc.FQN();
	}
}

operation Shared2LocalVariablesAndConstInStmt(
	stmt: RC!Statement,
	nc: RC!NodeContainer){
	
	if(stmt.instanceOf(RC!Assignment)){
				
		stmt.left.name = allLocalVariablesandConst(nc).selectOne(v|v.name = stmt.left.name.name); //and v.modifier = RC!VariableModifier#VAR 
		
		
		Shared2LocalVariablesAndConstInExpr(stmt.right,nc);
		
	} //else
	
	if(stmt.instanceOf(RC!Call)){
		for(arg in stmt.args){
			Shared2LocalVariablesAndConstInExpr(arg,nc);
		}
	} //else
	
	if(stmt.instanceOf(RC!IfStmt)){
		Shared2LocalVariablesAndConstInExpr(stmt.expression, nc);
		Shared2LocalVariablesAndConstInStmt(stmt.then, nc);
		Shared2LocalVariablesAndConstInStmt(stmt.`else`, nc);
		
	} //else
	
	if(stmt.instanceOf(RC!CommunicationStmt) and (stmt.communication._type=CommunicationType#SYNC or stmt.communication._type=CommunicationType#OUTPUT)){
		Shared2LocalVariablesAndConstInExpr(stmt.communication.value,nc);
	} //else
	
	if(stmt.instanceOf(RC!CommunicationStmt) and (stmt.communication._type=CommunicationType#INPUT )){
	stmt.communication.parameter = allLocalVariablesandConst(nc).selectOne(v|v.name = stmt.communication.parameter.name); //and v.modifier = RC!VariableModifier#VAR 
	
	
	} //else
	if(stmt.instanceOf(RC!SeqStatement)){
		for(s in stmt.statements){
			Shared2LocalVariablesAndConstInStmt(s, nc);
		}
	} //else
	if(stmt.instanceOf(RC!ParStmt)){
		varSet = Shared2LocalVariablesAndConstInStmt(stmt.stmt);
	} //else
	if(stmt.instanceOf(RC!TimedStatement)){
		Shared2LocalVariablesAndConstInStmt(stmt.stmt);
		Shared2LocalVariablesAndConstInStmt(stmt.deadline); //Stmt or Expr?
	} else
	{ 	}	
}


operation Shared2LocalVariablesAndConstInExpr(
	expr: RC!Expression,
	nc: RC!NodeContainer){
	
	if(expr = null){	
	} else
	
	if(expr.instanceOf(RefExp)){
		if(expr.ref.instanceOf(RC!Variable)){
			expr.ref = allLocalVariablesandConst(nc).selectOne(v|v.name = expr.ref.name);
		}
//TO DO: temporarily do not differetiate VAR and CONST
 
	} else {
	
	("line 299 expr.eContents = " +expr.eContents).println();
		for(obj in expr.eContents){
			if(obj.instanceOf(RC!Expression)){
				("obj = " + obj).println();
				Shared2LocalVariablesAndConstInExpr(obj,nc);
			}
		}
		
	}
	
}


//operation Shared2LocalVariablesAndConstInExpr(
//	expr: RC!Expression,
//	nc: RC!NodeContainer){
//	if(expr = null){	
//	} else
//	
//	if(expr.instanceOf(RefExp)){
////		var value = expr.ref;
////		("value.name = " + value.name).println();
////		(value.instanceOf(RC!Variable) and value.modifier= VariableModifier#VAR).println();
//		
////		if(expr.ref.instanceOf(RC!Variable) and expr.ref.modifier= VariableModifier#VAR){
//		if(expr.ref.instanceOf(RC!Variable)){
//					
//			expr.ref = allLocalVariablesandConst(nc).selectOne(v|v.name = expr.ref.name);
////			expr.ref = allLocalVariablesandConst(nc).selectOne(v|v.name = expr.ref.name and v.modifier = RC!VariableModifier#VAR);
//
////TO DO: temporarily do not differetiate VAR and CONST
//
////		if(expr.ref.instanceOf(RC!Variable) and expr.ref.modifier= VariableModifier#VAR){
////					
////			expr.ref = allLocalVariablesandConst(nc).selectOne(v|v.name = expr.ref.name and v.modifier = RC!VariableModifier#VAR );
////			("expr.ref.name = " + expr.ref.name).println();
////			("nc of value = " + nc(expr.ref)).println();
////		} else 
////		if(expr.ref.instanceOf(RC!Variable) and expr.ref.modifier= VariableModifier#CONST){
////			expr.ref = allLocalVariablesandConst(nc).selectOne(v|v.name = expr.ref.name and v.modifier = RC!VariableModifier#CONST );
////		} 
//	} else {
//	
//	("line 299 expr.eContents = " +expr.eContents).println();
//		for(obj in expr.eContents){
//			if(obj.instanceOf(RC!Expression)){
//				("obj = " + obj).println();
//				Shared2LocalVariablesAndConstInExpr(obj,nc);
//			}
//		}
//		
//	}
//	
//}



//This is only used for M2T validation of ApplExpr
operation createApplExprList(exprSeq: Sequence<Z!ApplExpr>): Z!CApplExprList{
	var aeList = new Z!CApplExprList;
	aeList.applExprs = exprSeq;
	return aeList;
}

//This is only used for M2T validation of Pred
operation createPredList(predSeq: Sequence<Z!Pred>): Z!CPredList{
	var predList = new Z!CPredList;
	predList.preds = predSeq;
	return predList;
}



operation replaceRef(){

	for(stmr in RC!StateMachineRef.all()){
	
		var stm_new = clone(stmr.ref);
		stm_new.name = stmr.name;
	 		
	 	ctl(stmr).machines.add(stm_new);
//	 	ctl(stmr).machines.remove(stmr);
//THIS is commented out BECAUSE EOL will fail, msg: Unknown reason
//	 	delete stmr;
		
	}

	for(ctlr in RC!ControllerRef.all()){

		var ctl_new = clone(ctlr.ref);
		ctl_new.name = ctlr.name;
	 		
	 	module(ctlr).nodes.add(ctl_new);
//	 	module(ctlr).nodes.remove(ctlr);//THIS is commented out BECAUSE EOL will fail, msg: Unknown reason, for both the cases that taking  EMF model and rct as source model
//	 	delete ctlr;
		
	}
	return RC;
}


//to create constant declaration for local constants of context
//a constant decl is a AxPara which has schemaText
operation declareConstants(context: RC!Context){
	("line 613, context = " + context).println();
	for(c in allLocalConstants(context)){
	
		("line 611 c = " + c).println();
		var constDecl = new Z!AxPara;
		constDecl.box = Z!Box#AxBox;
		constDecl.zSchText = new Z!ZSchText;
			
		var declList = new Z!ZDeclList;
		declList.decls.add(createVarDecl(c));
			
		constDecl.zSchText.declList = declList;
		
	}
}

//RoboChart funciton is a Circus AxPara 
operation createAxParaForFunc(f:RC!Function):Z!AxPara{
	var axPara = new Z!AxPara;
	axPara.box = Z!Box#AxBox;
	axPara.zSchText = new Z!ZSchText;
			
	var declList = new Z!ZDeclList;
	declList.decls.add(createVarDecl(f));
			
	axPara.zSchText.declList = declList;
	
	return axPara;
}




//used in createAxParaForFunc
operation createVarDecl(f: RC!Function):Z!VarDecl{
	var varDecl = new Z!VarDecl;
	
	varDecl.nameList = createNameList(Sequence{f.name});
	
	
	varDecl.expr = createGenOpApplForFuncDecl("_->_", f);

	return varDecl;
}



//create RefExpr as Generic Operator Application: explicit = true, mixFix = true
//used for Robochart SeqType transformation: name = seq_, expr = refExpr
operation createGenOpApplForFuncDecl(
	name_str: String,
	f: RC!Function
	): Z!RefExpr{
	
	var refExpr = new Z!RefExpr;
	refExpr.mixFix = true;
	refExpr.explicit = true;
	refExpr.name = name_str.createZName();
	
	//there are 2 expressions in the exprList to represent the type of parameters and the type of function
	refExpr.exprList = new Z!ZExprList;
	
	if(f.parameters.size()=0){
		refExpr.exprList.exprs.add(f.type.createTypeExpr());
	} else if(f.parameters.size()=1){
		("line 522, function is " + f.name).println();
		refExpr.exprList.exprs.add(f.parameters.at(0).type.createTypeExpr());
		refExpr.exprList.exprs.add(f.type.createTypeExpr());
	} else if(f.parameters.size()>1){//multiple parameters, means the 1st expr for the parameter types is a Cartesian product expression

		var prodExpr = Z!ProdExpr;
		var size = f.parameters.size();
		var i = 0;
		prodExpr = createProdExpr(f.parameters.at(0).type.createTypeExpr(), f.parameters.at(1).type.createTypeExpr());
		i = i + 2;
		if(size > 2){
			while(i<size){
				prodExpr = createProdExpr(prodExpr,f.parameters.at(i).type.createTypeExpr());
				i = i + 1;
			}
		}		

		refExpr.exprList.exprs.add(prodExpr);
		refExpr.exprList.exprs.add(f.type.createTypeExpr());
	}

	return refExpr;

}


//used in declareConstants and Rule 35
operation createVarDecl(c: RC!Variable):Z!VarDecl{
	var varDecl = new Z!VarDecl;
	("line 670, c = " + c).println();
	varDecl.nameList = createNameList(Sequence{c.name});
	("line 671, c.type = " + c.type).println();
	varDecl.expr = c.type.createTypeExpr();

	return varDecl;
}




//CSP Rule 1 
operation createModuleAsProcessPara(m: RC!RCModule): Z!ProcessPara{
	var ctrls = m.controllers.asSequence();
	var cons = m.connections;
	
	var roboticPlatform = m.nodes.selectOne(n|n.instanceOf(RC!RoboticPlatform));
	var asyncs = cons.select(c|c.`async` and Set{c.from, c.to}.excludes(roboticPlatform));
	
	var evasyncs = new Set<String>;
	for(c in asyncs){
		evasyncs.add(c.eto.name);
		evasyncs.add(c.efrom.name);
	}	
	evasyncs.add("terminate");
	
	//to create processpara for composeControllers(m,ctrls,cons),so that it can be called
	var composeControllersPara = composeControllers(m,ctrls,cons).createProcessPara("composeControllers_" + m.FQN(), false);
	
		
	
	//step1: paralleled buffers
	//Manual modifiey: [| terminate |] c: asyncs . buffer(c)
	//Manual original: it is interleaving buffers, terminate is added to deal with EXCEPTION operator issue
	
	var bufferSet;
	for(c in asyncs){
		bufferSet.add(buffer(c).name.word.createCallProcess());
	}
	var proc1 = createParallelProcessFromProcSet(Set{"terminate"},
											 bufferSet);
	// terminate is added to deal with EXCEPTION operator issue
	
	//step 2: parallel
	//Manual: modMemory(m) |[memoryChannels1(m)]| composeControllers(m,ctrls,cons)
	var memoryChannels = memoryChannels(m);
	memoryChannels.add("terminate");
	//this terminate is added to deal with the EXCEPTION operator issue
	var proc2 = createParallelProcess(memoryChannels(m), 
									  modMemory(m).name.word.createCallProcess(), 
									  composeControllersPara.name.word.createCallProcess()
									  );
	
	//step 3: parallel
	//Manual: proc1 [|evasyncs union {terminate}|]  proc2
	var proc = createParallelProcess(evasyncs.
									 proc1,
									 proc2);
	
	//step 4: hide
	var hiddenModuleChannels = hiddenModuleChannels(m);
	hiddenModuleChannels.add("terminate");	
	//this terminate is added to deal with the EXCEPTION operator issue
	
	proc = proc.createHideProcess(hiddenModuleChannels);
	
	//step 5: exception
//	proc = createExceptionProcess(Set{"terminate"}, proc, createSkipAction());  //TBC ??
	
	//step 6: hide terminate
//	proc = proc.createHideProcess(Sequence{"terminate"});
	
	//step 5: processpara
	proc.createProcessPara("RCModule_" + m.FQN(), false);
}


operation Set<Z!CircusProcess> createInterleaveProcess(): Z!CircusProcess{
	var proc;
	var size = self.size();

	var i = 0;
	proc = createProcess2("InterleaveProcess", self.at(0), self.at(1));
	i = i + 2;
	if(size > 2){
	while(i<size){
			proc = createProcess2("InterleaveProcess", proc, self.at(i));
			i = i + 1;
		}
	}
	return proc;
}


operation Set<Z!CircusAction> createInterleaveAction(): Z!CircusAction{
	var action;
	var size = self.size();

	var i = 0;
	action = createAction2("InterleaveAction", self.at(0), self.at(1));
	i = i + 2;
	if(size > 2){
	while(i<size){
			action = createAction2("InterleaveAction", action, self.at(i));
			i = i + 1;
		}
	}
	return action;
}

//TO DO
operation createExceptionAction(cs: Set<String>,
								act1: Z!CircusAction,
								act2: Z!CircusAction):
								Z!CircusAction{
								
}


//CSP Rule 2, the return type is different from the manual (Z!ChannelSet)
operation hiddenModuleChannels(m: RC!RCModule): Sequence<String>{
	var channelSeq = new Sequence<String>;
	
	var roboticPlatform = m.nodes.selectOne(n|n.instanceOf(RC!RoboticPlatform));
	var asyncs = m.connections.select(c|c.`async` and Set{c.from, c.to}.excludes(roboticPlatform));
	
	for(c in asyncs){
		channelSeq.add(c.eto.name);
		channelSeq.add(c.efrom.name);
	}
	
	channelSeq = channelSeq.includingAll(memoryChannels(m));

	return channelSeq;
}



//CSP Rule 3, the return type is different from the manual (Z!ChannelSet)
operation memoryChannels(m: RC!RCModule): Set<String>{
	var channelSet = new Set<String>;
	
	var rp = m.nodes.selectOne(n|n.instanceOf(RC!RoboticPlatformDef));
	
	for(v in allVariables(rp)){
		channelSet.add("set_" + v.name);
	}
	for(v in allConstants(rp)){
		channelSet.add("set_" + v.name);
	}
	for(c in m.controllers){
		for(v in requiredVariables(c)){
			channelSet.add("set_EXT_" + v.name + "_" + c.FQN()); 
			//Noted: vid(v,c)
			//TBC: here v.name should be the simple one, not the FQN
		}
	}
	
	channelSet = channelSet.includingAll(memoryChannels(m));

	return channelSet;
}


//CSP Rule 5
operation allVariables(context: RC!Context): Set<RC!Variable>{
	var varset: Set<RC!Variable>; 
	for(vl in context.variableList.select(l|l.modifier = RC!VariableModifier#VAR)){
		for(v in vl.vars){
			varset.add(v);
		}
	}
	
	for(i in context.pInterfaces){
		for(vl in i.variableList.select(l|l.modifier = RC!VariableModifier#VAR)){
			for(v in vl.vars){
				varset.add(v);
			}
		}
	}
	
	for(i in context.rInterfaces){
		for(vl in i.variableList.select(l|l.modifier = RC!VariableModifier#VAR)){
			for(v in vl.vars){
				varset.add(v);
			}
		}
	}
	return varset;
}

//CSP Rule 6
operation requiredVariables(context: RC!Context): Set<RC!Variable>{
	var varset: Set<RC!Variable>; 
	
	for(i in context.rInterfaces){
		for(vl in i.variableList.select(l|l.modifier = RC!VariableModifier#VAR)){
			for(v in vl.vars){
				varset.add(v);
			}
		}
	}
	return varset;
}


//CSP Rule 7
operation allLocalVariables(context: RC!Context): Set<RC!Variable>{
	var varset: Set<RC!Variable>; 
	for(vl in context.variableList.select(l|l.modifier = RC!VariableModifier#VAR)){
		for(v in vl.vars){
			varset.add(v);
		}
	}
	
	for(i in context.pInterfaces){
		for(vl in i.variableList.select(l|l.modifier = RC!VariableModifier#VAR)){
			for(v in vl.vars){
				varset.add(v);
			}
		}
	}
	return varset;
}

//CSP Rule 8
operation allConstants(context: RC!Context): Set<RC!Variable>{
	var varset: Set<RC!Variable>; 
	for(vl in context.variableList.select(l|l.modifier = RC!VariableModifier#CONST)){
		for(v in vl.vars){
			varset.add(v);
		}
	}
	
	for(i in context.pInterfaces){
		for(vl in i.variableList.select(l|l.modifier = RC!VariableModifier#CONST)){
			for(v in vl.vars){
				varset.add(v);
			}
		}
	}
	
	for(i in context.rInterfaces){
		for(vl in i.variableList.select(l|l.modifier = RC!VariableModifier#CONST)){
			for(v in vl.vars){
				varset.add(v);
			}
		}
	}
	return varset;
}

//CSP Rule 9
operation requiredConstants(context: RC!Context): Set<RC!Variable>{
	var varset: Set<RC!Variable>; 
	
	for(i in context.rInterfaces){
		for(vl in i.variableList.select(l|l.modifier = RC!VariableModifier#CONST)){
			for(v in vl.vars){
				varset.add(v);
			}
		}
	}
	return varset;
}

//CSP Rule 10
operation allLocalConstants(context: RC!Context): Set<RC!Variable>{
	var varset: Set<RC!Variable>; 
	for(vl in context.variableList.select(l|l.modifier = RC!VariableModifier#CONST)){
		for(v in vl.vars){
			varset.add(v);
		}
	}
	
	for(i in context.pInterfaces){
		for(vl in i.variableList.select(l|l.modifier = RC!VariableModifier#CONST)){
			for(v in vl.vars){
				varset.add(v);
			}
		}
	}

	return varset;
}

//CSP Rule 11
operation requiredOperations(c: RC!Context): Set<RC!Operation>{
	var opset: Set<RC!Operation>; 
	
	for(i in c.rInterfaces){
		opset = opset.includingAll(i.operations);
	}
	return opset;
}




//Rule 12, Memory in the manual is factored out as a function "mod_memory"
operation modMemory(m: RC!RCModule): Z!ProcessPara{
	var rp = m.nodes.select(n|n.instanceOf(RC!RoboticPlatform));
	var ctrls = m.nodes.select(n|n.instanceOf(RC!Controller));
	var lvars = allLocalVariables(rp).asSequence();

	var varsAndconts = lvars.includingAll(allConstants(rp));
	
	return mod_memory(varsAndconts,lvars,rp,ctrls,m);
	//mod_memory returns a processPara, not a process. TBC
//	return mod_memory(varsAndconts,lvars,rp,ctrls,m).createProcessPara("modMemory_" + m.FQN());
	//constInit(c) not covered as not shown in CSPM, constant c is processed as a parameter in CSPM.
	
}


//mod_memory is a function that returns a Process
//this is a Baisc Process take a ParamAction as the mainAction because it involves prefix action
operation mod_memory(
					  varsAndconts:  Sequence<RC!Variable>,
					  lvars: Sequence<RC!Variable>,
					  rp:    RC!RoboticPlatform,
					  ctrls: Set<RC!Controller>,
					  m:     RC!RCModule
					  ) 
					  :Z!ProcessPara{	
	
	
		
	/******************************************************
	Step 1: implementation of definition of Memory(vars) in the manual
	*******************************************************/
	
	//1.1 (; c : rcontrollers(v) . set_EXT_vid(v,c)! x -> Skip))
	if(lvars.size>0){
		var actionSeq_lvars = new Sequence<Z!CircusAction>;
		
		for(v in lvars){
			var rcontrollers_v = ctrls.select(c|requiredVariables(c).includes(v));
			
			var prefixAction;//(; c : rcontrollers(v) . set_EXT_vid(v,c)! x -> Skip))
			if(rcontrollers_v.size()>0){
						
				if(rcontrollers_v.size() = 1){
					var prefix = createOutputCommunicationFromString("set_Ext_" + v.name + "_" + rcontrollers_v.at(0).FQN(), "x__", "OUTPUT");//To DO v.name is followed by rcontrollers_v.at(0).FQN(). If v.name is FQN, should be renamed as the simple name first.
					prefixAction = createPrefixingAction(prefix, createSkipAction());
				} else{
					var prefix = createOutputCommunicationFromString("set_Ext_" + v.name + "_" + rcontrollers_v.at(0).FQN(), "x__", "OUTPUT");//To DO v.name
					prefixAction = createPrefixingAction(prefix, createSkipAction());
					var i=1;
					while(i< rcontrollers_v.size()){
						var prefix = createOutputCommunicationFromString("set_Ext_" + v.name + "_" + rcontrollers_v.at(i).FQN(), "x__", "OUTPUT");//To DO v.name
						prefixAction = createPrefixingAction(prefix, prefixAction);
						i++;
					} 
				}
			
			}
			
			//1.2 (set_v -> prefixaction );Mmory(vars)
			//prefixaction = (set_Ext_v1 ->set_Ext_v2 -> ..-> Skip)  from 1.1
			var commu = createInputCommunication("set_" + v.name, "x__"); 
			//set_vid(v)?x 
			//TBC here we use v.name instead of FQN because we assume all variables have the fully qualified names
			
			var action;
			
			//to replace the name of v with "x__"
			//RoboChart manual: Memory(vars[name(v):=x])
			var new_varsAndconts_names = new Sequence<String>;
			var varsAndconts_names = varsAndconts.getNames();
			

			var new_varsAndconts_names = new Sequence<String>;
			var size = varsAndconts.size();
			var i=0;
			var elem = new String;
			while(i<size){
				
				if(varsAndconts_names.at(i) = v.name){
					new_varsAndconts_names.add("x__");
				}
				else{
					elem = varsAndconts_names.at(i);
					new_varsAndconts_names.add(elem);				
				}
				i++;
			}
			
			("line 1069, new_varsAndconts_names = " + new_varsAndconts_names).println();
			("line 1070, varsAndconts_names = " + varsAndconts_names).println();
			
			
			
			if(rcontrollers_v.size() >0){
				action = createAction2("SeqAction", 
										createPrefixingAction(commu, prefixAction), 
										("modMemory_"+ m.FQN()).createCallAction(new_varsAndconts_names.createRefExprSeq(false,false)));
			} else{
				action = createPrefixingAction(commu, 
											   ("modMemory_"+ m.FQN()).createCallAction(new_varsAndconts_names.createRefExprSeq(false,false))
											  );
			}
			actionSeq_lvars.add(action);
		}
		
		
		//1.3 extchoices among all the actions in actionSeq_lvars
		var modMemory;
		if(lvars.size()>1){
			modMemory = actionSeq_lvars.createSequenceAsExtchoiceAction();
		} else {//lvars.size()=1
			modMemory = actionSeq_lvars.at(0);
		}
	}
	
	
	
	/******************************************************
	Step 2: external choices with end -> Skip
	 end -> Skip is not part of the manual, it is added to deal with
	the issue of exception operator
	*******************************************************/
	modMemory = createAction2("ExtChoiceAction", 
								modMemory, 
								createPrefixingAction(createSynchCommunication("terminate"), createSkipAction())
							   );
	
	
	
	/******************************************************
	Step 3: create ParamAction on top of ctrlMemory
	*******************************************************/
//	return ctrlMemory;
	var paramaction = new Z!ParamAction;
	paramaction.isParamCommand = true;
	paramaction.circusAction = modMemory;
	paramaction.declList = new Z!ZDeclList;
	
	
	/* action.declList  is the list of parameters, including variables and constants
	   e.g., Memory(id__, cv1, x, m, a1, a3, c2, c3) 
	   c2 and c3 are constants  	*/
	
	//add all the variables and constants as parameters
	for(v in varsAndconts){
//		var value = new RC!Variable;
//		value.name = v.name;
//		value.type = clone(v.type);
//		action.declList.decls.add(createVarDecl(value));
		action.declList.decls.add(createVarDecl(v));
	}
	//e.g., Memory(id__, 0, 0, 0, (0,0), 0, const_pkg0_M_C1_c2, const_pkg0_M_C1_c3)
	
	var paramaction_actpara = paramaction.createActionPara("modMemory_action_" + m.FQN());
	

	/*************************************************************
	Step 4: create Basic process taking modMemory as main action
	**************************************************************/
	
	var mainActionName = paramaction_actpara.name.word;
	var basicProcess = Sequence{paramaction_actpara}.createBasicProcess(mainActionName);
	/* there is only one action in this Basic process */

	return basicProcess.createProcessPara("modMemory_" + m.FQN(), true);		
	
	
}


//Rule 13
// not to be implemented as a standalone operation, and has been embedded in Rule 19





operation allLocalVariablesandConst(context: Any): Set<RC!Variable>{
	var varset: Set<RC!Variable>; 
	for(vl in context.variableList){
		for(v in vl.vars){
			varset.add(v);
		}
	}
	return varset;
}


//Rule 14
operation composeControllers(
						 	 m: RC!RCModule,
						 	 ctrls: Sequence<RC!Controller>, 
						  	 cons: Set<RC!Connection>): 
							 Z!CircusProcess{
						  
	if(ctrls.size()=1){
		return renamingController(m,ctrls.at(0),cons);
	} else {
	
		var tail_ctrls = ctrls.clone();
		tail_ctrls.removeAt(0);
		
		var renCtrlEvts_tail = new Set<String>;
		for(c in tail_ctrls){
			renCtrlEvts_tail = renCtrlEvts_tail.includingAll(renCtrlEvts(m,c,cons));
		}
		var connevts = intersect(renCtrlEvts(m,ctrls.at(0),cons), renCtrlEvts_tail);
		connevts.add("teminate");
		//this terminate is added to deal with the EXCEPTION operator issue
		
		var proc = createParallelProcess(connevts, renamingController(m,ctrls.at(0),cons), composeControllers(m,tail_ctrls,cons));
		
		return proc;
		/************************************
		the ProcessPara should be created in Rule 1 when the function composeControllers is called.
		we do not create ProcessPara because the function composeControllers might be called multiple times to create members of the ultimate composeControllers.*************/
	}
	
						  
}




//Rule 15
operation renamingController(m: RC!RCModule,
							 c: RC!Controller,
						 	 cons: Set<RC!Connection>): 
						 	 Z!CircusProcess{
						  
	var internalConns = new Set<RC!Connection>;
	for(con in RC!Connection.all()){
		if(con.from.instanceOf(RC!Controller) and con.to.instanceOf(RC!Controller) and (not con.`async`) and  Set{con.from, con.to}.includes(c)){
			internalConns.add(con);
		}
	}
	
	var toPlatform = new Set<RC!Connection>;
	for(con in RC!Connection.all()){
		if(con.from = c and RC!Platform.all().includes(con.to)){  //TBC: RC!Platform.all() is the right scope??
			toPlatform.add(con);
		}
	}
	
	var fromPlatform = new Set<RC!Connection>;
	for(con in RC!Connection.all()){
		if(con.to = c and RC!Platform.all().includes(con.from)){ //TBC: RC!Platform.all() is the right scope??
			fromPlatform.add(con);
		}
	}
	
	var renamepairL = new Sequence<String>;
	var renamepairR = new Sequence<String>;
	
	for(con in internalConns){
		 renamepairL.add(con.eto.name +"\\<cdot>in" );
		 renamepairR.add(con.efrom.name +"\\<cdot>out");
	}	
	
	for(con in internalConns){
		 renamepairL.add(con.eto.name +"\\<cdot>out" );
		 renamepairR.add(con.efrom.name +"\\<cdot>in");
	}	
	
	for(con in fromPlatform){
		 renamepairL.add(con.eto.name);
		 renamepairR.add(con.efrom.name);
	}				  
						  
	for(con in toPlatform){
		 renamepairL.add(con.efrom.name);
		 renamepairR.add(con.eto.name);
	}					  
	
	for(v in requiredConstants(c)){
		 renamepairL.add("set_" + v.name);
		 renamepairR.add("set_" + v.name + "_" + m.FQN()); //TBC,vid(v,c):  v.name should be the simple name so that can be followed by m.FQN()s
	}	
	
	var proc = createControllerAsProcessPara(c).name.word.createCallProcess().createRenameAction(renamepairL, renamepairR);
	
	return proc;
}

//Rule 16, the return type is different from the manual (Z!ChannelSet)
operation renCtrlEvts(m: RC!RCModule,
					  c: RC!Controller,
					  cons: Set<RC!Connection>): 
					 Set<String>{
					 
	var internalConns = new Set<RC!Connection>;
	for(con in RC!Connection.all()){
		if(con.from.instanceOf(RC!Controller) and con.to.instanceOf(RC!Controller) and (not con.`async`) and  Set{con.from, con.to}.includes(c)){
			internalConns.add(con);
		}
	}
	
	var cs = new Set<String>;
	for(con in internalConns){
		cs.add(con.efrom.name);
	}				 
	
	cs.add("terminate");
	
	for(v in requiredConstants(c)){
		 cs.add("set_" + v.name + "_" + m.FQN());//TBC,vid(v,c):  v.name should be the simple name so that can be followed by m.FQN()s
	}
	
	return cs;
}



//TBC c.mult = c.bidirect 
//Rule 17 modified: parallel synchronize on terminate

operation buffer(c: RC!Connection): Z!ProcessPara{
	var proc;
	if(c.bidirect){
		proc = createParallelProcess(Set{"terminate"},
							    	 singleBuffer(c.efrom,c.eto, c).name.word.createCallProcess(),
				   					 singleBuffer(c.eto,c.efrom, c).name.word.createCallProcess());
				
	} else{
		proc = singleBuffer(c.efrom,c.eto, c).name.word.createCallProcess();
	}

	return proc.createProcessPara("buffer_connct_" + c.FQN(), false);//TBD: c.FQN or controllerDefOfC(c).FQN?
}

//Rule 17 original: interleave
//this version not used because need to synchronize on terminate for dealing with exception operation
/*
operation buffer(c: RC!Connection): Z!ProcessPara{
	var proc;
	if(c.bidirect){
		proc = Set{singleBuffer(c.efrom,c.eto).name.word.createCallProcess(),
				   singleBuffer(c.eto,c.efrom).name.word.createCallProcess()}
				.createInterleaveProcess();
	} else{
		proc = singleBuffer(c.efrom,c.eto).name.word.createCallProcess();
	}

	return proc.createProcessPara("buffer_connct_" + c.FQN(), false);
}
*/



//e.g.,
/*Buffer0(<v>) = 
			ctrl_ref1::turn.out?x -> Buffer0(<x>)
			[]
			ctrl_ref0::turn.in!v -> Buffer0(<>)
  Buffer0(<>) = ctrl_ref1::turn.out?x -> Buffer0(<x>)

  within Buffer0(<>)
*/
//Rule 18
//TBC: the naming convention of all the prefixes
operation singleBuffer(efrom: RC!Event,
					   eto: RC!Event,
					   c: RC!Connection): Z!ProcessPara{
	if(efrom.type != null){
		return Buffer_empty(efrom, eto, c).createProcessPara("single_buffer_" + efrom.name + "_to_" + eto.name, false);
	} else{
		return Buffer_false(c).createProcessPara("single_buffer_" + efrom.name + "_to_" + eto.name, false);
	}			   
}

operation Buffer_empty(efrom: RC!Event,
					   eto: RC!Event,
					   c: RC!Connection): Z!CircueProcess{
		
	var prefix1 = createInputCommunication(efrom.name + "_" + controllerDefOfCon(c).FQN() + "_out", "x__");  
	//e.g., ctrl_ref1::turn_out ? x
	
	var choice1 = createPrefixingAction(prefix1, 
										buffer_x_actpara.name.word.createCallAction(Sequence{"x__".createRefExpr(false, false)})
										);	//Might 'x' conflict with other'x' used as the name of the RoboChart variable, shall we use 'x__'here? Yes
	
	var choice2 = createPrefixingAction(createSynchCommunication("terminate"), 
										createSkipAction()
									   );
	//choice2: terminate -> SKIP, this is added for dealing with exception operator					   
	
	var buffer_empty = createAction2("ExtChoiceAction", 
									  choice1,
									  choice2); 
	
	//create main action para
	var buffer_empty_actpara = buffer_empty.createActionPara("singleBuf_empty_" + efrom.name + "_to_" + eto.name);
	
	
	var actionParaSeq = new Sequence<Z!ActionPara>;
	
	actionParaSeq.add(buffer_empty_actpara);
		
	
	var prefix3 = createInputCommunication(efrom.name + "_" + controllerDefOfCon(c).FQN() + "_out", "x__"); 
	var choice3 = createPrefixingAction(prefix3, 
										buffer_x_actpara.name.word.createCallAction(Sequence{"x__".createRefExpr(false, false)})
									   );
	var prefix4 = createOutputCommunicationFromString(eto.name + "_" + controllerDefOfCon(c).FQN() + "_in", "v");
	var choice4 = createPrefixingAction(prefix4, 
										buffer_empty_actpara.name.word.createCallAction()
									   );
	var choice5 = createPrefixingAction(createSynchCommunication("terminate"), 
										createSkipAction()
									   );
	//choice5: terminate -> SKIP, this is added for dealing with exception operator
	
	var buffer_x = createAction2("ExtChoiceAction", 
								  createAction2("ExtChoiceAction", choice3, choice4),
								  choice5); 

	var buffer_x_param = new Z!ParamAction;
	buffer_x_param.isParamCommand = true;
	buffer_x_param.circusAction = buffer_x;
	buffer_x_param.declList = new Z!ZDeclList;
	buffer_x_param.declList.decls.add("v".createRefExpr(false, false));
	//Is parameter v or <v>? v
	

	var buffer_x_actpara = buffer_x_param.createActionPara("singleBuf_x_" + efrom.name + "_to_" + eto.name);
	actionParaSeq.add(buffer_x_actpara);
	
	var mainActionName = buffer_empty_actpara.name.word;
	var basicProcess = actionParaSeq.createBasicProcess(mainActionName);
	

	return basicProcess.createProcessPara("singleBuffer_proc_" + efrom.name + "_to_" + eto.name, true);			   
					   
}



//TO DO
//return the controllerDef that contains this connection
operation controllerDefOfCon(c:RC!Connection): RC!ControllerDef{

}


//TBC: the naming convention of all the prefixes
operation Buffer_false(c: RC!Connection): Z!CircueProcess{
		
	var prefix1 = createSynchCommunication(efrom.name + "_" + controllerDefOfCon(c).FQN() + "_out");  

	var choice1 = createPrefixingAction(prefix1, 
										buffer_true_actpara.name.word.createCallAction()
										);	
	
	var choice2 = createPrefixingAction(createSynchCommunication("terminate"), 
										createSkipAction()
									   );
	//choice2: terminate -> SKIP, this is added for dealing with exception operator					   
	
	var buffer_false = createAction2("ExtChoiceAction", 
										    choice1,
										    choice2); 
										    
	//create main action para
	var buffer_false_actpara = buffer_fasle.createActionPara("singleBuf_false_" + efrom.name + "_to_" + eto.name);
	
	
	var actionParaSeq = new Sequence<Z!ActionPara>;
	
	actionParaSeq.add(buffer_false_actpara);
		
	
	var prefix3 = createSynchCommunication(efrom.name + "_" + controllerDefOfCon(c).FQN() + "_out"); 
	var choice3 = createPrefixingAction(prefix3, 
										buffer_true_actpara.name.word.createCallAction()
									   );
	var prefix4 = createSynchCommunication(eto.name + "_" + controllerDefOfCon(c).FQN() + "_in");
	var choice4 = createPrefixingAction(prefix4, 
										buffer_fasle_actpara.name.word.createCallAction()
									   );
	var choice5 = createPrefixingAction(createSynchCommunication("terminate"), 
										createSkipAction()
									   );
										
	var buffer_true = createAction2("ExtChoiceAction", 
										createAction2("ExtChoiceAction", choice3, choice4),
										choice5); //choice5: terminate -> SKIP, this is added for dealing with exception operator
	
	var buffer_true_actpara = buffer_true.createActionPara("singleBuf_true_" + efrom.name + "_to_" + eto.name);
	actionParaSeq.add(buffer_true_actpara);
	
	var mainActionname = "singleBuf_false_" + efrom.name + "_to_" + eto.name;
	var basicProcess = actionParaSeq.createBasicProcess(mainActionname);
	
	
	//is this a basic process? although actionParaSeq contains two actionparas
	return basicProcess.createProcessPara("singleBuffer_proc_" + efrom.name + "_to_" + eto.name, true);			   
					   
}

/*******************************************
//TO DO: HOW TO DECLARE EVENTS OF CTRLS????
//						Vars
//						Consts
//what is the syntax for these regarding fully-qualified names?
********************************************/

//Rule 19
operation createControllerAsProcessPara(c: RC!ControllerDef): Z!ProcessPara{
	var actionParaSeq = new Sequence<Z!ActionPara>;
	
	//to create operation sematics for defined ops
	for(op in c.lOperations){
		if(op.nodes.isDefined()){
//			actionParaSeq.add(createOperationDefAsActionPara(op));
			createOperationDefAsActionPara(op);
		}
	}
	
	//to create operation sematics for required ops
	var requiredOperations = new Set<RC!OperationSig>;
	for(ri in c.rInterfaces){
		for(op in ri.operations){
			requiredOperations.add(op);
		}
	}
	
	//eg.,
	//CALL__move1(id__,
//						    param_m,
//						    param_m1) 	= move1Call.param_m.param_m1 -> SKIP
//	createCallOpActionPara(op) = move1Call.param_m.param_m1 -> SKIP
	
	for(op in requiredOperations){
//		actionParaSeq.add(createCallOpActionPara(op));
		createCallOpActionPara(op);
	}
	
	
	
	var lvars = new Set<String>;
	for(v in allLocalVariables(c)){
		lvars.add("set_" + v.name);
	}
	
	var rvars = new Set<String>;
	for(v in requiredVariables(c)){
		rvars.add("set_EXT_" + v.name);
	}
	
	var lconsts = new Set<String>;
	for(v in allLocalConstants(c)){
		lconsts.add("set_" + v.name);
	}
	
	var rconsts = new Set<String>;
	for(v in requiredConstants(c)){
		rconsts.add("set_" + v.name);
	}
	
	var cs = lvars.includingAll(rvars).includingAll(lconsts).includingAll(rconsts);
	cs.add("terminate");
	//"terminate" is added to deal with the issue of EXCEPTION operator
	
	var cons = c.connections;
	var ms = c.machines.select(m|m.instanceOf(RC!StateMachineDef)).asSequence();
	var composeMachinePara = composeMachines(c,ms,cons).createActionPara("composeMachines_" + c.FQN());
//	var crtlMemoryPara = crtlMemory(c).createActionPara("crtlMemory_" + c.FQN());
	
	/* to create sequence of varaible initials/default as Z!Expr */
	var vars =  requiredVariables(c).asSequence().includingAll(allLocalVariables(c).asSequence());
	
	var initialSeq = new Sequence<Z!Expr>;
	for(v in vars){
		initialSeq.add(v.getInitialOrDefaultValueAsExpr());
		//in the manual: intial only, but it should be 'intial or default'
		//this paramter is presented in Rule 20 in the manual
		//Here we use this paramter initialSeq when we call the funciton crtlMemory in the below
	}
	
	//the following is derived from R20: constInit(c)
	//because we treat constants as paramters, so they are added into initialSeq as part of the paramter of crtlMemory
	for(const in allConstants(c)){
		if(const.initial.isDefined()){
			initialSeq.add(const.initial.createExpr());//parameter is the initial value of constant
			//TBC need to confirm with Pedro, should we always use const's name or we can use the value of it if exists?
		} else{
			initialSeq.add(createVarDecl(const));//parameter is the name of constant
			//e.g., Memory(id__, 0, 0, 0, (0,0), 0, const_pkg0_M_C1_c2, const_pkg0_M_C1_c3)
		}
	}
		
	var action = createParallelAction(cs, 
									  composeMachinePara.name.word.createCallAction(), 
									  crtlMemory(c).name.word.createCallAction(initialSeq) 
									  //call ctrlMemory with initials as parameters
									  );
	
	var hide_cs = lvars.asSequence().includingAll(rvars.asSequence()).includingAll(lconsts.asSequence());
	("hide_cs = " + hide_cs).println();
	("hide_cs.type() = " + hide_cs.type()).println();
	("action.type() = " + action.type()).println();
	action = action.createHideAction(hide_cs);
	
	
	
	//create main action
	action.createActionPara("controller_action_" + c.FQN());
	
	//add every actionpara including the main action para into the sequence
	for(action_para in Z!ActionPara.all()){
		actionParaSeq.add(action_para);
	}
	
	
	var mainActionname = "controller_action_" + c.FQN();
	
	
	var basicProcess = actionParaSeq.createBasicProcess(mainActionname);
	
	
	//is this a basic process? although actionParaSeq contains two actionparas
	return basicProcess.createProcessPara("controller_proc_" + c.FQN(), true);
	//true means it is a BasicProcss
	
}




//Rule 20, Memory in the manual is factored out as a function "ctrl_memory"
operation crtlMemory(c: RC!ControllerDef): Z!ActionPara{
	var ms = c.machines.select(m|m.instanceOf(RC!StateMachineDef));
	var lvars = allLocalVariables(c).asSequence();
	var rvars = requiredVariables(c).asSequence();

	var vars = rvars.includingAll(lvars) ;
//	var vars_names = vars.getNames();
//	var varvalues = rvars.getInitialValues().asSequence().includingAll(lvars.getInitialValues().asSequence());
	var varsAndconts = vars.includingAll(allConstants(c));
	
	return ctrl_memory(varsAndconts,lvars,rvars,ms,c).createActionPara("crtlMemory_" + c.FQN());
	//constInit(c) not covered as not shown in CSPM, constant c is processed as a parameter in CSPM.
	
}


//ctrl_memory is a function that returns a ParamAction 
operation ctrl_memory(
					  varsAndconts:  Sequence<RC!Variable>,
					  lvars: Sequence<RC!Variable>,
					  rvars: Sequence<RC!Variable>,
					  ms:    Set<RC!StateMachineDef>,
					  c:     RC!ControllerDef
					  ) 
					  :Z!ParamAction{	
	
	
	/******************************************************
	Step 1: Iterated external choices for LOCAL variables in lvars
	*******************************************************/
	
		var left_choice;
		
		if(lvars.size>0){
		var actionSeq_left_choice_lvars = new Sequence<Z!CircusAction>;
		
		for(v in lvars){
			var rmachines_v = ms.select(m|requiredVariables(m).includes(v));
			
			var prefixAction;//(; m : rmachines(v) . set_EXT_vid(v,m)! x -> Skip))
			if(rmachines_v.size()>0){
						
				if(rmachines_v.size() = 1){
					var prefix = createOutputCommunicationFromString("set_Ext_" + v.name + "_" + rmachines_v.at(0).FQN(), "x__", "OUTPUT");//To DO v.name is followed by rmachines_v.at(0).FQN(). If v.name is FQN, should be renamed as the simple name first.
					prefixAction = createPrefixingAction(prefix, createSkipAction());
				} else{
					var prefix = createOutputCommunicationFromString("set_Ext_" + v.name + "_" + rmachines_v.at(0).FQN(), "x__", "OUTPUT");//To DO v.name
					prefixAction = createPrefixingAction(prefix, createSkipAction());
					var i=1;
					while(i< rmachines_v.size()){
						var prefix = createOutputCommunicationFromString("set_Ext_" + v.name + "_" + rmachines_v.at(i).FQN(), "x__", "OUTPUT");//To DO v.name
						prefixAction = createPrefixingAction(prefix, prefixAction);
						i++;
					} 
				}
			
			}
			
			var commu = createInputCommunication("set_" + v.name, "x__"); //set_vid(v)?x //TBC here we use v.name instead of FQN because we assume all variables have the fully qualified names
			var action;
			
			//to replace the name of v with "x__"
			//RoboChart manual: Memory(vars[name(v):=x])
			var new_varsAndconts_names = new Sequence<String>;
			var varsAndconts_names = varsAndconts.getNames();
			

			var new_varsAndconts_names = new Sequence<String>;
			var size = varsAndconts.size();
			var i=0;
			var elem = new String;
			while(i<size){
				
				if(varsAndconts_names.at(i) = v.name){
					new_varsAndconts_names.add("x__");
				}
				else{
//					("line 1322, ss.at(i) = " + ss.at(i)).println();
//					("line 1322, ss.at(i).type = " + ss.at(i).type()).println();
					elem = varsAndconts_names.at(i);
					new_varsAndconts_names.add(elem);				
				}
				i++;
			}
			
			("line 1321, new_varsAndconts_names = " + new_varsAndconts_names).println();
			("line 1321, varsAndconts_names = " + varsAndconts_names).println();
			
			
			
			if(rmachines_v.size() >0){
				action = createAction2("SeqAction", 
										createPrefixingAction(commu, prefixAction), 
										("ctrlMemory_"+ c.FQN()).createCallAction(new_varsAndconts_names.createRefExprSeq(false,false))
										);
			} else{
				action = createPrefixingAction(commu, 
											   ("ctrlMemory_"+ c.FQN()).createCallAction(new_varsAndconts_names.createRefExprSeq(false,false))
											  );
			}
			actionSeq_left_choice_lvars.add(action);
		}
		
		if(lvars.size()>1){
			left_choice = actionSeq_left_choice_lvars.createSequenceAsExtchoiceAction();
		} else {//lvars.size()=1
			left_choice = actionSeq_left_choice_lvars.at(0);
		}
	}
	
	
	
	/******************************************************
	Step 2: Iterated external choices for REQUIRED variables in rvars
	*******************************************************/
	
	var right_choice;
	if(rvars.size>0){
		var actionSeq_right_choice_rvars = new Sequence<Z!CircusAction>;
		
		for(v in rvars){
		
			var rmachines_v = ms.select(m|requiredVariables(m).includes(v));
			var prefixAction; //(; m : rmachines(v) . set_EXT_vid(v,m)! x -> Skip))
			if(rmachines_v.size()>0){
			
				if(rmachines_v.size()=1){
					var prefix = createOutputCommunicationFromString("set_Ext_" + v.name + "_" + rmachines_v.at(0).FQN(), "x__", "OUTPUT");//TO DO v.name
					prefixAction = createPrefixingAction(prefix, createSkipAction());
				} else{
					var prefix = createOutputCommunicationFromString("set_Ext_" + v.name + "_" + rmachines_v.at(0).FQN(), "x__", "OUTPUT");//To DO v.name
					prefixAction = createPrefixingAction(prefix, createSkipAction());
					var i=1;
					while(i< rmachines_v.size()){
						var prefix = createOutputCommunicationFromString("set_Ext_" + v.name + "_" + rmachines_v.at(i).FQN(), "x__", "OUTPUT");//To DO v.name
						prefixAction = createPrefixingAction(prefix, prefixAction);
						i++;
					} 
				}
			
			}
			
			var commu = createInputCommunication("set_Ext_" + v.name, "x__"); //set_Ext_vid(v)?x //TBC here we use v.name instead of FQN because we assume all variables have the fully qualified names.
			var action;
			
			//to replace the name of v with "x__"
			//RoboChart manual: Memory(vars[name(v) := x])
			//to replace the name of v with "x__"
			//RoboChart manual: Memory(vars[name(v):=x])
			var new_varsAndconts_names = new Sequence<String>;
			var varsAndconts_names = varsAndconts.getNames();
			

			var new_varsAndconts_names = new Sequence<String>;
			var size = varsAndconts.size();
			var i=0;
			var elem = new String;
			while(i<size){
				
				if(varsAndconts_names.at(i) = v.name){
					new_varsAndconts_names.add("x__");
				}
				else{
					elem = varsAndconts_names.at(i);
					new_varsAndconts_names.add(elem);				
				}
				i++;
			}
			
			("line 1414, new_varsAndconts_names = " + new_varsAndconts_names).println();
			("line 1415, varsAndconts_names = " + varsAndconts_names).println();
			
					
			if(rmachines_v.size() >0){
				action = createAction2("SeqAction", 
									    createPrefixingAction(commu, prefixAction), 
									    ("ctrlMemory_"+ c.FQN()).createCallAction(new_varsAndconts_names.createRefExprSeq(false,false))
									   );
			} else{
				action = createPrefixingAction(commu, 
											   ("ctrlMemory_"+ c.FQN()).createCallAction(new_varsAndconts_names.createRefExprSeq(false,false))
											  );
			}
			actionSeq_right_choice_rvars.add(action);
		}
		
		if(rvars.size()>1){
			right_choice = actionSeq_right_choice_rvars.createSequenceAsExtchoiceAction();
		} else {//rvars.size()=1
			right_choice = actionSeq_right_choice_rvars.at(0);
		}
	}
	
	/******************************************************
	Step 3: external choices for lvars and rvars
	*******************************************************/
	var ctrlMemory;
	if(left_choice.isDefined() and right_choice.isDefined()){
		ctrlMemory = createAction2("ExtChoiceAction", left_choice, right_choice);
	} else{
		if(left_choice.isDefined()){
			ctrlMemory = left_choice;
		} else{//(right_choice.isDefined())
			ctrlMemory = right_choice;
		}
	}
	
	
	
	/******************************************************
	Step 4: external choices with end -> Skip
	 end -> Skip is not part of the manual, it is added to deal with
	the issue of exception operator
	*******************************************************/
	
	ctrlMemory = createAction2("ExtChoiceAction", 
								ctrlMemory, 
								createPrefixingAction(createSynchCommunication("terminate"), createSkipAction())
							   );
	
	
	
	/******************************************************
	Step 5: create ParamAction on top of ctrlMemory
	*******************************************************/
//	return ctrlMemory;
	var action = new Z!ParamAction;
	action.isParamCommand = true;
	action.circusAction = ctrlMemory;
	action.declList = new Z!ZDeclList;
	
	
	/* action.declList  is the list of parameters, including variables and constants
	   e.g., Memory(id__, cv1, x, m, a1, a3, c2, c3) 
	   c2 and c3 are constants  	*/
	
	//add all the variables and constants as parameters
	for(v in varsAndconts){
//		var value = new RC!Variable;
//		value.name = v.name;
//		value.type = clone(v.type);
//		action.declList.decls.add(createVarDecl(value));
		action.declList.decls.add(createVarDecl(v));
	}
	//e.g., Memory(id__, 0, 0, 0, (0,0), 0, const_pkg0_M_C1_c2, const_pkg0_M_C1_c3)
	
	
	return action;
	
}


operation Sequence<RC!Variable> getNames(): Sequence<String>{
	var nameSet = new Sequence<String>;
	for(v in self){
		nameSet.add(v.name);		
	}
	return nameSet;
}

operation Set<RC!Variable> getInitialValues(): Set<String>{
	var initSet = new Set<String>;
	for(v in self){
		initSet.add(v.initial.toString());		
	}
	return initSet;
}

//Rule 21
//Difference from manual: we use connevts.including(terminate) instead of connevts
operation composeMachines(c: RC!Controller, 
						  ms: Sequence<RC!StateMachineDef>, 
						  cons: Set<RC!Connection>): 
//						  Z!ActionPara{ //this function recursively revoke itself, it returns ActionPara, the code will be too complicated.
//the correspoinding ActionPara shall be created in Rule 19 when composeMachines() is called.
						  Z!CircusAction{
						  
	if(ms.size()=1){
		return renamingMachine(c,ms.at(0),cons);//TO DO, nops should be incorporated.		
	} else {
	
		var tail_ms = ms.clone();
		tail_ms.removeAt(0);
		
		var renStmEvts_tail = new Set<String>;
		("line 1453, tail_ms = " + tail_ms).println();
		for(m in tail_ms){
			renStmEvts_tail = renStmEvts_tail.includingAll(renStmEvts(c,m,cons));
		}
		var connevts = intersect(renStmEvts(c,ms.at(0),cons), renStmEvts_tail);
		
		var action = createParallelAction(connevts.including(terminate), renamingMachine(c,ms.at(0),cons), composeMachines(c,tail_ms,cons));//TO DO, nops should be incorporated.	
//		connevts.including(terminate) = connevts union {terminate}. terminate is added to slove the issue with exception operator
		
		return action;
//		return action.createActionPara("composeMachines_" + c.FQN());
		/************************************
		the ActionPara will be created in Rule 19 when the function composeMachines is call.
		we do not create ActionPara because the function composeMachines might be called multiple times to create members of the ultimate composeMachines.*************/
	}
	
						  
}

//Rule 22
operation renamingMachine(c: RC!Controller, 
						  m: RC!StateMachineDef, 
						  cons: Set<RC!Connection>): 
//						  Z!ActionPara{
						  Z!CircusAction{
						  
	var internalConns = new Set<RC!Connection>;
	for(con in RC!Connection.all()){
		if(con.from.instanceOf(RC!StateMachine) and con.to.instanceOf(RC!StateMachine) and Set{con.from, con.to}.includes(m)){
		internalConns.add(con);
		}
	}
	
	var toController = new Set<RC!Connection>;
	for(con in RC!Connection.all()){
		if(con.from = m and RC!Controller.all().includes(con.to)){
			toController.add(con);
		}
	}
	
	var fromController = new Set<RC!Connection>;
	for(con in RC!Connection.all()){
		if(con.to = m and RC!Controller.all().includes(con.from)){
			fromController.add(con);
		}
	}
	
	var renamepairL = new Sequence<String>;
	var renamepairR = new Sequence<String>;
	
	for(con in internalConns){
		 renamepairL.add(con.eto.name +"\\<cdot>in" );
		 renamepairR.add(con.efrom.name +"\\<cdot>out");
	}	
	
	for(con in internalConns){
		 renamepairL.add(con.eto.name +"\\<cdot>out" );
		 renamepairR.add(con.efrom.name +"\\<cdot>in");
	}	
	
	for(con in fromController){
		 renamepairL.add(con.eto.name);
		 renamepairR.add(con.efrom.name);
	}				  
						  
	for(con in toController){
		 renamepairL.add(con.efrom.name);
		 renamepairR.add(con.eto.name);
	}					  
	
	for(v in requiredConstants(m)){
		 renamepairL.add("set_" + v.name);
		 renamepairR.add("set_" + v.name); //TBC, "set_" + v.name should be replace by vid(v,c)?? but I don't know the definition of vid(v,c)
	}	
	
	var action = createStateMachineDefAsActionPara(m).name.word.createCallAction().createRenameAction(renamepairL, renamepairR);
	
	return action;
//	return action.createActionPara("renamingMachine_" + m.FQN());
}

//Rule 23
operation renStmEvts(c: RC!Controller, 
					 m: RC!StateMachineDef, 
					 cons: Set<RC!Connection>): 
					 Set<String>{
					 
	var internalConns = new Set<RC!Connection>;
	for(con in RC!Connection.all()){
		if(con.from.instanceOf(RC!StateMachine) and con.to.instanceOf(RC!StateMachine) and Set{con.from, con.to}.includes(m)){
		internalConns.add(con);
		}
	}
	
	var cs = new Set<String>;
	for(con in internalConns){
		cs.add(con.efrom.name);
	}				 
	
	cs.add("terminate");
	
	for(v in requiredConstants(m)){
		 cs.add("set_" + v.name);//TBC vid(v,c)  ??
	}
	
	return cs;
}

//Rule 25
operation createStateMachineDefAsActionPara(stm: RC!StateMachineDef): Z!ActionPara{
	var action = stateful(stm).name.word.createCallAction().createHideAction(Sequence{"terminate"});
	
	action = createAction2("SeqAction", action, createAction2("InterruptAction", "SSTOP".createCallAction(), createPrefixingAction(createSynchCommunication("terminate"), createSkipAction())));
	
	var renamepairL = new Sequence<String>;
	var renamepairR = new Sequence<String>;
	for(v in requiredVariables(stm)){
		 renamepairL.add("share");
		 renamepairR.add("set_EXT_" + v.name);
	}
	//TBC the direction of renaming
	
	action = action.createRenameAction(renamepairL, renamepairR);
	action = createParallelAction(Set{"shared"}, action, createSkipAction());
	
	var sharedVarSync = new Set<String>;
	for(v in requiredVariables(stm)){
		sharedVarSync.add("get_" + v.name);
		sharedVarSync.add("set_" + v.name);
		sharedVarSync.add("set_EXT_" + v.name);
	}
	
	var sharedVarHide = new Set<String>;
	for(v in requiredVariables(stm)){
		sharedVarHide.add("get_" + v.name);
	}
	
	var sharedConstSync = new Set<String>;
	for(v in requiredVariables(stm)){
		sharedVarHide.add("get_" + v.name);
	}
	
	var cs = sharedVarSync.includingAll(sharedConstSync);
	cs.add("terminate");
	
	action = createParallelAction(cs, action, sharedVarMemory(stm).name.word.createCallAction()).createHideAction(sharedVarHide.includingAll(sharedConstSync).asSequence());
	
	return action.createActionPara("stm_" + stm.FQN());
}

//Rule 26, the return type is different from the manual (Z!ChannelSet)
operation getsetChannels(stm: RC!StateMachineDef): Set<String>{
	var channelSet = new Set<String>;
	for(v in allVariables(s)){
		channelSet.add("get_" + v.name);
		channelSet.add("set_" + v.name);
	}
	for(v in allConstants(s)){
		channelSet.add("get_" + v.name);
		channelSet.add("set_" + v.name);
	}
	return channelSet;
}


//Rule 27
operation createOperationDefAsActionPara(op: RC!OperationDef): Z!ActionPara{
	var action = stateful(op).circusAction.createHideAction(Sequence{"terminate"});
	"lin 797".println(); op.eContainer().println();
	return action.createActionPara("stateful_op_" + op.FQN());
	
}

//Rule 28
//not to be implemented at the moment
//as this is not often used in RoboChart




/* Rule 32, 34, 36, 38 for constants are not implemented because constants are processed as parameters*/
//Rule 29, different from the manual: machineBody is taken out as a standalone operation
operation stateful(stm: RC!StateMachineBody): Z!ActionPara{
	
	var parallelL = machineBody(stm).name.word.createCallAction();
	var parallelR = varMemory(stm).name.word.createCallAction();
	var channelSet = getsetLocalChannels(stm);
	channelSet.add("terminate");
	
	var stateful = createParallelAction(channelSet, parallelL, parallelR).createHideAction(channelSet.asSequence());
	
	return stateful.createActionPara("stateful_"+ stm.FQN());
}

//Rule 29-2 - MachineBody
operation machineBody(stm: RC!StateMachineBody): Z!ActionPara{
	
	var parallelL = ncBehaviour(stm).name.word.createCallAction();
	var parallelR = createSkipAction();
	var channelSet = Set{"interrupt_" + stm.FQN()};
	var machineBody = createParallelAction(channelSet, parallelL,parallelR).createHideAction(Sequence{"enteredSS_"+stm.FQN()});
	
	return machineBody.createActionPara("machineBody_"+ stm.FQN());
}

//Rule 30, the return type is different from the manual (Z!ChannelSet)
operation getsetLocalChannels(s: RC!StateMachineBody): Set<String>{
	var channelSet = new Set<String>;
	for(v in allLocalVariables(s)){
		channelSet.add("get_" + v.name);
		channelSet.add("set_" + v.name);
	}
	return channelSet;
}

//Rule 31
operation varMemory(stm: RC!Context): Z!ActionPara{


	var vars = allLocalVariables(stm);
	
	//to generate Individual variable memory as ActionPara for each variable in vars
	for(v in vars){
		("line 1581, v = " + v + ", type.type.NAME = " + v.type.type.name  + ", v.type.type()" + v.type.type()).println();
		//,  type.ref.name =  + v.type.ref.name
		Memory(v);
	}
	
	
	var varMemory;
	if(vars.size()=0){
		varMemory = createPrefixingAction(createSynchCommunication("terminate"), createSkipAction());
	} 
	
	else if(vars.size()=1) {
		
		var action_name = "Memory_"+ vars.at(0).name;
		var ParaSeq = Sequence{vars.at(0).getInitialOrDefaultValueAsExpr()};
		varMemory = action_name.createCallAction(ParaSeq);
		//By assigning initial or default value as parameter of this CallAction, 
		//Memory(x) is instantiated.
	} 
	
	else if(vars.size()>1){
		("line 1600, vars = " + vars).println();
		var action_name0 = "Memory_"+ vars.at(0).name;
		var ParaSeq0 = Sequence{vars.at(0).getInitialOrDefaultValueAsExpr()};	("line 1602, ParaSeq0 = " + ParaSeq0).println();
		var action0 = action_name0.createCallAction(ParaSeq0);
		
		var action_name1 = "Memory_"+ vars.at(1).name;
		("line 1606, vars.at(1) = " + vars.at(1)).println();
		("line 1606, vars.at(1).type = " + vars.at(1).type).println();		
		("line 1606, vars.at(1).type.type() = " + vars.at(1).type.type().name).println();		
//		("line 1606, vars.at(1).type.ref = " + vars.at(1).type.ref).println();
		var ParaSeq1 = Sequence{vars.at(1).getInitialOrDefaultValueAsExpr()};
		("ParaSeq1 = " + ParaSeq1).println();
		var action1 = action_name1.createCallAction(ParaSeq1);
		
		
		varMemory = createParallelAction(
						Set{"terminate"}, 
						action0, 
						action1
					);
		
		vars.removeAt(0);
		vars.removeAt(0);		
		while(vars.size()>0){
			("line 1627, v = " + vars.at(0) + ", type.type.NAME = " + vars.at(0).type.type.name  + ", v.type.type()" + vars.at(0).type.type()).println();
		
			var action_name = "Memory_"+ vars.at(0).name;
			var ParaSeq = Sequence{vars.at(0).getInitialOrDefaultValueAsExpr()};
			var action = action_name.createCallAction(ParaSeq);
		
			varMemory = createParallelAction(Set{"terminate"}, varMemory, action);			
			vars.removeAt(0);
		}
	}
	
	return varMemory.createActionPara("varMemory_"+ stm.FQN());
}


operation RC!Variable getInitialOrDefaultValueAsExpr(): Z!Expr{

	("line 1643, var = " + self).println();
	if(self.initial != null){
		"self.initial != null".println();
		return self.initial.createExpr();
	} else{
		
		"self.initial = null".println();
		return self.type.defaultValueAsZExpr();			
	}
}



//Rule 33, follows the same pattern as Rule 31


operation sharedVarMemory(stm: RC!Context): Z!ActionPara{


	var vars = requiredVariables(stm);
	
	//to generate Individual shared variable memory as ActionPara for each variable in vars
	for(v in vars){
		("line 1566, v = " + v + ", v.type = " + v.type   +  ", v.type.type = " + v.type.type  + ", type.type.NAME = " + v.type.type.name  + ", v.type.type()= " + v.type.type()).println();
		//,  type.ref.name =  + v.type.ref.name
		sharedMemory(v);
	}
	
	
	var sharedVarMemory;
	if(vars.size()=0){
		sharedVarMemory = createPrefixingAction(createSynchCommunication("terminate"), createSkipAction());
	} 
	
	else if(vars.size()=1) {
		
		var action_name = "sharedMemory_"+ vars.at(0).name;
		var ParaSeq = Sequence{vars.at(0).getInitialOrDefaultValueAsExpr()};
		sharedVarMemory = action_name.createCallAction(ParaSeq);
		//By assigning initial or default value as parameter of this CallAction, 
		//Memory(x) is instantiated.
	} 
	
	else if(vars.size()>1){
		("line 1600, vars = " + vars).println();
		var action_name0 = "sharedMemory_"+ vars.at(0).name;
		var ParaSeq0 = Sequence{vars.at(0).getInitialOrDefaultValueAsExpr()};	//("line 1602, ParaSeq0 = " + ParaSeq0).println();
		var action0 = action_name0.createCallAction(ParaSeq0);
		
		var action_name1 = "sharedMemory_"+ vars.at(1).name;
//		("line 1606, vars.at(1) = " + vars.at(1)).println();
//		("line 1606, vars.at(1).type = " + vars.at(1).type).println();		
//		("line 1606, vars.at(1).type.type() = " + vars.at(1).type.type().name).println();		
//		("line 1606, vars.at(1).type.ref = " + vars.at(1).type.ref).println();
		var ParaSeq1 = Sequence{vars.at(1).getInitialOrDefaultValueAsExpr()};
		("ParaSeq1 = " + ParaSeq1).println();
		var action1 = action_name1.createCallAction(ParaSeq1);
		
		
		sharedVarMemory = createParallelAction(
						Set{"terminate"}, 
						action0, 
						action1
					);
		
		vars.removeAt(0);
		vars.removeAt(0);		
		while(vars.size()>0){

			var action_name = "sharedMemory_"+ vars.at(0).name;
			var ParaSeq = Sequence{vars.at(0).getInitialOrDefaultValueAsExpr()};
			var action = action_name.createCallAction(ParaSeq);
		
			sharedVarMemory = createParallelAction(Set{"terminate"}, sharedVarMemory, action);			
			vars.removeAt(0);
		}
	}
	
	return sharedVarMemory.createActionPara("sharedVarMemory_"+ stm.FQN());
}



//Rule 35 
/*this is different from the manual in two ways
1. the main body is moved to function IndividualVarMemory
2. the initial or default value of the variable is assigned in Rule according to the manual, but in CSPM code, it is assigned when Memory(v) is called in varMemory; So to be consistent with CSPM, the within part in Rule 35 of manual is moved to Rule 31 here above.

In fact, there is no need to have a ParamAction, because the parameter value is
only assigned as initial or default, that is a one time thing, so it can be done directly in IndividualVarMemory. However, to be consistent with manual, the implementation still uses ParamAction.
*/
operation Memory(v: RC!Variable): Z!ActionPara{

	return IndividualVarMemory(v).createActionPara("Memory_" + v.name);

}

/*
	so, Memory_a(0) =
					get_a!0 -> Memory_a(0)
					[]
					set_a?x__ -> Memory_a(x__)
					[]
					terminate -> SKIP  ??
Memory_a(0) is an action whose name is Memory_a, parameter is a RC!Expression 0 in this case
*/

/*e.g., Memory_a(0) where
		Memory_a(value) =
					get_a!value -> Memory_a(value)
					[]
					set_a?x__ -> Memory_a(x__)
					[]
					terminate -> SKIP
here we need ParamAction  */
//Rule 35 auxilary
/*IndividualVarMemory is a function taking variable v as its paramter
 *it returns a ParamAction whose paramter is value of type RC!Expression
 *we do not create AcitonPara in this function because IndividualVarMemory is 
 *recursive, it makes code simple if we create ActionPara at the final step
 *i.e., in Rule 35*/
operation IndividualVarMemory(v: RC!Variable): Z!ParamAction{
	
	
	var commu1  = createOutputCommunicationFromString("get_" + v.name, "value", "OUTPUT");
	var choice1 = createPrefixingAction(
						commu1, 
						("Memory_"+v.name).createCallAction(Sequence{"value".createRefExpr(false, false)})
						); 
	
	
	
	var commu2  = createInputCommunication("set_" + v.name, "x__");
	var choice2 = createPrefixingAction(
						commu2, 
						("Memory_"+v.name).createCallAction(Sequence{"x__".createRefExpr(false, false)})
						);  
	
	var choice3 = createPrefixingAction(createSynchCommunication("terminate"), createSkipAction());
	
	var memory = createAction2("ExtChoiceAction", choice1, createAction2("ExtChoiceAction", choice2, choice3));
	
	var action = new Z!ParamAction;
	action.isParamCommand = true;
	action.circusAction = memory;
	
	var value = new RC!Variable;
	value.name = "value";
	("line 1745,  v.type = " + v.type).println();
	("line 1746,  v.type.type() = " + v.type.type()).println();
	("line 1738,  v.type.type = " + v.type.type).println();
//	("line 1739,  v.type.ref = " + v.type.ref).println();
	value.type = clone(v.type);
//	param.type.ref = clone(v.type.ref);
//	("line 1741,  v.type = " + v.type.type.ref).println();
//	("line 1742,  v.type = " + v.type.type.ref).println();
	("line 1750, value.type = " + value.type).println();
//	("line 1750, value.type.ref = " + value.type.ref).println();
	action.declList = new Z!ZDeclList;
	action.declList.decls.add(createVarDecl(value));
	
	return action;
}

//TO DO
operation RC!Type defaultValueAsZExpr(): Z!Expr{
("line 1807, self.type().name = " + self.type().name).println();

	if(self.type().name = "TypeRef"){
		"self.type = TypeRef" .println();
		self.ref.name.println();
		if(self.ref.name = "int"){
			return createNumExpr(0);
		}
//		if(self.ref.name = "float"){
//			return createNumExpr(0);//TO DO
//		}
//		if(self.ref.name = "String"){
//			return createNumExpr(0);//TO DO
//		}
		if(self.ref.name = "Boolean"){
			return createBooleanExpr(true);
		} 
		
		if(self.ref.name != "Boolean" and self.ref.name != "int") {
			return createNumExpr(0);
		}
		
		else {//TO DO
		
		}
	}
	
	if(self.type().name = "SeqType"){
	
	("line 1830, self = "  + self).println();
	("line 1831, self.values = "  + self.values).println();
		
	}

	if(self.type().name = "ProductType"){
		var typeSeq = new Sequence<Z!Expr>;
		for(tp in self.types){
			("line 1840, tp = " + tp).println();
			typeSeq.add(tp.defaultValueAsZExpr());
		}
		return typeSeq.createTupleExpr();
		
	}
	/*
	if(self.type().name = "RelationType"){
	
	}
	if(self.type().name = "FunctionType"){
	
	}
	if(self.type().name = "SetType"){
	
	}
	
	if(self.type().name = "AnyType"){
	
	}
	if(self.type().name = "VectorType"){
	
	}
	if(self.type().name = "MatrixType"){
	
	}
	*/
}

operation createNumExpr(value: Integer): Z!NumExpr{
	var numExpr = new Z!NumExpr;
	numExpr.numeral = new Z!ZNumeral;
	numExpr.numeral.value = value;
	
	return numExpr;
}

operation createBooleanExpr(value: Boolean): Z!RefExpr{
	var boolExpr = new Z!RefExpr;
	boolExpr.mixFix = false;
	boolExpr.explicit = false;
	boolExpr.name = new Z!ZName;
	if(value = true){
		boolExpr.name.word ="True";
	} else {
		boolExpr.name.word ="False";
	}
	
	return boolExpr;
}

//TO be confirmed
//Rule 37, follows the same pattern of Rule 35

operation sharedMemory(v: RC!Variable): Z!ActionPara{

	return IndividualSharedVarMemory(v).createActionPara("sharedMemory_" + v.name);

}

//Rule 37 auxilary
operation IndividualSharedVarMemory(v: RC!Variable): Z!ParamAction{
	
	
	var commu1  = createOutputCommunicationFromString("get_" + v.name, "value", "OUTPUT");
	var choice1 = createPrefixingAction(
						commu1, 
						("sharedMemory_"+v.name).createCallAction(Sequence{"value".createRefExpr(false, false)})
						); 
	
	
	
	var commu2  = createInputCommunication("set_" + v.name, "x__");
	var choice2 = createPrefixingAction(
						commu2, 
						("sharedMemory_"+v.name).createCallAction(Sequence{"x__".createRefExpr(false, false)})
						);  
						
	var commu3  = createInputCommunication("set_EXT_" + v.name, "x__");
	var choice3 = createPrefixingAction(
						commu3, 
						("sharedMemory_"+v.name).createCallAction(Sequence{"x__".createRefExpr(false, false)})
						);  
	
	var choice4 = createPrefixingAction(createSynchCommunication("terminate"), createSkipAction());
	
	var sharedMemory = createAction2("ExtChoiceAction", choice1, createAction2("ExtChoiceAction", choice2, createAction2("ExtChoiceAction", choice3, choice4)));
	
	var action = new Z!ParamAction;
	action.isParamCommand = true;
	action.circusAction = sharedMemory;
	
	var value = new RC!Variable;
	value.name = "value";
//	("line 1745,  v.type = " + v.type).println();
//	("line 1746,  v.type.type() = " + v.type.type()).println();
//	("line 1738,  v.type.type = " + v.type.type).println();
//	("line 1739,  v.type.ref = " + v.type.ref).println();
	value.type = clone(v.type);
//	param.type.ref = clone(v.type.ref);
//	("line 1741,  v.type = " + v.type.type.ref).println();
//	("line 1742,  v.type = " + v.type.type.ref).println();
	("line 1931, value.type = " + value.type).println();
//	("line 1750, param.type.ref = " + param.type.ref).println();
	action.declList = new Z!ZDeclList;
	action.declList.decls.add(createVarDecl(value));
	
	return action;
}



operation nc(stmt: RC!Statement): RC!NodeContainer{
	for(nc in RC!NodeContainer.all()){
		
		for(st in nc.nodes.select(s|s.instanceOf(RC!State))){
			if(st.actions.size()>0){
				for(action in st.actions){
					if(action.action = stmt){
						return nc;
					}
				}
			}
		}	
		
		for(tr in nc.transitions){
			if(tr.action = stmt){
				return nc;
			}			
		}
	}
}


operation clone(type : RC!Type) : RC!Type   {
	var emfTool = new Native("org.eclipse.epsilon.emc.emf.tools.EmfTool");
	var ecoreUtil = emfTool.ecoreUtil;
	var cloned = ecoreUtil.copy(type);
	return cloned;
}


operation clone(i : Integer) : Integer   {
	var emfTool = new Native("org.eclipse.epsilon.emc.emf.tools.EmfTool");
	var ecoreUtil = emfTool.ecoreUtil;
	var cloned = ecoreUtil.copy(i);
	return cloned;
}



operation clone(i : String) : String   {
	var emfTool = new Native("org.eclipse.epsilon.emc.emf.tools.EmfTool");
	var ecoreUtil = emfTool.ecoreUtil;
	var cloned = ecoreUtil.copy(i);
	return cloned;
}

operation clone(typeref : RC!TypeRef) : RC!TypeRef   {
	var emfTool = new Native("org.eclipse.epsilon.emc.emf.tools.EmfTool");
	var ecoreUtil = emfTool.ecoreUtil;
	var cloned = ecoreUtil.copy(typeref);
	return cloned;
}



operation clone(stmdef : RC!StateMachineDef) : RC!StateMachineDef   {
	var emfTool = new Native("org.eclipse.epsilon.emc.emf.tools.EmfTool");
	var ecoreUtil = emfTool.ecoreUtil;
	var cloned = ecoreUtil.copy(stmdef);
	return cloned;
}

operation clone(ctldef : RC!ControllerDef) : RC!ControllerDef   {
	var emfTool = new Native("org.eclipse.epsilon.emc.emf.tools.EmfTool");
	var ecoreUtil = emfTool.ecoreUtil;
	var cloned = ecoreUtil.copy(ctldef);
	return cloned;
}

operation clone(vl : RC!VariableList) : RC!VariableList   {
	var emfTool = new Native("org.eclipse.epsilon.emc.emf.tools.EmfTool");
	var ecoreUtil = emfTool.ecoreUtil;
	var cloned = ecoreUtil.copy(vl);
	return cloned;
}


operation clone(v : RC!Variable) : RC!Variable   {
	var emfTool = new Native("org.eclipse.epsilon.emc.emf.tools.EmfTool");
	var ecoreUtil = emfTool.ecoreUtil;
	var cloned = ecoreUtil.copy(v);
	("line 554 v.modifier = " + v.modifier).println();
	("line 555 cloned.modifier = " + cloned.modifier).println();
/**************************************
	Not working: cloned.modifier = v.modifier; 
    var.modifer is a DERIVED attribute, can not be changed
    the cloned var has a default modifier VAR even if v is a constant
    to slove this issue, we need to clone VariableList then collect all the vars from it.
****************************************/
	return cloned;
}

//return the controller that contains the statemachineref stmr
operation ctl(stmr: RC!StateMachineRef): RC!ControllerDef{
	for(ctl in RC!ControllerDef.all()){
		if(ctl.machines.includes(stmr)){
			return ctl;
		}
	}
}






//CSP Rule 44-0
//return the vaiables as models instead of strings
//TO DO: depend on the context using this operation, this operation might not be complete
//need to be revisited
operation usedVariablesModel(stmt:RC!Statement):Set<Variable>{
	var varSet = new Set<Variable>;
	var container = nc(stmt);//this is to be passed to Rule 45, so that the variable name can be fully qualified with container's name, but not the component that declares the var
	
	if(stmt.instanceOf(RC!Assignment)){
		varSet = usedVariablesInExprModel(stmt.right,container);
	} else
	if(stmt.instanceOf(RC!Call)){
		for(arg in stmt.args){
			varSet = varSet.includingAll(usedVariablesInExprModel(arg,container));
		}
	} else
	//stmt.then and stmt.else are handled in the IfStmt incontext semantics
	if(stmt.instanceOf(RC!IfStmt)){
		varSet = usedVariablesInExprModel(stmt.expression,container);
	} else
	if(stmt.instanceOf(RC!CommunicationStmt) and (stmt.communication._type=CommunicationType#SYNC or stmt.communication._type=CommunicationType#OUTPUT)){
		varSet = usedVariablesInExprModel(stmt.communication.value,container);
	} else
//	if(stmt.instanceOf(RC!SeqStatement)){
//		for(s in stmt.statements){
//			varSet = varSet.includingAll(usedVariables(s));
//		}
//	} else
//	if(stmt.instanceOf(RC!ParStmt)){
//		varSet = usedVariables(stmt.stmt);
//	} else
	if(stmt.instanceOf(RC!TimedStatement)){
		varSet = usedVariables(stmt.stmt).includingAll(usedVariables(stmt.deadline));
	} else
	{//SeqStatement falls in this case
	}
	
	return varSet;
}

//CSP Rule 45-0
//to return a set of Variable models, instead of Variable name strings
operation usedVariablesInExprModel(expr:RC!Expression, container: Any): Set<Variable>{
	var set = new Set<String>;
	if(expr = null
	 //when expr is concreate value (int, float, string, boolean, ect.), as these do not fall into any if case, therefore, set = {}
	 //or expr.instanceOf(IntegerExp) or expr.instanceOf(FloatExp) or expr.instanceOf(StringExp) or expr.instanceOf(BooleanExp)
	 ){
	} else
	if(expr.instanceOf(RefExp)){
		var value = expr.ref;
		if(value.instanceOf(RC!Variable) and value.modifier= VariableModifier#VAR){
			set.add(value);
			//here we tried to use operation nc() to return the basiccontext that defines this variable
			//However, the var may be declared in another component
			//therefore we do not need to pass the parameter 'container' to the usedVariables operaiton as below
//			set.add(value.name + "_" + container.FQN());
		}

	} else
	{
		"line814".println();
		 expr.eContents.println();
		 "line816".println();
		for(obj in expr.eContents){
			if(obj.instanceOf(RC!Expression)){
//				set = set.includingAll(usedVariables(obj));
				set = set.includingAll(usedVariablesInExprModel(obj,container));
			}
		}
		
	}
	
	return set;
}


//to return the nodecontainer of the variable
//TO DO: the required var
operation nc(v: RC!Variable): RC!BasicContext{

	//Case 1: v belongs to a STMDef
	for(nc in RC!StateMachineDef.all()){
		for(vl in nc.variableList){
			if(vl.modifier = RC!VariableModifier#VAR and vl.vars.includes(v)){
				return nc;
			}
		}
	}
	
	//Case 2: v belongs to a OperationDef
	for(nc in RC!OperationDef.all()){
		for(vl in nc.variableList){
			if(vl.modifier = RC!VariableModifier#VAR and vl.vars.includes(v)){
				return nc;
			}
		}
	}
	
	//Case 3: v belongs to a ControllerDef
	for(nc in RC!ControllerDef.all()){
		for(vl in nc.variableList){
			if(vl.modifier = RC!VariableModifier#VAR and vl.vars.includes(v)){
				return nc;
			}
		}
	}
	
	//Case 4: v belongs to a PlatformDef
	for(nc in RC!RoboticPlatformDef.all()){
		for(vl in nc.variableList){
			if(vl.modifier = RC!VariableModifier#VAR and vl.vars.includes(v)){
				return nc;
			}
		}
	}
	
	
	//Case 5: v belongs to a Interface
	for(nc in RC!Interface.all()){
		for(vl in nc.variableList){
			if(vl.modifier = RC!VariableModifier#VAR and vl.vars.includes(v)){
				return nc;
			}
		}
	}
}




//return the module that contains the controller ctlr
operation module(ctlr: RC!ControllerRef): RC!RCModule{
	for(module in RC!RCModule.all()){
		if(module.nodes.includes(ctlr)){
			return module;
		}
	}
}

//Spec is the ROOT element of the generated Circus model, it contains a narrative section and a ZSection
operation createSpec(zsect: Z!ZSect): Z!Spec{
	var spec = new Z!Spec;
	var narrativeSect = new Z!NarrSect;
	spec.sects = Sequence{narrativeSect, zsect};
	return spec;
}


operation createZSect(
	sect_name: String,
	paraSeq: Sequence<Z!Para>,
	parentNameSeq: Sequence<String>
	): Z!ZSect{
	
	var zsect = new Z!ZSect;
	zsect.name = sect_name;
	
	zsect.paraList = new Z!ZParaList;
	zsect.paraList.paras = paraSeq;
	
	zsect.parents = createParentList(parentNameSeq);
	
	return zsect;
}

//used in createZSect
operation createParentList(parentNameSeq: Sequence<String>): Sequence<Z!Parent>{
	var parents = Sequence<Z!Parent>;
	parents = Sequence{};
	for(p in parentNameSeq){
		parents.add(createParent(p));
	}
	return parents;
}

operation createParent(p: String): Z!Parent{
	var parent = new Z!Parent;
	parent.word = p;
	return parent;
}

operation Z!ZSect addPara2ZSect(para: Z!Para): Z!ZSect{
	var zsect =  self;
	zsect.paraList.paras.add(para);
	return zsect;

}

//used to create NIDS enumeration typePara
operation Z!Freetype createEnumTypePara(): Z!FreePara{
	var freePara = new Z!FreePara;
	freePara.freetypeList =  new Z!ZFreetypeList;
	freePara.freetypeList.freeTypes.add(self);
	
	return freePara;
}


//to create enumeration type to be used for channels, e.g., channel internal__: NIDS, where NIDS is a enumeration type
operation createEnumType(
	name: String, 
	str_seq: Sequence<String>
	): Z!Freetype{
	
	var enumType = new Z!Freetype;
	enumType.name = name.createZName();
	
	var branchList = new Z!ZBranchList;
	for(elm in str_seq){
		branchList.branches.add(elm.createBranch());
	}
	enumType.branchList = branchList;
	
	return enumType;
}


//used in createEnumType
operation String createBranch(): Z!Branch{
	var branch = new Z!Branch;
	branch.name = self.createZName();
	return branch;
	//branch.expr = null;
}
//
//Fully Qualified Name for Node
operation RC!Node FQN(): String{
	var  stm_sets = RC!StateMachineDef.all();
	
	//Case 1: the node is contained in a stm
	for(stm in stm_sets){
		if(stm.nodes.includes(self)){
			return self.name+"_"+ stm.FQN();
		}
	}
	
	var op_sets = RC!OperationDef.all();
	//Case 2: the node is contained in a opdef
	for(op in op_sets){
		if(op.nodes.includes(self)){
			return self.name+"_"+ op.FQN();
		}
	}
	
	//Case 3: the node is contained in a composite node
//	for(nd in RC_model!Node.all()){
	for(nd in RC!Node.all()){
		if(nd.nodes.isDefined() and nd.nodes.size()>0){
			if(nd.nodes.includes(self)){
				return self.name+"_"+ nd.FQN();
			}
		}
	}	
}

/*
//Fully Qualified Name for events
operation RC!Event FQN(): String{
	var  stm_sets = RC!StateMachineDef.all();
	"line 13".println();
	stm_sets.println();
	
	//Case 1: the event is contained in a stmdef
	for(stm in stm_sets){
		if(stm.events.includes(self)){
			return self.name+"_"+ stm.FQN();
		}
	}
	
	//Case 2: the node is contained in a controllerdef node
	for(ctl in RC!ControllerDef.all()){
		if(ctl.events.includes(self)){
			return self.name + "_" + ctl.FQN();
		}
	}	
	
	//Case 3: ?? TBC
}
*/


//Fully Qualified Name for StateMachineDef
operation RC!OperationDef FQN(): String{

	//Case 1: the op is contained in a controllerdef
	for(ctl in RC!ControllerDef.all()){
		if(ctl.lOperations.includes(self)){
			return self.name + "_" + ctl.FQN();
		}
	}
	
	//Case 2: the stm is contained in a package
	for(pkg in RC!RCPackage.all()){
		if(pkg.operations.includes(self)){
			if(pkg.name.isDefined()){
				return self.name + "_" + pkg.name;			
			}else{
				return self.name;	
			}
		}
	}	
	
	//a module can not have a stm outside a controller
}

//Fully Qualified Name for StateMachineDef
operation RC!StateMachineDef FQN(): String{

	//Case 1: the stm is contained in a controllerdef
	for(ctl in RC!ControllerDef.all()){
		if(ctl.machines.includes(self)){
			return self.name + "_" + ctl.FQN();
		}
	}
	
	//Case 2: the stm is contained in a package
	for(pkg in RC!RCPackage.all()){
		if(pkg.machines.includes(self)){
			if(pkg.name.isDefined()){
				return self.name + "_" + pkg.name;			
			}else{
				return self.name;	
			}
		}
	}	
	
	//a module can not have a stm outside a controller
}


//Fully Qualified Name for ControllerDef
operation RC!ControllerDef FQN(): String{
	//Case 1: the controller is contained in a module
	for(md in RC!RCModule.all()){
		if(md.nodes.includes(self)){
			return self.name + "_" + md.FQN();
		}
	}
	
	//Case 2: the controller is contained in a package
	for(pkg in RC!RCPackage.all()){
		if(pkg.controllers.includes(self)){
			if(pkg.name.isDefined()){
				return self.name + "_" + pkg.name;			
			}else{
				return self.name;	
			}
		}
	}
}


//interface does not have a semantics function, its name is ignored?
operation RC!Interface FQN(): String{

	for(pkg in RC!RCPackage.all()){
		if(pkg.interfaces.includes(self)){
			if(pkg.name.isDefined()){
				return  pkg.name;			
			}else{
				return null;	
			}
		}
	}
}

// Fully Qualified Name for RCModule
operation RC!RCModule FQN(): String{

	//Case 1: the module is contained in a package
	for(pkg in RC!RCPackage.all()){
		if(pkg.modules.includes(self)){
			if(pkg.name.isDefined()){
				return self.name + "_" + pkg.name;			
			}else{
				return self.name;	
			}
		}
	}		
}





//channel decleration and channelset declaration for node container (NC)
operation RC!NodeContainer createchanParaNC()  {
	
	//1. channel internal__: NIDS
	
	var NID_node_seq = Sequence<String>;
	NID_node_seq = Sequence{};
		
	for(n in self.nodes){
		NID_node_seq.add("NID_" + n.FQN());
	}
	
	//CSPM: datatype NIDS = NID_i0 | NID_s0 | ...
	var NIDS = createEnumType("NIDS_"+self.FQN(), NID_node_seq);
	
	var NIDS_para = NIDS.createEnumTypePara();
	
	//CSPM: channel internal__:NIDS
	var internal_chanpara = Sequence{"internal__"+self.FQN()}.createChannelPara("internal_channel_" + self.FQN(), NIDS.name.word);
	
//	for(n in self.nodes){
//		node_seq.add("internal__NID_" + n.FQN());
//	}
	//	var internal_chanpara = node_seq.createChannelPara("internal_chan_" + self.FQN());
	
	

	
	//2. Flow channel: interrupt, exited, exit, terminate
	var flow_chanpara = Sequence{"interrupt_"+self.FQN(), "exited_"+self.FQN(), "exit_"+self.FQN(), "terminate"}.createChannelPara("flowchannel_" + self.FQN());



	//3. variable channels, each var has a channel declaration, as vars can have different types, while the channels in the chandecl.list should have the same type.
	
	var var_chanpara = createChannelPara("variable_channel_" + self.FQN());
	for(vl in self.variableList){
		if(vl.modifier = RC!VariableModifier#VAR){
//			var i=0;
			for(v in vl.vars){
				
				var type_expr = v.type.createTypeExpr();
				
				var var_seq = Sequence{"get_" + v.name , 
									   "set_" + v.name, 
									   "setL_" + v.name , 
									   "setR_" + v.name };
									   
				var_chanpara.declList.decls.add(var_seq.createChannelDecl(type_expr));
				
				
//				var_chanpara.declList.decls.at(i).addChan2ChanDecl("get_" + v.FQN(), type_expr);
//				var_chanpara.declList.decls.at(i).addChan2ChanDecl("set_" + v.FQN(), type_expr);
//				var_chanpara.declList.decls.at(i).addChan2ChanDecl("setL_" + v.FQN(), type_expr);
//				var_chanpara.declList.decls.at(i).addChan2ChanDecl("setR_" + v.FQN(), type_expr);
//				i++;
			}
		}
	}
	
	
	//4. Shared variable channels
	if(self.hasSharedVars()){//i.e., has requied interface which contains variables
		var shared_var_chanpara = createChannelPara("shared_var_channel_" + self.FQN());
		for(ri in self.rInterfaces){
			for(vl in ri.variableList.select(l|l.modifier = VariableModifier#VAR)){
				for(v in vl.vars){
					
					var type_expr = v.type.createTypeExpr();
					
					var var_seq = Sequence{"set_EXT_" + v.name};
					//TBC with Pedro: v to be FQN at which level? stm or ctrl or pkg?
					
					shared_var_chanpara.declList.decls.add(var_seq.createChannelDecl(type_expr));
				}
			}
		}
	}
	
	
		
	
	
	//5. Local variable channels for defined operations that are required by the state machine
	//TO DO
	
	
	//6. Declaring state machine events as channels

	var evt_chanpara = createChannelPara("event_channel_" + self.FQN());
	
	//Case 1: to create the type for the state machine event channels (external), 
	//e.g., CSPM: trigger1:InOut.core_int;   NIDS is not involved.
	//Circus: trigger1_in ::int, trigger1_out ::int
	for(e in self.events){
				
//		var evt_seq = Sequence{e.FQN() + "_in", //CSPM InOut enumtype is removed for Circus, so becomes 2 channels
//							   e.FQN() + "_out"};
	
		var evt_seq = Sequence{e.name + "_in", //CSPM InOut enumtype is removed for Circus, so becomes 2 channels
							   e.name + "_out"};
									   
		if(e.type=null){
			evt_chanpara.declList.decls.add(evt_seq.createChannelDecl());	
		}else{
			var type_expr = e.type.createTypeExpr();
			evt_chanpara.declList.decls.add(evt_seq.createChannelDecl(type_expr));
		}
	}
	
	//Case 2: to generate channels for the events to be used as transition triggers
	//e.g., CSPM: trigger1__:NIDS.InOut.core_int
	//Circus: trigger1_stm0_pkg0__in :: NIDS x int
	for(e in self.events){
//		var evt_seq = Sequence{e.FQN() + "__in"//,
//							 //e.FQN() + "__out" , this is removed because the out channel is not necessary, as e.NIDS channel is only used for transition triggers, and a trigger can only be an input.
//							   };	

		var evt_seq = Sequence{e.name + "__in"//,
							 //e.name + "__out" , this is removed because the out channel is not necessary, as e.NIDS channel is only used for transition triggers, and a trigger can only be an input.
							   };	
							   							   	
		if(e.type=null){
			evt_chanpara.declList.decls.add(evt_seq.createChannelDecl(NIDS.name.word));	
		}else{
			var type_expr = e.type.createTypeExpr();
			
			//to create the PRODUCT type for the state machine event channels (internal), 
			//e.g., CSPM: trigger1__:NIDS.InOut.core_int
			type_expr = createProdExpr(NIDS.name.word.createTypeExpr(), type_expr);					   
			evt_chanpara.declList.decls.add(evt_seq.createChannelDecl(type_expr));
		}
	}
	
	//7. Declaring call and ret events for undefined operations as channels
	
	if(self.hasRequiredOps()){//TBC with Pedro: is hasRequiredOps enough?
		var undefined_ops_chanpara = createChannelPara("undefined_op_channel_" + self.FQN());
		for(ri in self.rInterfaces){
			for(op in ri.operations){
				var op_seq = Sequence{op.name + "Call"};
				var size = op.parameters.size();
				if(size = 0){
	
					undefined_ops_chanpara.declList.decls.add(op_seq.createChannelDecl());	
	
				} else if(size = 1){
										
					var type_expr = op.parameters.at(0).type.createTypeExpr();
					undefined_ops_chanpara.declList.decls.add(op_seq.createChannelDecl(type_expr));
					
				} else if(op.parameters.size()>1){
					
					var prodExpr = createProdExpr(op.parameters.at(0).type.createTypeExpr(), op.parameters.at(1).type.createTypeExpr());
					var i = 2;
					if(size > 2){
						while(i<size){
							prodExpr = createProdExpr(prodExpr,op.parameters.at(i).type.createTypeExpr());
							i++;
						}
					}		
				
					undefined_ops_chanpara.declList.decls.add(op_seq.createChannelDecl(prodExpr));
				}
			}
		}
	}
	
	
	//8. Declaring local channels for each node in the node container
	//shall these local ones be declared in state semantics?
	for(n in self.nodes){
		if(n.instanceOf(RC!Junction)){
			var junc_chan = Sequence{"enter_"+ n.FQN(),
									 "interrupt_"+ n.FQN()}.createChannelPara("junction_channel_" + n.FQN());
		} else{
			var st_chan = Sequence{"enter_"+ n.FQN(),
								   "entered_"+ n.FQN(),
								   "interrupt_"+ n.FQN(),
								   "enteredL_"+ n.FQN(),
								   "enteredR_"+ n.FQN()}.createChannelPara("state_channel_" + n.FQN());
		}
	}
	
	
	//9. Declaring NC channelsets: enterSS, enteredSS, internal_events, shared_variable_events, sem__events
	
	//enterSS
	var enterSSchannelset = createChannelSet(createBasicChannelSetExpr(enterSS(self)));
	var enterSSchannelsetPara = enterSSchannelset.createChanSetPara("enterSS_"+self.FQN());
	
	//enteredSS
	var enteredSSchannelset = createChannelSet(createBasicChannelSetExpr(enteredSS(self)));
	var enteredSSchannelsetPara = enteredSSchannelset.createChanSetPara("enteredSS_"+self.FQN());
	
	
	//internal_events
	var internal_stringset = enterSS(self).includingAll(enteredSS(self)).includingAll(Sequence{"interrupt_"+self.FQN(), "exited_"+self.FQN()});
	var internal_events_channelset = createChannelSet(createBasicChannelSetExpr(internal_stringset));
	var internal_events_channelsetPara = internal_events_channelset.createChanSetPara("internal_events_"+self.FQN());
	
	
	//shared_variable_events
	var shared_var_events_channelset = createChannelSet(createBasicChannelSetExpr(sharedVarSet(self)));
	var shared_variable_events_channelsetPara = shared_var_events_channelset.createChanSetPara("shared_variable_events_"+self.FQN());
	
	
	//sem__events
	//terminate should not be FQN.
	var sem__events_stringset = Sequence{"terminate"};
	
	if(self.hasSharedVars()){
		sem__events_stringset = sem__events_stringset.includingAll(sharedVarSet(self));
	}
	
	for(e in self.events){				
//		sem__events_stringset.add(e.FQN() + "_in");
//		sem__events_stringset.add(e.FQN() + "_out");
		sem__events_stringset.add(e.name + "_in");
		sem__events_stringset.add(e.name + "_out");
	}
	
	
	if(self.hasRequiredOps()){
		sem__events_stringset = sem__events_stringset.includingAll(requiredOps(self));
	}	
	
	var sem__events_channelset = createChannelSet(createBasicChannelSetExpr(sem__events_stringset));
	var sem__events_channelsetPara = sem__events_channelset.createChanSetPara("sem__events_"+self.FQN());
	
	//10. Declaring State Local channelsets: enterSS_s0, enteredSS_s0, etc
	//shall these local ones be declared in state semantics?
	
}


operation RC!NodeContainer hasRequiredOps():Boolean{
		
	for(ri in self.rInterfaces){	
		if(ri.operations.size()>0){
			return true;
		}
	} 
	return false;
}


operation RC!NodeContainer hasSharedVars():Boolean{
	var hasSharedVars = false;
	
	for(ri in self.rInterfaces){
	
		for(vl in ri.variableList){
			if(vl.modifier = VariableModifier#VAR){
				hasSharedVars = true;
				return true;
			} 
		}
	} 
	return false;
}


//this is used for variable channel decleration, only TypeRef, ProductType and SeqType are considered for variable's type
operation RC!Type createTypeExpr(): Z!Expr{
	("line 1249, self = " + self).println();
	if(self.isTypeOf(ProductType)){
		return self.createProdExpr();
	} else  if(self.isTypeOf(TypeRef)){  
		return self.ref.name.createRefExpr(false, false);
	} else  if(self.isTypeOf(SeqType)){  

//		return createRefExprAsGenOpAppl("seq_",self.domain.name.asString());
		return createRefExprAsGenOpAppl("seq_",self.domain.createTypeExpr());
	}
}
  
//this is used for variable channel decleration, a RefType is generated from the name of the enumeration type, e.g., NIDS
operation String createTypeExpr(): Z!Expr{
	return self.createRefExpr(false, false);
}

operation RC!ProductType createProdExpr(): Z!ProdExpr{
	var prodexpr = new 	Z!ProdExpr;
	prodexpr.exprList = new Z!ZExprList;
 	for(t in self.types){
 		prodexpr.exprList.exprs.add(t.createTypeExpr());
 	}
 	
 	return prodexpr;
}

operation createProdExpr(exp1: Z!Expr, exp2:Z!Expr): Z!ProdExpr{
	var prodexpr = new 	Z!ProdExpr;
	prodexpr.exprList = new Z!ZExprList;
	prodexpr.exprList.exprs = Sequence{exp1,exp2};
	
 	return prodexpr;
}


//to create an empty channelPara with a para name with the decl not defined and the type not identified
operation createChannelPara(
	para_name: String
	): Z!ChannelPara{
	var chanDeclPara = new Z!ChannelPara;
	chanDeclPara.declList = new Z!ZDeclList;
	
//	var decl = Set{}.createChannelDecl();
//	chanDeclPara.declList.decls = Sequence{decl};
	
	chanDeclPara.declList.decls = Sequence{};
	chanDeclPara.name = para_name.createZName();
	
	return chanDeclPara;
}





//type indicate the type of the channel, or is sync if is untyped
operation Sequence<String> createChannelPara(
	para_name: String,
	type: String
	): Z!ChannelPara{
	var chanDeclPara = new Z!ChannelPara;
	chanDeclPara.declList = new Z!ZDeclList;
	
	var decl = self.createChannelDecl(type);
	chanDeclPara.declList.decls = Sequence{};
	chanDeclPara.declList.decls.add(decl);

	chanDeclPara.name = para_name.createZName();
	
	return chanDeclPara;
}

operation Sequence<String> createChannelPara(
	para_name: String
	): Z!ChannelPara{
	var chanDeclPara = new Z!ChannelPara;
	
	chanDeclPara.declList = new Z!ZDeclList;
	
	var decl = self.createChannelDecl();
	chanDeclPara.declList.decls = Sequence{decl};
		
	chanDeclPara.name = para_name.createZName();
	return chanDeclPara;
}


operation Sequence<String> createChannelDecl(): Z!ChannelDecl{
	var decl = new 	Z!ChannelDecl;
	
	//The first element is the (possibly empty) list of generic formal parameters
//	var fst_list = createNameList(Set{});
	decl.genFormals = createNameList(Sequence{});
	
	//the second element is the (possibly empty) list of declared channel names
//	var snd_list = createNameList(self);
	decl.channelNameList = createNameList(self);
	
	//expr attr indicate the type of the channel, and it's a RefExpr
	//if it's untyped, type = "SYNCH"
	if(self.size()>0){
		decl.expr = "SYNCH".createRefExpr(false, false);
	} else{
		//self.size() = 0 means this is an empty channel decl, so no type is identified.
	}
	
	
	return decl;
}


operation Sequence<String> createChannelDecl(type: String): Z!ChannelDecl{
	var decl = new 	Z!ChannelDecl;
	
	//The first element genFormals is the (possibly empty) list of generic formal parameters
	decl.genFormals = createNameList(Sequence{});
	
	//the second element is the (possibly empty) list of declared channel names
	decl.channelNameList = createNameList(self);

	//expr attr indicate the type of the channel, and it's a RefExpr
	//if it's untyped, type = "SYNCH"
	decl.expr = type.createRefExpr(false, false);
	
	return decl;
}

operation Sequence<String> createChannelDecl(type_expr: Z!Expr): Z!ChannelDecl{
	var decl = new 	Z!ChannelDecl;
	
	//The first element genFormals is the (possibly empty) list of generic formal parameters
	decl.genFormals = createNameList(Sequence{});
	
	//the second element is the (possibly empty) list of declared channel names
	decl.channelNameList = createNameList(self);

	//expr attr indicate the type of the channel, and it's a RefExpr
	//if it's untyped, type = "SYNCH"
	decl.expr = type_expr;
	
	return decl;
}



operation createCallOps(nc: RC!NodeContainer){
	for(ri in nc.rInterfaces){
		for(op in ri.operations){
			createCallOpActionPara(op);
		}
	}
}


/* Operation call RoboChart e.g.,
CALL__move1(id__,
			const_pkg0_M_C1_stm0_c2,
			const_pkg0_M_C1_stm0_c1,
			param_m,
			param_m1) 	= move1Call.param_m.param_m1 -> SKIP  */
operation createCallOpActionPara(op: RC!OperationSig): Z!ActionPara{
//	var action;
	if(op.parameters.size() = 0){
		var commu = createSynchCommunication(op.name + "Call");
		var action = createPrefixingAction(commu, createSkipAction());
		var actionPara = action.createActionPara(op.name + "Call");//TBC the FQN for stm opcall and ctrl opcall
		return actionPara;
	} else
	if(op.parameters.size()>0){
		
		var commu = new Z!Communication;
		commu.commUsage = Z!CommUsage#Normal;
		commu.indexed = false;
		commu.multiSych = 0;
		commu.channelExpr = (op.name + "Call").createRefExpr(false,false);
	
		commu.fieldList = new Z!CircusFieldList; 
					
		commu.commPattern = Z!CommPattern#Mixed;	
		for(p in op.parameters){
			var field = new Z!DotField;
			field.expr = ("param_" + p.name).createRefExpr(false,false);
			field.outputField = false;
			commu.fieldList.fields.add(field);
		}
		
		var action = new Z!ParamAction;
		action.isParamCommand = false;
		action.declList = new Z!ZDeclList;
		for(p in op.parameters){
			action.declList.decls.add(createVarDecl(p));
		}
		
		action.circusAction = createPrefixingAction(commu, createSkipAction());
		 
//		return action;
		var actionPara = action.createActionPara(op.name + "Call");//TBC the FQN for stm opcall and ctrl opcall
	 	return actionPara;
	}
	
//	var actionPara = action.createActionPara(op.name + "Call" +self.FQN());

	
}

operation createDotInputCommunication(
	chan_name: String,
	dot_para:String,
	input_var: String
	): Z!Communication{
	
	var commu = new Z!Communication;

	commu.commUsage = Z!CommUsage#Normal;
	commu.indexed = false;
	commu.multiSych = 0;
	commu.channelExpr = chan_name.createRefExpr(false,false);

	commu.fieldList = new Z!CircusFieldList; 
		
	
	commu.commPattern = Z!CommPattern#Mixed;		
	var field1 = new Z!DotField;
	field1.expr = dot_para.createRefExpr(false,false);
	field1.outputField = false;
	
	
	var field2 = new Z!InputField;
	field2.varialbeName = input_var.createZName();
	
	commu.fieldList.fields = Sequence{field1,field2};
	
	return commu;
}


//CSP Rule 40

operation ncBehaviour(nc:RC!NodeContainer): Z!ActionPara{
	nc.createchanParaNC(); // HERE is to declare all the channels for a state machine
	var hideset_string = enterSS(nc).includingAll(Sequence{"exit_" + nc.FQN(), "exited_" + nc.FQN(), "internal__"+nc.FQN()});
	
//	var hidechannelset = createChannelSet(createBasicChannelSetExpr(hideset_string));
//	var hidechannelsetPara = hidechannelset.createChanSetPara("ncCoreBeh_hideset_"+nc.FQN());
//	var ncBehaviourProc = ncCoreBehaviour(nc).createHideProcess(hideset_string).createRenameProcess(renameTriggerEventsPairL(nc), renameTriggerEventsPairR(nc));


	var ncBehaviour = ncCoreBehaviour(nc).name.word.createCallAction().createHideAction(hideset_string).createRenameAction(renameTriggerEventsPairL(nc), renameTriggerEventsPairR(nc));
	//TO DO: need to confirm the M2T part
	

//	var ncBehaviourProcPara =  ncBehaviourProc.createProcessPara("ncBehaviourProc_"+nc.FQN(), false);

	return ncBehaviour.createActionPara("ncBehaviour_"+ nc.FQN());
}





//CSP Rule 41
operation ncCoreBehaviour(nc: RC!NodeContainer): Z!ActionPara{

	
	/***************start of tidsR(nc) calculation************************/
	
	//tidsR(nc) renaming is implemented as transitions renaming and nodes renaming 
	//firstly, to calculate the renaming pair for the transitions
	var tidsR_trans_pairL = new Sequence<String>;
	for(t in nc.transitions){
		tidsR_trans_pairL.add("interrupt_" + t.source.FQN());
	}
	var tidsR_trans_pairR = new Sequence<String>;
	for(t in nc.transitions){
//		tidsR_trans_pairR.add(tevent(t,nc.name));
		tidsR_trans_pairR.add(tevent_str(t));
	} 
	

	//Secondly, to calculate the renaming pair for the nodes
	var tidsR_nodes_pairL = new Sequence<String>; 
	for(n in nc.nodes.select(m|m.instanceOf(State))){
		tidsR_nodes_pairL.add("interrupt_" + n.FQN());
	}
	var tidsR_nodes_pairR = new Sequence<String>;
	for(n in nc.nodes.select(m|m.instanceOf(State))){
		tidsR_nodes_pairR.add("interrupt_" + nc.FQN());
	}
	

	//to combine the two sets of pair
	var tidsR_pairL = tidsR_trans_pairL.includingAll(tidsR_nodes_pairL);
	var tidsR_pairR = tidsR_trans_pairR.includingAll(tidsR_nodes_pairR);
	
	/***************end of tidsR(nc)************************/
	
	
	
	//Rename composeNodes(nc.nodes) with tidsR(nc)
	var composedNodeActionTidsRenamed = composeNodes(nc.nodes).name.word.createCallAction().createRenameAction(tidsR_pairL, tidsR_pairR);

	
	//create transition action: Q
	var transActionPara = nc.createTransitionsAsActionPara();
	
	var initial_name = nc.nodes.selectOne(n|n.instanceOf(Initial)).FQN();

	var commu = createSynchCommunication("enter_" + initial_name);
	
	var prefixAction = createPrefixingAction(commu, transActionPara.name.word.createCallAction());
	
//	//a action paragraph is created for transAction because transAction is defined standalone in auto-gen CSPM 
//	var transProcPara = transProc.createProcessPara("trans_proc_" + nc.FQN(), true);
	
	
	//this step creates the string set, but not a channelset, because this can SIMPLIFY the coding. 
	//we will generate a channelset after all channels are collected (by union) for the channelset
	var cs_stringset = flowevts(nc).includingAll(transSync(nc));
	cs_stringset.add("terminate");
	("line903: cs_stringset.type = " +cs_stringset).println();
	
	
	/***************begin of C.2.2 metanotatin************************/
	
	var ncCoreBehaviour = createMetaParallelAction(nc, 
												  composedNodeActionTidsRenamed, 
												  vars(nc.nodes), 
												  vars(nc.nodes), 
												  cs_stringset, 
												  vtguards(nc), 
												  Set{}, 
												  prefixAction
												  );
	/***************end of C.2.2 metanotatin************************/
	
	
	return ncCoreBehaviour.createActionPara("ncCoreBehaviour_"+ nc.FQN());
}

//used inCSP Rule 41 - operation ncCoreBehaviour  
operation vtguards(nc: RC!NodeContainer):  Set<String>{
	var varset = new Set<String>;
	varset = Set{};
	for(t in nc.transitions){
		varset = varset.includingAll(usedVariablesInExpr(t.condition,nc));
	}
	return varset;
}

	
//CSP Rule 46
operation vars(nodeset:Set<RC!Node>): Set<String>{
	"Rule 46 is called".println();
	var varset = Set<String>;
	varset = Set{};

	for(n in nodeset){
		varset = varset.includingAll(vars(n));
	}
	return varset;
}


//CSP Rule 47
operation vars(ts: Set<RC!Transition>):Set<String>{
	"Rule 47 is called".println();
	var varset = Set<String>;
	for(t in ts){
		varset = varset.includingAll(vars(t));//Rule 49
	}
	return varset;
}


//CSP Rule 48
operation vars(node: RC!Node):Set<String>{
	"Rule 48 is called".println();
	var varset = Set<String>;
	varset = Set{};
	if(node.instanceOf(RC!State)){
		for(a in node.actions){
			varset = varset.includingAll(vars(a.action));//Rule 50
		}
		"line 285".println();
		varset = varset.includingAll(vars(node.nodes))//Rule 46
				       .includingAll(vars(node.transitions));//Rule 47
	} else{
		varset = Set{};
	}
	return varset;
}

//CSP Rule 49
operation vars(t: RC!Transition):Set<String>{
	"Rule 49 is called".println();
	var varset = Set<String>;
	if(t.condition.isDefined()){
		varset = varset.includingAll(vars(t.condition));//Rule 50
	}
	if(t.action.isDefined()){
		varset = varset.includingAll(vars(t.action));//Rule 50
	}
	if(t.deadline.isDefined()){
		varset = varset.includingAll(vars(t.deadline));
	}
	
	return varset;
}

//CSP Rule 50
operation vars(stmt: RC!Statement):Set<String>{
	var varset = Set<String>;
	varset = Set{};
	
	if(stmt.instanceOf(RC!Assignment)){
//		varset = usedVariables(stmt.left).includingAll(usedVariables(stmt.right));
//		THIS line above nc(stmt.left.name) is commented out, because usedVariables (Rule 45) does not cover VarRef, a subclass of Assignable
		
		varset = Set{stmt.left.name.name }.includingAll(usedVariablesInExpr(stmt.right, nc(stmt)));
		//stmt.left is an Assignable, stmt.left.name is a Variable
		//nc(stmt.left.name) returns the basiccontext that defines this variable
		// we use the nc(stmt) as scope or nc(stmt.left.name) as scope? e.g., in module stm0, var is a local and to be renamed using EXT
		//TO be checked
		
		//TO DO: to confirm: "stmt.left.name.name" works for one var name, but is there stmt.left has multiple names?
		
	} else
	
	if(stmt.instanceOf(RC!Call)){
		for(arg in stmt.args){
			varset = usedVariablesInExpr(arg, nc(stmt));
		}
		varset = varset.includingAll(requiredVariables(stmt.`operation`));
	} else
	
	if(stmt.instanceOf(RC!IfStmt)){
		varset = usedVariablesInExpr(stmt.expression, nc(stmt)).includingAll(vars(stmt.then)).includingAll(vars(stmt.`else`));
	} else
	
	if(stmt.instanceOf(RC!CommunicationStmt) and (stmt.communication._type=CommunicationType#SYNC or stmt.communication._type=CommunicationType#OUTPUT)){
		varset = usedVariablesInExpr(stmt.communication.value, nc(stmt));
	} else
	//CSP Rule 50 does not consider INPUT, should raise an issue in github
	if(stmt.instanceOf(RC!CommunicationStmt) and (stmt.communication._type=CommunicationType#INPUT)){
//		var para_str = stmt.communication.parameter.name + "_" + nc(stmt.communication.parameter).FQN();
//		var para_str = stmt.communication.parameter.name + "_" + nc(stmt).FQN();
		var para_str = stmt.communication.parameter.name;
		//parameter is a Variable
		//SAME HERE: TODO: TBC: shall we use the nc(stmt) as scope or nc(stmt.left.name) as scope? e.g., in module stm0, var is a local and to be renamed using EXT
		//the var may be declared one level above. TO be checked
		varset = Set{para_str};
	} else
	
	if(stmt.instanceOf(RC!ParStmt)){
		varset = vars(stmt.stmt);
	} else
	
	if(stmt.instanceOf(RC!SeqStatement)){
		varset = vars(stmt.statements);
	} else
	
	if(stmt.instanceOf(RC!TimedStatement)){
		varset = vars(stmt.stmt).includingAll(vars(stmt.deadline));
	}
		
	return varset;
}


//used in CSP Rule 50
operation requiredVariables(op: RC!OperationSig): Set<String>{
	var varset = new Set<String>;
	varset = Set{};
	for(p in op.parameters){
		varset.add(p.name);
	}
	
	return varset;
}



//CSP Rule 51
operation vars(seq: Sequence<RC!Statement>):Set<String>{

	var varset = Set<String>;
	for(stmt in seq){
		varset = varset.includingAll(vars(stmt));
	}

	return varset;
}

//CSP C.2.2 metanotation
operation createMetaParallelAction(
	nc: RC!NodeContainer, 
	P: Z!CircusAction, 
	pr: Set<String>, 
	pw: Set<String>, 
	cs: Set<String>, 
	qr: Set<String>, 
	qw: Set<String>, 
	Q: Z!CircusAction
	): Z!CircusAction{


	
	//step 1 - rename P: (1) create assigementpairs, (2) rename P 

	
	//share <-- share
	var PRenaming_pairR = Sequence{"share"};
	var PRenaming_pairL = Sequence{"share"};
	
	//share <-- setR(v)
	var pr_qw = intersect(pr,qw);
	("line 1488 pr = " + pr).println();
	("line 1489 qw = " + qw).println();
	("line 1488 pr_qw = " + pr_qw).println();
	
	for(v in pr_qw){//because qw is empty, this for loop never happens
		PRenaming_pairR.add("share");
		PRenaming_pairL.add("setR_"+v);//R207 setR(v)
	}
	
	//set(v) <-- setL(v)
	var pw_qr = intersect(pw,qr);
	for(v in pw_qr){
		PRenaming_pairR.add("set_"+v);//Rule 201
		PRenaming_pairL.add("setL_"+v);//R204 setL(v)
		
		//TO confirm 
		//IF this is the place to give variable a FQN, the benefit of not FQN in operations vars is the vars are simplified in this way, i.e., we don't need to add .FQN() for each vars
		//the drawback is that we need to be careful to not omit any places that needs FQN
	}
	
	var PRenamed = P.createRenameAction(PRenaming_pairR, PRenaming_pairL);
	/****************************************************************
	TO DO, this renaming above is WRONG, as it should be RELATIONAL renaming
	e.g.,  [[ share__ <- x__ | x__ <- {| share__,setR_a,setR_a1 |} ]] 
	It means share becomes three channels
	Thus, P = share -> P becomes
	Q = share -> Q or setR_a -> Q or setR_a1 -> Q
	
	***************************************************************************/
	
	

	//step 2 - rename Q: (1) create assigementpairs, (2) rename Q
				
	//share <-- share
	var QRenaming_pairR = Sequence{"share"};
	var QRenaming_pairL = Sequence{"share"};
	
	//share <-- setL(v)
	var qr_pw = intersect(qr,pw);
	for(v in qr_pw){
		QRenaming_pairR.add("share");
		QRenaming_pairL.add("setL_"+v);//R204 setL(v)
	}
	
	//set(v) <-- setR(v)
	var qw_pr = intersect(pw,qr);
	for(v in qw_pr){//because qw is empty, this for loop never happens
		PRenaming_pairR.add("set_"+v);//Rule 201
		PRenaming_pairL.add("setR_"+v);//R207 setR(v)
	}
	
	var QRenamed = Q.createRenameAction(QRenaming_pairR, QRenaming_pairL);
	
	
	//step 3 - create parallel process: (1) define channel set 

	
	var channel_names = cs.includingAll(setLC(intersect(pw,qr))).includingAll(setRC(intersect(qw,pr)));
	channel_names.add("share");
	("line 1708, channel_names = " + channel_names).println();
	//TO DO, each channel in channelset_stringSet needs to be declared as a channel.
	//channelset_stringSet.createChannel();
	
//	var channelset = createChannelSet(createBasicChannelSetExpr(channel_names)).createChanSetPara("parallel_chanset_ncCoreBeh_" + nc.FQN());
	//this channelset is the one in CSPM: [| union(union(union(flowevts,transSync),{terminate}),{|share__,setL_a,setR_a|}) |]
	
	//step 4 - create parallel process	P{|channelset|}Q
	
	var PparQ = createParallelAction(channel_names, PRenamed, QRenamed);
//	var PparQ = createParallelAction("parallel_chanset_ncCoreBeh_" + nc.FQN(), PRenamed,QRenamed);
	
	//step 5 - rename parallel process: (1) create assigementpairs, (2) rename P{|channelset|}Q
	
	var PQRenaming_pairR = new Sequence<String>;
	var PQRenaming_pairL = new Sequence<String>;
	if(pr_qw.size()>0 or qr_pw.size()>0){
		
		for(v in pr_qw){//because qw is empty, this for loop never happens
			PQRenaming_pairR.add("setR_"+v);
			PQRenaming_pairL.add("set_"+v);
		}
		for(v in qr_pw){
			PQRenaming_pairR.add("setL_"+v);
			PQRenaming_pairL.add("set_"+v);
		}
		
		var PparQRenamed = PparQ.createRenameAction(PQRenaming_pairR, PQRenaming_pairL);
		
		return PparQRenamed;
	} else {
		return PparQ;
	}
}


//used in  C.2.2 metanotation's operation "createMetaParallelAction"
operation intersect(
	setA: Set<Any>, 
	setB: Set<Any>
	): Set<Any>{
	var intersection = new Set<Any>;
	for (elementA in setA) {
        if (setB.includes(elementA)) {
            intersection.add(elementA);
        }
    }
	return intersection;	
}

//used in CSP Rule 41
//this creates the string set, but not a channelset, because this can SIMPLIFY the coding. 
//we will generate a channelset after all channels are collected (by union) for the channelset
operation flowevts(nc: RC!NodeContainer): Set<String>{
	var flowevts = enterSS(nc).
				   includingAll(Set{"exit_"+nc.FQN(),
				   					"exited_"+nc.FQN(),
				   					"interrupt_"+nc.FQN()}
				   				).asSet();
	return flowevts;
}


//used in CSP Rule 40 and operation flowevts
//this creates the string set, but not a channelset, because this can SIMPLIFY the coding. 
//we will generate a channelset after all channels are collected (by union) for the channelset
operation enterSS(nc: RC!NodeContainer): Sequence<String>{
	var seq = new Sequence<String>;
	for(n in nc.nodes){
//		set.add(nc.name+"."+n.name+"::enter"); //stm0.i0::enter ?
		seq.add("enter_" + n.FQN()); 
	}
	return seq;
}

operation enteredSS(nc: RC!NodeContainer): Sequence<String>{
	var seq = new Sequence<String>;
	for(n in nc.nodes.select(m|m.instanceOf(RC!State))){
		seq.add("entered_" + n.FQN()); 
	}
	return seq;
}


operation sharedVarSet(nc: RC!NodeContainer): Sequence<String>{
	var seq = new Sequence<String>;
	for(ri in nc.rInterfaces){
		for(vl in ri.variableList.select(l|l.modifier = VariableModifier#VAR)){
			for(v in vl.vars){
				seq.add("set_EXT_" + v.name); 
			}
		}
	}
	return seq;
}

operation requiredOps(nc: RC!NodeContainer): Sequence<String>{
	var seq = new Sequence<String>;
	for(ri in nc.rInterfaces){
		for(op in ri.operations){
			seq.add(op.name + "Call"); 
		}
	}
	return seq;
}


//used in Rule 41
operation transSync(nc: RC!NodeContainer): Set<String>{
	var set = new Set<String>;
	for(t in nc.transitions){
		set.add(tevent_str(t));
	}
	return set;
}


//CSP Rule 206, used in C.2.2 (Rule 41)
operation setLC(nameset: Set<String>):Set<String>{
	var set = new Set<String>;
	for(n in nameset){
		set.add("setL_"+n);
	}
	return set;
}

//CSP Rule 209, used in C.2.2 (Rule 41)
operation setRC(nameset: Set<String>):Set<String>{
	var set = new Set<String>;
	for(n in nameset){
		set.add("setR_"+n);
	}
	return set;
}


//CSPM example:
/****************************
[[ stop__.x____ 	<- stop,
   trigger1__.x____ <- trigger1,
   event1__.x____ 	<- event1
   | x____ <- NIDS
]]
*******************************/
//CSP Rule 42 - part1, used in Rule 40
//by 5th June 2024, this operation is only used in Rule 40
//and this is the only place involving "event1__.x____ <- event1 | x____ <- NIDS"
//in Isabelle, we use "event1_stm0_pkg0__in\<cdot>x" to represent the above
operation renameTriggerEventsPairL(nc:RC!NodeContainer): Sequence<String>{
	var pairL = new Sequence<String>;
	
	for(t in nc.transitions.select(l|l.trigger.isDefined())){
		
		pairL.add(t.trigger.event.name +"__in" +"\\<cdot>x" );
//		pairL.add(t.trigger.event.FQN()+"__in" +"\\<cdot>x" );
		//in Isabelle, event1\<cdot>x means the set of events that take all values of the first type of event1  when the tirgger's type is a product.
		//what about the case the trigger's type is not a product, but only NIDS?
		//TBC
		
		
	}
	return pairL;
}

//CSP Rule 42 - part2
operation renameTriggerEventsPairR(nc:RC!NodeContainer): Sequence<String>{
	var pairR = new Sequence<String>;
	for(t in nc.transitions.select(l|l.trigger.isDefined())){
//		pairR.add(t.trigger.event.FQN()+"_in");
		pairR.add(t.trigger.event.name +"_in");
	}
	return pairR;
}


//This operation is not used yet
//channelset is declared, and is referred here as a name (RefExp)
operation Z!CircusProcess createHideProcess(
	cs_name: String//, 
//	nc: RC!NodeContainer
	):Z!HideProcess{
	"line 608 createHideProcess is called".println();
	var hideProc = new Z!HideProcess;
	hideProc.channelSet =  createChannelSet(cs_name.createRefExpr(false,false));
	
	hideProc.circusProcess = self;
	hideProc.type().println();
 	return hideProc;
}

//channelset is not declared, and is declared within hideProcess, but has no name (BasicChannelSetExpr)
operation Z!CircusProcess createHideProcess(
	channel_names: Sequence<String>//, 
//	nc: RC!NodeContainer
	):Z!HideProcess{

	"line 622 createHideProcess is called".println();
	var hideProc = new Z!HideProcess;
	hideProc.channelSet = createChannelSet(createBasicChannelSetExpr(channel_names));
	
	hideProc.circusProcess = self;
 	return hideProc;
}

//channelset is not declared, and is declared within hideAction, but has no name (BasicChannelSetExpr)
operation Z!CircusAction createHideAction(
	channel_names: Sequence<String>
	):Z!HideAction{

	var hideAction = new Z!HideAction;
	hideAction.channelSet = createChannelSet(createBasicChannelSetExpr(channel_names));
	
	hideAction.circusAction = self;
 	return hideAction;
}

operation Z!CircusAction createHideAction(
	cs_name: String
	):Z!HideAction{

	var hideAction = new Z!HideAction;
	hideAction.channelSet =  createChannelSet(cs_name.createRefExpr(false,false));
	
	hideAction.circusAction = self;
 	return hideAction;
}

//the parameter is a channelset instead of string set
operation Z!CircusProcess createHideProcess(
	cs: Z!CircusChannelSet
	):Z!HideProcess{

	var hideProc = new Z!HideProcess;

	hideProc.channelSet = cs;
	hideProc.circusProcess = self;
 	return hideProc;
}


operation Z!CircusAction createRenameAction(
	nameSetL: Sequence<String>, 
	nameSetR: Sequence<String>
	): Z!RenameAction{
	var action = new Z!RenameAction;
	action.circusAction = self;
	action.assignmentPairs = createAssignmentPairs(nameSetL, nameSetR);
	
	return action;
}

operation Z!CircusProcess createRenameProcess(
	nameSetL: Sequence<String>, 
	nameSetR: Sequence<String>
	): Z!RenameProcess{
	var proc = new Z!RenameProcess;
	proc.circusProcess = self;
	proc.assignmentPairs = createAssignmentPairs(nameSetL, nameSetR);
	
	return proc;
}

//this is not directly used, but in createRenameProcess
operation createAssignmentPairs(
	nameSetL: Sequence<String>, 
	nameSetR: Sequence<String>
	): Z!AssignmentPairs{
	var pairs = new Z!AssignmentPairs;
	var lhs = new Z!ZNameList;
	var rhs = new Z!ZExprList;
	
	for(sname in nameSetL){
		lhs.names.add(sname.createZName());
	}
	pairs.lhsElement = lhs;
	
	for(tname in nameSetR){
		rhs.exprs.add(tname.createRefExpr(false,false));
	}
	pairs.rhsElement = rhs;
	
	return pairs;
}

//was used in R41 tidsR(nc), now replaced by the below updated version (the parameter 'context' was removed)
/*
//this version makes the FQN locally instead of using FQN
operation tevent(t: RC!Transition, context: String): String{
 	
 	var tevent_string;
 	
	if(t.trigger = null){
		tevent_string = "internal." + context +"." + t.source.name;
	} 
	
	else {
		tevent_string = t.trigger.event.name + "__." + context+"." + t.source.name + "_in";
	}
	
	return tevent_string;
}
*/

// CSP Rule 43 variation
// used in R41 tidsR(nc) 
operation tevent_str(t: RC!Transition): String{
 	
 	var tevent_string;
 	
	if(t.trigger = null){
		tevent_string = "internal__" + nc(t).FQN()  + ".NID_" + t.source.FQN();
		tevent_string = "internal__" + nc(t).FQN()  + "\\<cdot>NID_" + t.source.FQN();
	} 
	
	else {
//		tevent_string = t.trigger.event.FQN() + "__in.NID_" + t.source.FQN();
//		tevent_string = t.trigger.event.name + "__in.NID_" + t.source.FQN();
		tevent_string = t.trigger.event.name + "__in\\<cdot>NID_" + t.source.FQN();
	}
	
	return tevent_string;
}

//CSP Rule 43 variation
//TO DO: to confirm the Z type, shall trigger event be both a channel AND a communication?
//this version returns Communication
operation tevent(t: RC!Transition): Z!Communication{
 	"line 1397, tevent to return communication is called".println();
 	var chan_name;
 	var para_name = "NID_" + t.source.FQN();//TBC
	var commu;
	if(t.trigger = null){
		chan_name = "internal__" + nc(t).FQN();
		commu = createOutputCommunicationFromString(chan_name, para_name, "SYNC");
	} 
	
	else {
		chan_name = t.trigger.event.name + "__in";
//		chan_name = t.trigger.event.FQN() + "__in";
		commu = createOutputCommunicationFromString(chan_name, para_name, "SYNC");
	}
	("line 1814, commu.chan = " + commu.channelExpr.name.word.asString()).println();
	("line 1815, commu.expr = " + commu.fieldList.fields.at(0).expr.name.word.asString()).println();
	
	return commu;
}


//to obtain the nodecontainer that contains the transition t
operation nc(t: RC!Transition): RC!NodeContainer{
	for(nc in RC!NodeContainer.all()){
		if(nc.transitions.includes(t)){
			return nc;
		}
	}
}

//operation nc(nd: RC!Node): RC!NodeContainer{
//	for(nc in RC!NodeContainer.all()){
//		if(nc.nodes.includes(nd)){
//			return nc;
//		}
//	}
//}
operation nc(nd: RC!Node): RC!NodeContainer{
	("line 1933, nd"+ nd).println();
	("line 1933, nd.eContainer()"+ nd.eContainer()).println();
	return nd.eContainer();
}



//CSP Rule 44
operation usedVariables(stmt:RC!Statement):Set<String>{
	var varSet = new Set<String>;
	var container = nc(stmt);//this is to be passed to Rule 45, so that the variable name can be fully qualified with container's name, but not the component that declares the var
	
	if(stmt.instanceOf(RC!Assignment)){
		varSet = usedVariablesInExpr(stmt.right,container);
	} else
	if(stmt.instanceOf(RC!Call)){
		for(arg in stmt.args){
			varSet = varSet.includingAll(usedVariablesInExpr(arg,container));
		}
	} else
	//stmt.then and stmt.else are handled in the IfStmt incontext semantics
	if(stmt.instanceOf(RC!IfStmt)){
		varSet = usedVariablesInExpr(stmt.expression,container);
	} else
	if(stmt.instanceOf(RC!CommunicationStmt) and (stmt.communication._type=CommunicationType#SYNC or stmt.communication._type=CommunicationType#OUTPUT)){
		varSet = usedVariablesInExpr(stmt.communication.value,container);
	} else
//	if(stmt.instanceOf(RC!SeqStatement)){
//		for(s in stmt.statements){
//			varSet = varSet.includingAll(usedVariables(s));
//		}
//	} else
//	if(stmt.instanceOf(RC!ParStmt)){
//		varSet = usedVariables(stmt.stmt);
//	} else
	if(stmt.instanceOf(RC!TimedStatement)){
		varSet = usedVariables(stmt.stmt).includingAll(usedVariables(stmt.deadline));
	} else
	{//SeqStatement falls in this case
	}
	
	return varSet;
}



//used in operation usedVariables(stmt:RC!Statement)
//TO DO: this is not a complete implementation because of lamda expr
//TO BE FIXED LATER for LAMDA
//as the lamda expression is not well considered.
//the local variable in lamda expr should not be considered in this function
//CSP Rule 45
operation usedVariablesInExpr(expr:RC!Expression, container: Any): Set<String>{
	var set = new Set<String>;
	if(expr = null
	 //when expr is concreate value (int, float, string, boolean, ect.), as these do not fall into any if case, therefore, set = {}
	 //or expr.instanceOf(IntegerExp) or expr.instanceOf(FloatExp) or expr.instanceOf(StringExp) or expr.instanceOf(BooleanExp)
	 ){
	} else
	if(expr.instanceOf(RefExp)){
		var value = expr.ref;
		if(value.instanceOf(RC!Variable) and value.modifier= VariableModifier#VAR){
			set.add(value.name );
			//here we tried to use operation nc() to return the basiccontext that defines this variable
			//However, the var may be declared in another component
			//therefore we do not need to pass the parameter 'container' to the usedVariables operaiton as below
//			set.add(value.name + "_" + container.FQN());
		}

	} else
	{
		"line814".println();
		 expr.eContents.println();
		 "line816".println();
		for(obj in expr.eContents){
			if(obj.instanceOf(RC!Expression)){
//				set = set.includingAll(usedVariables(obj));
				set = set.includingAll(usedVariablesInExpr(obj,container));
			}
		}
		
	}
	
	return set;
}



//CSP Rule 52
operation composeNodes(nodes: Set<Node>): Z!ActionPara{
	
//	var procForComposeNodes;
	var composeNodesAction;
	if(nodes.size()=0){//SStop /\ terminate -> Skip, this is an action
		composeNodesAction = createAction2("InterruptAction", "SSTOP".createCallAction(), createPrefixingAction(createSynchCommunication("terminate"), createSkipAction()));
		return composeNodesAction.createActionPara("composeNodes");
//		var actionParaSeq = new Sequence<Z!ActionPara>;
//		actionParaSeq = Sequence{action.createActionPara("action")};
//		procForComposeNodes = actionParaSeq.createBasicProcess("action");
	}else{
		
//		var ndProcSet = new Set<CircusProcess>;
//		var ndProcNameSet = new Set<String>;
	
		
		for(nd in nodes){
//			var proc_name = "node_proc_" + nd.FQN();
			if(nd.instanceOf(Junction)){
				
//				nd.createJunctionAsBasicProcess().createProcessPara(proc_name, true);
				nd.createJunctionAsActionParas();
//				ndProcNameSet.add(proc_name);
				

			} else
			if(nd.instanceOf(Final)){
				nd.createFinalAsActionParas();
//				nd.createFinalAsBasicProcess().createProcessPara(proc_name, true);
//				ndProcNameSet.add(proc_name);
//				ndProcSet.add(nd.createFinalAsBasicProcess());
			} else
			if(nd.instanceOf(State)){
				if(nd.nodes.size()=0){
					nd.createSimpleStateAsActionParas();
//					nd.createSimpleStateAsBasicProcess().createProcessPara(proc_name, true);
//					ndProcNameSet.add(proc_name);
//					ndProcSet.add(nd.createSimpleStateAsBasicProcess());
				} else{
					nd.createCompositeStateAsActionParas();
					//ndProcSet.add(nd.createCompositeStateAsBasicProcess()); 
				}
				
			}
		}
		
//		//to create channelset as a channel set paragraph	
//		var cs = createChannelSet(createBasicChannelSetExpr(Set{"share", "terminate"})).createChanSetPara("cs");
		
		if(nodes.size()<2){
			throw "There are less than 2 nodes, so the parallel process can not be composed.";
		} else{
			var ndActionNameSet = getNodeActionNameSet(nodes);
			//we can directly use the node process ndProcSet.at(0),ndProcSet.at(1) to create parallel process directly, but to be consistent with the auto-gen CSPM, we use callProcess here
//			procForComposeNodes = createParallelProcess(Set{"share", "terminate"}, ndProcNameSet.at(0).createCallProcess(),ndProcNameSet.at(1).createCallProcess());
//			ndProcNameSet.removeAt(0);
//			ndProcNameSet.removeAt(0);
			
			composeNodesAction = createParallelAction(Set{"share", "terminate"}, ndActionNameSet.at(0).createCallAction(),ndActionNameSet.at(1).createCallAction());
			ndActionNameSet.removeAt(0);
			ndActionNameSet.removeAt(0);		
			while(ndActionNameSet.size()>0){

				composeNodesAction = createParallelAction(Set{"share", "terminate"}, composeNodesAction,ndActionNameSet.at(0).createCallAction());			
				ndActionNameSet.removeAt(0);
			}

		}
		
		return composeNodesAction.createActionPara("composeNodes");
	}
		
}


operation getNodeActionNameSet(nodes: Set<RC!Node>): Set<String>{
	var nameSet = new Set<String>;
	for(nd in nodes){
		nameSet.add("Inactive_"+nd.FQN());
	}
	return nameSet;
}

operation String createCallProcess(): Z!CallProcess{
	var proc = new Z!CallProcess;
	proc.callExpr = self.createRefExpr(false,false);
	proc.callUsage = Z!CallUsage#Parameterised;
	
	return proc;
}

operation Z!ZName createCallProcess(): Z!CallProcess{
	var proc = new Z!CallProcess;
	proc.callExpr = self.word.createRefExpr(false,false);
	proc.callUsage = Z!CallUsage#Parameterised;
	
	return proc;
}


//BasicProcss is formed by a (possibly empty) set of process paragraphs, an optional process state given as a schema and a mandatory main action definition.
//so isBasicProc = true if it is a BasicProcss
operation Z!CircusProcess createProcessPara(name: String, isBasicProc: Boolean): Z!ProcessPara{
	var para = new Z!ProcessPara;
	para.name = name.createZName();
	para.circusProcess = self;
	para.isBasicProcess = isBasicProc;
	
	return para;
}


//channelset is a reference to a channelset name, therefore it is an RefExpr
operation createParallelAction(
	cs_name: String, 
	left: Z!CircusAction, 
	right: Z!CircusAction
	):Z!ParallelAction{
	
	var action = new Z!ParallelAction;
	action.channelSet = createChannelSet(cs_name.createRefExpr(false,false));
	action.leftAction = left;
	action.rightAction = right;
	
	action.leftNameSet = createNameSet(Set{});//the name set is empty
	action.rightNameSet = createNameSet(Set{});
	
	return action;
}


//channelset is declared in the process directly using the channel names, so has no channelset name
//therefore it is an BasicChannelSetExpr
operation createParallelAction(
	channel_names: Set<String>, 
	left: Z!CircusAction, 
	right: Z!CircusAction
	):Z!ParallelAction{
	
	var action = new Z!ParallelAction;
	action.channelSet = createChannelSet(createBasicChannelSetExpr(channel_names));
	action.leftAction = left;
	action.rightAction = right;
	
	action.leftNameSet = createNameSet(Set{});//the name set is empty
	action.rightNameSet = createNameSet(Set{});
	
	return action;
}


operation createNameSet(names: Set<String>): Z!CircusNameSet{
	var nameSet = new Z!CircusNameSet;
	nameSet.expr = names.createSetExpr();
	
	return nameSet;
}


//channelset is a reference to a channelset name, therefore it is an RefExpr
operation createParallelProcess(
	cs_name: String, 
	left: Z!CircusProcess, 
	right: Z!CircusProcess
	):Z!ParallelProcess{
	
	var proc = new Z!ParallelProcess;
	proc.channelSet = createChannelSet(cs_name.createRefExpr(false,false));
	proc.leftProcess = left;
	proc.rightProcess = right;
	
	return proc;
}

//channelset is declared in the process directly using the channel names, so has no channelset name
//therefore it is an BasicChannelSetExpr
operation createParallelProcess(
	channel_names: Set<String>, 
	left: Z!CircusProcess, 
	right: Z!CircusProcess
	):Z!ParallelProcess{
	
	var proc = new Z!ParallelProcess;
	proc.channelSet = createChannelSet(createBasicChannelSetExpr(channel_names));
	proc.leftProcess = left;
	proc.rightProcess = right;
	
	return proc;
}


operation createParallelProcessFromProcSet(
	channel_set: Set<String>, 
	proc_set: Set<Z!CircusProcess> 
	): Z!ParallelProcess{
	
	var proc;
	var size = proc_set.size();

	var i = 0;
	proc = createParallelProcess(channel_set, proc_set.at(0), proc_set.at(1));
	i = i + 2;
	if(size > 2){
	while(i<size){
			proc = createParallelProcess(channel_set, proc, proc_set.at(i));
			i = i + 1;
		}
	}
	return proc;
}

/*
channel set to be synchronized in a parallel action/process is shown as Enumerated channel set in CZT tool.
It is BaiscChannelSetExpr in CZT AST, which contains a set of communications. 
So it is not a channelset, but an expr.
So in the channel set, its a list of communications, instead of a list of channels
*/
//to create BasicChannelSetExpr used in channel set declaration
operation createBasicChannelSetExpr(channel_names:Sequence<String>): Z!BasicChannelSetExpr{
	var expr = new Z!BasicChannelSetExpr;
	var commuList = new Sequence<Z!Communication>;
	for(n in channel_names){
		commuList.add(createChannelSetCommunication(n));
	} 
	var communicationList = new Z!CircusCommunicationList;
	expr.communicationList = communicationList;
	expr.communicationList.communications = commuList;
	return expr;
}

operation createBasicChannelSetExpr(channel_names:Set<String>): Z!BasicChannelSetExpr{
	var expr = new Z!BasicChannelSetExpr;
	var commuList = new Sequence<Z!Communication>;
	for(n in channel_names){
		commuList.add(createChannelSetCommunication(n));
	} 
	var communicationList = new Z!CircusCommunicationList;
	expr.communicationList = communicationList;
	expr.communicationList.communications = commuList;
	return expr;
}
//to create communication of channelset type to be used in the BasicChannelSetExpr
operation createChannelSetCommunication(
	channel_name:String
	): Z!Communication{
	
	var commu = new Z!Communication;
	commu.commUsage = Z!CommUsage#Normal;
	commu.indexed = false;
	commu.multiSych = 0;
	commu.channelExpr = channel_name.createRefExpr(false,false);
	commu.fieldList = new Z!CircusFieldList; 
	
	commu.commPattern = Z!CommPattern#ChannelSet;
	commu.fieldList.fields = Sequence{};		
		
	return commu;
}

operation createChannelSet(expr: Z!Expr):Z!CircusChannelSet{
	var cs = new Z!CircusChannelSet;
	cs.expr = expr;
	return cs;

}




operation Z!CircusChannelSet createChanSetPara(name: String): Z!ChannelSetPara{
	var para = new Z!ChannelSetPara;
	para.name = name.createZName();
	para.channelSet = self;
	
	return para;
}


//CSP Rule 53, modified: 1. update action Trans into a prefixingaction, then 2. updated as a process: (enter.initial(nc.nodes) -> Trans)
operation RC!NodeContainer createTransitionsAsActionPara(): Z!ActionPara{
	
	var trans;

	
	var tran_seq = new Sequence<Z!CircusAction>;
	tran_seq = Sequence{};
	for(t in self.transitions){
		tran_seq.add(t.createTransitionAsCircusAction());
	}
	
	var choice1_action1_left;
	if(tran_seq.size() = 1){
		choice1_action1_left = tran_seq.at(0);
	} else if(tran_seq.size() > 1) {
		choice1_action1_left = tran_seq.createSequenceAsExtchoiceAction();
	}

	
	var choice1_action1_right = createPrefixingAction(createSynchCommunication("share"), createSkipAction());
	
 	var choice1_action1 = createAction2("ExtChoiceAction", choice1_action1_left, choice1_action1_right);

//	var choice1 = createAction2("SeqAction", choice1_action1, "trans".createCallAction());
	var choice1 = createAction2("SeqAction", choice1_action1, ("Trans_"+self.FQN()).createCallAction());
	
	/* Start of Choice 2 creation*/
	//Stop /\ (exit -> Skip)
	var choice2_action1_action2 = createAction2("InterruptAction", "SSTOP".createCallAction(), createPrefixingAction(createSynchCommunication("exit_"+self.FQN()), createSkipAction()));
	var choice2_action1 = createPrefixingAction(createSynchCommunication("interrupt_" + self.FQN()), choice2_action1_action2);
	
	//exited -> end -> Skip
	var choice2_action2_action2 = createPrefixingAction(createSynchCommunication("exited_"+self.FQN()), createPrefixingAction(createSynchCommunication("terminate"), createSkipAction()));
	
	//SStop /\ (exited -> end -> Skip)
	var choice2_action2 = createAction2("InterruptAction", "SSTOP".createCallAction(), choice2_action2_action2);
	var choice2 = createAction2("SeqAction", choice2_action1, choice2_action2);
	/* End of Choice 2 creation*/
	
	
	//terminate -> Skip
	var choice3 = createPrefixingAction(createSynchCommunication("terminate"), createSkipAction());
		
	var trans = createAction2("ExtChoiceAction", choice1, createAction2("ExtChoiceAction", choice2, choice3));
	("trans: "+trans).println();
	
	
	var vguards = self.vguards(); 
	"line309".println();
	vguards.println();
	var Trans = readStateA(vguards, trans);
	return Trans.createActionPara("Trans_"+self.FQN());
	
	
	//Trans is an actioin and can not be a process, because it will be prefixed.
	//end of CSP Rule53
	
	/***********************************
	To be moved to Rule 41
	//to integrate the prefix "enter.initial"
	//and to convert the action into a Process
	var initial_name = self.nodes.selectOne(n|n.instanceOf(Initial)).FQN();

	var commu = createSynchCommunication("enter_" + initial_name);
	
	var prefixAction = createPrefixingAction(commu, Trans);
	prefixAction.createActionPara("prefixedTransAction_"+self.FQN());
	//?? THIS ACTIONPARA SHOULD BE USED IN RULE 41 THROUGH A CALLACTION, THUS THE STRUCTURE IS MORE READABLE
	//TO DO, REMOVE PREFIX IN THIS OPERATION TO RULE 41 SO THAT CONSISTENT WITH MANUAL.
	**********************************/
	
//	var actionParaSeq = new Sequence<Z!ActionPara>;
//	actionParaSeq = Sequence{prefixAction.createActionPara("prefixedTransAction_"+self.FQN())};
//	var proc = actionParaSeq.createBasicProcess("prefixedTransAction_"+ self.FQN());
		
//	return proc;

}


//CSP Rule 54
//to create circus action for each transition
operation RC!Transition createTransitionAsCircusAction(): Z!CircusAction{
	var circusAction;
	if(self.source.type().name = "State"){
					
		//action1: trigger; action2: interruptAction1 ; action3: interruptAction(SStop, SeqAction )
		
		var action1 = trigger(self);
		
		//to create action2: exit
		var rightAction1 = createPrefixingAction(createSynchCommunication("exit_"+nc(self).FQN()), createSkipAction());
		var action2 = createAction2("InterruptAction", "SSTOP".createCallAction(), rightAction1);
		
		//to create action3_inner_1: exited
		var prefixedAction = self.createTrActionAsCircusAction();
		
		
		var action3_inner_1 = createPrefixingAction(createSynchCommunication("exited_"+nc(self).FQN()), prefixedAction);
		
		
		//to create action3_inner_2: enter
		var action3_inner_2 = createPrefixingAction(createSynchCommunication("enter_" + self.target.FQN()), createSkipAction());
		
		var action3_right = createAction2("SeqAction", action3_inner_1, action3_inner_2);
		
		//SStop /\ ( (exited-> [[t.action]]) ; (enter_t.target -> Skip))
		var action3 = createAction2("InterruptAction", "SSTOP".createCallAction(), action3_right);
		
		
		circusAction = createAction2("SeqAction", action1, createAction2("SeqAction", action2, action3));
		
		if(self.condition != null){
			
			("line 2419,  self.condition.eContainer() = " + self.condition.eContainer()).println(); 
			("line 2419,  self.condition = " + self.condition).println();
			("line 2419,  self.condition.type() = " + self.condition.type()).println();
			var pred = self.condition.createExpr().createMemPredEquality();
			circusAction = createGuardedAction(pred, circusAction);
		} 
	} else 
	
	if(self.source.type().name != "State"){
		//action1: prefixingAction
		
		("line 2225, self.source.type().name = " + self.source.type().name).println();
		var prefixedAction = self.createTrActionAsCircusAction();
		
		/*A transition containing a trigger must start on a state, so tevent below can only return internal__.id(t.source)*/
		var action1 = createPrefixingAction(tevent(self), prefixedAction);
		
		
		var action2 = createPrefixingAction(createSynchCommunication("enter_" + self.target.FQN()), createSkipAction());
		
		circusAction = createAction2("SeqAction", action1, action2);
				
		if(self.condition != null){
			var pred = self.condition.createExpr().createMemPredEquality();
			circusAction = createGuardedAction(pred, circusAction);
		} 
	} 
	
	return circusAction;
}


//equality is s relation operator application (C.5.12): MemPred
operation Z!Expr createMemPredEquality(): Z!MemPred{
	var pred =  new Z!MemPred;
	pred.leftExpr = self;
	
	var set = Set{"True"};
	pred.rightExpr = set.createSetExpr();
	pred.mixFix = true;
	
	return pred;
}


operation  Set<String> createSetExpr(): Z!SetExpr{
	var setExpr = new Z!SetExpr;
	var exprList = new Z!ZExprList;
	var exprs = new Sequence<Z!Expr>;
	exprs = Sequence{};
	for(m in self){
		exprs.add(m.createRefExpr(false,false));
	}
	exprList.exprs = exprs;
	setExpr.exprList = exprList;
	return setExpr;
}



 

//CSP Rule 55
operation trigger(t: RC!Transition): Z!PrefixingAction{
	var triggerAction;
	var commu;
	var callAction;
	var channel_name;
	
	if(t.trigger = null){
	
		/*************************************
		commu is a dot communication
		CSP semantics funciton: internal.id(t.source)
		CSPM example: internal__!NID_s0
		Circus example: internal__stm0.NID_s0_stm0
		****************************************/
		commu = createOutputCommunicationFromString("internal__" + nc(t).FQN(), "NID_" + t.source.FQN(), "SYNC");
		triggerAction = createPrefixingAction(commu, createSkipAction());
	} else
	//transition trigger event can only be input or simple type
	if(t.trigger._type = CommunicationType#INPUT){
		
		/*************************************
		CSP semantics function: eventId(t.event)__.id(t.soure).in?x
		CSPM example: trigger1__!NID_s0.in?a
		Circus example: trigger1_stm0__in!NID_s0_stm0?a_stm0
		****************************************/
		channel_name = t.trigger.event.name + "__in";
//		channel_name = t.trigger.event.FQN() + "__in";		
		var dot_para = "NID_" + t.source.FQN();

//		var input_var = t.trigger.parameter.name + "_" + nc(t.trigger.parameter).FQN();
		//the line above is commented out because the var name should be in a state machine scope, i.e. as a local var
		var input_var = t.trigger.parameter.name;
//		commu = createOutputInputCommunication(channel_name, output_para,input_var);
		commu = createDotInputCommunication(channel_name, dot_para,input_var);
		
		//Circus example: set_a_stm0!a_stm0
		var inner_channel_name = "set_" + t.trigger.parameter.name;
		
		var expr_string = t.trigger.parameter.name;
		var inner_commu = createOutputCommunicationFromString(inner_channel_name, expr_string, "OUTPUT");
			
		var rightAction = createPrefixingAction(inner_commu, createSkipAction());
		var leftAction = "SSTOP".createCallAction();
		callAction = createAction2("InterruptAction", leftAction, rightAction);
		
		triggerAction = createPrefixingAction(commu, callAction);
	} else
	
	if(t.trigger._type = CommunicationType#SIMPLE){
		channel_name = t.trigger.event.name + "__in" ;
//		channel_name = t.trigger.event.FQN() + "__in" ;
		var dot_para = "NID_"+ t.source.FQN();
//		commu = createSynchCommunication(channel_name);
		commu = createOutputCommunicationFromString(channel_name, dot_para, "SYNC");
	
		triggerAction = createPrefixingAction(commu, createSkipAction());
	} 
	
	return triggerAction;
}






//CSP Rule 57
operation RC!Junction createJunctionAsActionParas() {
//	var actionParaSeq = new Sequence<Z!ActionPara>;
	
		
	var Inactive = createAction2("InterruptAction", "SSTOP".createCallAction(), createAction2("ExtChoiceAction", ("Activation_"+self.FQN()).createCallAction(), ("Termination_"+self.FQN()).createCallAction()));
	Inactive.createActionPara("Inactive_"+self.FQN());
//	actionParaSeq = Sequence{Inactive.createActionPara("Inactive")};
	
		
	var Activation = createPrefixingAction(createSynchCommunication("enter_"+self.FQN()), ("Active_"+self.FQN()).createCallAction());
	Activation.createActionPara("Activation_"+self.FQN());
//	actionParaSeq.add(Activation.createActionPara("Activation"));
	
	var Termination = createPrefixingAction(createSynchCommunication("terminate"), createSkipAction());
	Termination.createActionPara("Termination_"+self.FQN());
//	actionParaSeq.add(Termination.createActionPara("Termination"));
	
	var seqAction1 = createAction2("InterruptAction", "SSTOP".createCallAction(), createPrefixingAction(createSynchCommunication("interrupt_"+self.FQN()), createSkipAction()));
	
	var Active = createAction2("SeqAction", seqAction1, ("Inactive_"+self.FQN()).createCallAction());
	Active.createActionPara("Active_"+self.FQN());
//	actionParaSeq.add(Active.createActionPara("Active"));
	
//	var mainActionname = "Inactive";
	
//	var basicProcess = actionParaSeq.createBasicProcess(mainActionname);
//	return basicProcess;
}




//CSP Rule 58
operation RC!Final createFinalAsActionParas() {
//	var actionParaSeq = new Sequence<Z!ActionPara>;
	
	var Inactive = createAction2("InterruptAction", "SSTOP".createCallAction(), createAction2("ExtChoiceAction", ("Activation_"+self.FQN()).createCallAction(), ("Termination_"+self.FQN()).createCallAction()));
	Inactive.createActionPara("Inactive_"+self.FQN());
//	actionParaSeq = Sequence{Inactive.createActionPara("Inactive")};
	
		
	var Activation = createPrefixingAction(createSynchCommunication("enter_"+self.FQN()), ("Entering_"+self.FQN()).createCallAction());
	Activation.createActionPara("Activation_"+self.FQN());
//	actionParaSeq.add(Activation.createActionPara("Activation"));
	
	
	var Termination = createPrefixingAction(createSynchCommunication("terminate"), createSkipAction());
	Termination.createActionPara("Termination_"+self.FQN());
//	actionParaSeq.add(Termination.createActionPara("Termination"));
	
		
	var Entering = createPrefixingAction(createSynchCommunication("entered_" + self.FQN()), ("Active_"+self.FQN()).createCallAction());
	Entering.createActionPara("Entering_"+self.FQN());
//	actionParaSeq.add(Entering.createActionPara("Entering"));
	
	
	var rightAction = createAction2("ExtChoiceAction", ("Termination_"+self.FQN()).createCallAction(), createPrefixingAction(createSynchCommunication("interrupt_"+self.FQN()), ("Interrupted_"+self.FQN()).createCallAction()));
	
	var Active = createAction2("InterruptAction", "SSTOP".createCallAction(), rightAction);
	Active.createActionPara("Active_"+self.FQN());
//	actionParaSeq.add(Active.createActionPara("Active"));
	
	var rightAction2 = createPrefixingAction(createSynchCommunication("exit_"+ nc(self).FQN()), createPrefixingAction(createSynchCommunication("exited_"+ nc(self).FQN()), ("Inactive"+self.FQN()).createCallAction()));
	
	var Interrupted = createAction2("InterruptAction", "SSTOP".createCallAction(), rightAction2);
	Interrupted.createActionPara("Interrupted_"+self.FQN());
//	actionParaSeq.add(Interrupted.createActionPara("Interrupted_"+self.FQN()));
	
//	var mainActionname = "Inactive";
//	
//	var basicProcess = actionParaSeq.createBasicProcess(mainActionname);
//	return basicProcess;
}




//CSP Rule 59
operation RC!State createSimpleStateAsActionParas() {
//	var actionParaSeq = new Sequence<Z!ActionPara>;
	
	var Inactive = createAction2("InterruptAction", "SSTOP".createCallAction(), createAction2("ExtChoiceAction", ("Activation_"+self.FQN()).createCallAction(), ("Termination_"+self.FQN()).createCallAction()));
	Inactive.createActionPara("Inactive_"+self.FQN());
//	actionParaSeq.add(InactivePara);
	
	var Activation = createPrefixingAction(createSynchCommunication("enter_"+self.FQN()), ("Active_"+self.FQN()).createCallAction());
	Activation.createActionPara("Activation_"+self.FQN());
//	actionParaSeq.add(Activation.createActionPara("Activation"));
	
	
	var Termination = createPrefixingAction(createSynchCommunication("terminate"), createSkipAction());
	Termination.createActionPara("Termination_"+self.FQN());
//	actionParaSeq.add(Termination.createActionPara("Termination"));
	
	var Active = createAction2("SeqAction", self.createStateActionAsCircusAction("EntryAction"), createAction2("SeqAction", ("Behaviour_"+self.FQN()).createCallAction(), ("Exiting_"+self.FQN()).createCallAction()));
	Active.createActionPara("Active_"+self.FQN());
//	actionParaSeq.add(Active.createActionPara("Active"));
	
	
	var Behaviour = createPrefixingAction(createSynchCommunication("entered_" + self.FQN()), ("During_"+self.FQN()).createCallAction());
	Behaviour.createActionPara("Behaviour_" + self.FQN());
//	actionParaSeq.add(Behaviour.createActionPara("Behaviour"));
	
	var duringLeft = createAction2("SeqAction", self.createStateActionAsCircusAction("DuringAction"), "SSTOP".createCallAction());
	var duringRight = createPrefixingAction(createSynchCommunication("interrupt_" + self.FQN()), createSkipAction());
	var During = createAction2("InterruptAction", duringLeft, duringRight);
	During.createActionPara("During_" + self.FQN());
//	actionParaSeq.add(During.createActionPara("During"));
	
	
	
	var exitingAction1 = createAction2("InterruptAction", "SSTOP".createCallAction(), createPrefixingAction(createSynchCommunication("exit_"+ nc(self).FQN()), createSkipAction()));
	var exitingAction2 = self.createStateActionAsCircusAction("ExitAction");
	var exitingAction3 = createPrefixingAction(createSynchCommunication("exited_"+ nc(self).FQN()), ("Inactive_" + self.FQN()).createCallAction());
	var Exiting = createAction2("SeqAction", exitingAction1, createAction2("SeqAction", exitingAction2, exitingAction3));
	Exiting.createActionPara("Exiting_" + self.FQN());
//	actionParaSeq.add(Exiting.createActionPara("Exiting"));
	
//	var mainActionname = "Inactive";
//	
//	var basicProcess = actionParaSeq.createBasicProcess(mainActionname);
//	return basicProcess;
}


//Rule 60
operation RC!State createCompositeStateAsActionParas(){
	
	
	/*******************************
	Inactive
	*******************************/
	var Inactive = createAction2("InterruptAction", "SSTOP".createCallAction(), createAction2("ExtChoiceAction", ("Activation_"+self.FQN()).createCallAction(), ("Termination_"+self.FQN()).createCallAction()));
	Inactive.createActionPara("Inactive_"+self.FQN());
	
	
	
	/*******************************
	Activation
	*******************************/
	var Activation = createPrefixingAction(createSynchCommunication("enter_"+self.FQN()), ("Active_"+self.FQN()).createCallAction());
	Activation.createActionPara("Activation_"+self.FQN());
	
	
	/*******************************
	Termination
	*******************************/
	var Termination = createPrefixingAction(createSynchCommunication("terminate"), createSkipAction());
	Termination.createActionPara("Termination_"+self.FQN());
	
	
	/*******************************
	Active
	*******************************/
	var Active = createAction2("SeqAction", self.createStateActionAsCircusAction("EntryAction"), createAction2("SeqAction", ("Behaviour_"+self.FQN()).createCallAction(), ("Exiting_"+self.FQN()).createCallAction()));
	Active.createActionPara("Active_"+self.FQN());
	
	
	/*******************************
	Behaviour
	*******************************/
	var cs = enteredSS(self).asSet().includingAll(Set{"terminate", "interrupt_" + nc(self).FQN()});//TBC
	var ns1 = vars(self.nodes);
	var ns2 = vars(s.actions.selectOne(a|a.instanceOf(RC!DuringAction)).action); //Manual: vars(s.during) TBC: s.during.type = statement? 
	var Beh_act1 = ncbehaviour(self);
	var Behaviour = createParallelAction(cs,ns1,ns2,Beh_act1.name.word.createCallAction(),"During_"+self.FQN().createCallAction());
	Behaviour.createActionPara("Behaviour_" + self.FQN());
	
	
	/*******************************
	During
	*******************************/
	//step 1: [] e: enteredSS(s) . e -> Skip
	var extchoiceSeq = new Sequence<Z!CircusAction>;
	for(e in enteredSS(self)){
		extchoiceSeq.add(createPrefixingAction(createSynchCommunication(e.name), createSkipAction()));
	}
	var ext_choice;
	if(extchoiceSeq.size()>1){
		ext_choice = extchoiceSeq.createSequenceAsExtchoiceAction();
	} else if(extchoiceSeq.size()=1) {//lvars.size()=1
		ext_choice = extchoiceSeq.at(0);
	}
	
	//step 2: SStop /\ (step 1)
	var During_act1 = createAction2("InterruptAction", "SSTOP".createCallAction(), ext_choice);
	
	
	//step 3: RUN(enteredSS(s))
	var run = createRunAction(enteredSS(self)); 
	
	//step 4 [s.during]action ; SStop
	var During_act2 = createAction2("SeqAction", self.createStateActionAsCircusAction("DuringAction"), "SSTOP".createCallAction());
	
	//step 5: RUN ||| (during;SStop)
	var During_act3  = createAction2("InterleaveAction", run, During_act2);
	
	
	//step 6: interrupt.id(s) -> (SStop /\ end -> Skip)
	var stopInterruptByEnd = createAction2("InterruptAction", "SSTOP".createCallAction(), createPrefixingAction(createSynchCommunication("terminate"), createSkipAction()));
	var During_act4 = createPrefixingAction(createSynchCommunication("interrupt_" + self.FQN()), stopInterruptByEnd);
	
	
	//step 7: interruption 
	var During_act5 = createAction2("InterruptAction", During_act3, During_act4);
	
	
	//step 8: entered.id(s) -> ()
	During_act5 = createPrefixingAction(createSynchCommunication("enter_"+self.FQN()), During_act5);
	
	//step 9: sequential
	var During = createAction2("SeqAction", During_act1, During_act5);
	
	During.createActionPara("During_" + self.FQN());
	
	
	/*******************************
	Exiting
	*******************************/
	var exitingAction1 = createAction2("InterruptAction", "SSTOP".createCallAction(), createPrefixingAction(createSynchCommunication("exit_" + nc(self).FQN()), createSkipAction()));
	var exitingAction2 = self.createStateActionAsCircusAction("ExitAction");
	var exitingAction3 = createPrefixingAction(createSynchCommunication("exited_"+ nc(self).FQN()), ("Inactive_" + self.FQN()).createCallAction());
	var Exiting = createAction2("SeqAction", exitingAction1, createAction2("SeqAction", exitingAction2, exitingAction3));
	Exiting.createActionPara("Exiting_" + self.FQN());

}


operation createParallelAction(cs: Set<String>,
							   ns1: Set<String>,
							   ns2: Set<String>,
							   left:Z!CircusAction,
							   right:Z!CircusAction): Z!CircusAction{
	
	var action = new Z!ParallelAction;
	action.channelSet = createChannelSet(createBasicChannelSetExpr(cs));
	action.leftAction = left;
	action.rightAction = right;
	
	action.leftNameSet = createNameSet(ns1);
	action.rightNameSet = createNameSet(ns2);
	
	return action;
}


operation Z!CircusAction createActionPara(name: String): Z!ActionPara{
	var para = new Z!ActionPara;
	para.name = name.createZName();
	para.circusAction = self;
	
	return para;
}


//to convert action list into a process
operation Sequence<Z!Para> createBasicProcess(mainActionName: String): Z!BasicProcess{
	
//	var list.paras = new Sequence<Z!Para>;
//	list.paras = self;
	var basicProcess = new Z!BasicProcess;
	
	basicProcess.mainAction = mainActionName.createCallAction();
	
	var list = new Z!ZParaList;
	basicProcess.paraList = list;
	basicProcess.paraList.paras = new Sequence<Z!Para>;
	basicProcess.paraList.paras = self;
		
	return basicProcess;
}




operation Sequence<Z!CircusAction> createSequenceAsExtchoiceAction(): Z!ExtChoiceAction{
	var extchoiceAction;
	var size = self.size();
	var i = 0;
	extchoiceAction = createAction2("ExtChoiceAction", self.at(0), self.at(1));
	i = i + 2;
	if(size > 2){
		while(i<size){
			extchoiceAction = createAction2("ExtChoiceAction", extchoiceAction, self.at(i));
			i = i + 1;
		}
	}
	return extchoiceAction;
}


//This is not used yet
operation Sequence<Z!CircusAction> createSequenceAsSeqAction(): Z!SeqAction{
	var seqAction;
	var size = self.size();
	var i = 0;
	seqAction = createAction2("SeqAction", self.at(0), self.at(1));
	i = i + 2;
	if(size > 2){
		while(i<size){
			seqAction = createAction2("SeqAction", seqAction, self.at(i));
			i = i + 1;
		}
	}
	return seqAction;
}


operation RC!NodeContainer vguards(): Set<String>{
	var vguards = new Set<String>;
	for (tr in self.transitions){
		vguards= vguards.includingAll(usedVariablesInExpr(tr.condition,self));
	}

	return vguards;
}




//TO DO to confirm the Z type
//this version returns ChannelDecl
/*
operation  tevent(t: RC!Transition): Z!ChannelDecl{
 	
 	var chan_name;
 	var chan_type;

	if(t.trigger = null){
		chan_name = "internal." + t.source.name;
		chan_type = "SYNCH";
	} 
	
	//TO DO: to confirm if this "else" is necessary 
	//as trigger is only allowed when source= state 
	else {
		chan_name = t.trigger.event.name + "__." + t.source.name + "_in";
		chan_type = "SYNCH";
	}
	
	var channel = chan_name.createChannelDecl(chan_type);
	
	return channel;
}
*/






operation String createZName(): Z!ZName{
	var zname = new Z!ZName;
	zname.word = self;
	return zname;
}


operation createNameList(stringSeq: Sequence<String>): Z!ZNameList{
	var nl = new Z!ZNameList;
	nl.names = new Sequence<Z!ZName>;
	nl.names = Sequence{};
	
	for(str in stringSeq){
		nl.names.add(str.createZName());
	}
	
	return nl;
}

/*
//used in addChannelDecl
operation Z!ZNameList addName2NameList(name: String){
	self.names.add(name.createZName());
	return self;
}
*/

//not used, replaced by above which take Set<String> as parameter
/*
operation createNameList(nl_string: String): Z!ZNameList{
	var nl = new Z!ZNameList;
	nl.names = new Sequence<ZName>;
"line 185".println();
nl_string.println();
nl_string.length.println();
	
	//if the nl_string is empty string, then the returned list is an empty list.
	//i.e., nl.names = Sequence{}
	if(nl_string.length>1){
		var nl_seq = nl_string.split(",");
		"line191".println();
		nl_seq.println();
		for(name in nl_seq){
			nl.names.add(name.createZName());
		}
	} 

	return nl;
}
*/


operation createShareAsCommunication(): Z!Communication{
	var commu = new Z!Communication;
	
	var chanExpr = new Z!RefExpr;
	var chanExpr = "share".createRefExpr(false,false);
	commu.channelExpr = chanExpr;
	commu.commPattern.name = "Synch";
	commu.commUsage.name = "Normal";
	commu.indexed = false;
	commu.multiSych = 0;
	
	return commu;
}

//TO DO: shall it be an actionPara or action?
operation createSStopActionPara(): Z!ActionPara{
	var actionPara = new Z!ActionPara;
	
	actionPara.name = "SStop".createZName();
	
	var commu = createShareAsCommunication();
	var callAction = "SStop".createCallAction();
	
	//this is a PrefixingAction
	
	actionPara.circusAction = createPrefixingAction(commu, callAction);
	
	return actionPara;
}

operation createPrefixingAction(
	commu: Z!Communication, 
	action: Z!CircusAction
	): Z!PrefixingAction{
	
	var prefixingAction = new Z!PrefixingAction;
	
	prefixingAction.communication  = commu;
	
	prefixingAction.circusAction = action;
	
	return prefixingAction;
}




operation String createAction1(type: String): Z!Action1{
	var action1 = new Z!Action1;
	
	return action1;
}

//binary circus action: not covering PrefixingAction
//TO DO: to complete other types of Action2
operation createAction2(
	type: String, 
	fst_action: Z!CircusAction, 
	snd_action: Z!CircusAction
	): Z!Action2{
	
	var action2;
	if(type = "InterruptAction"){
		//action2 = createInterruptAction(fst_action, snd_action);
		action2 = new Z!InterruptAction;
	} 
	if(type = "SeqAction"){
		action2 = new Z!SeqAction;
	} 
	if(type = "ExtChoiceAction"){
		action2 = new Z!ExtChoiceAction;
	} 	
	if(type = "InterleaveAction"){
		action2 = new Z!InterleaveAction;
	} 
	action2.leftAction = fst_action;

	action2.rightAction = snd_action;
//	action2.actionList = new Z!CircusActionList;
	
//	action2.actionList.circusActions = Sequence{action2.leftAction, action2.rightAction};
		
	return action2;
}


operation createProcess2(
	type: String, 
	fst_proc: Z!CircusProcess, 
	snd_proc: Z!CircusProcess
	): Z!Process2{
	
	var proc;
	
	if(type = "SeqProcess"){
		proc = new Z!SeqProcess;
	} 
	if(type = "ExtChoiceProcess"){
		proc = new Z!ExtChoiceProcess;
	} 	
	if(type = "InterleaveProcess"){
		proc = new Z!InterleaveProcess;
	} 
	if(type = "Process"){
		proc = new Z!InterleaveProcess;
	} 
	proc.leftProcess = fst_proc;

	proc.rightProcess = snd_proc;
//	action2.actionList = new Z!CircusActionList;
	
//	action2.actionList.circusActions = Sequence{action2.leftAction, action2.rightAction};
		
	return proc;
}

operation String createCallAction(): Z!CallAction{
	var callAction = new Z!CallAction;
	callAction.name = self.createZName();
	
	return callAction;
}



operation String createCallAction(list: Sequence<Z!Expr>): Z!CallAction{
	var callAction = new Z!CallAction;
	callAction.name = self.createZName();
	callAction.exprList =  new Z!ZExprList;
	callAction.exprList.exprs = list;
	
	return callAction;
}




operation RC!Transition createTrActionAsCircusAction(): Z!CircusAction{
	if(self.action != null){
		//return self.action.createStmtAsAction();
		return self.action.createStmtInContextAsAction();
	} else{
		return createSkipAction();
	}
}



//CSP Rule 62
operation readState(varSet: Set<String>, action: Z!CircusAction):Z!CircusAction{
	if(varSet.size()=0){
		return action;
	} else {
		
		var var_name = varSet.at(0);

		var commu = createInputCommunication("get_"+var_name, var_name);
		varSet.removeAt(0);	
		var prefixAction = createPrefixingAction(commu, readState(varSet,action));
		var leftAction = "SSTOP".createCallAction();
		
		var action1 = createAction2("InterruptAction", leftAction, prefixAction);
		return action1;
	}
}


//CSP Rule 63
operation readStateAtomic(varSet: Set<String>, action: Z!CircusAction):Z!CircusAction{
	if(varSet.size()=0){
		return action;
	} else {
		
		var var_name = varSet.at(0);
		var commu = createInputCommunication("get_"+var_name, var_name);
		varSet.removeAt(0);	
		var prefixAction = createPrefixingAction(commu, readStateAtomic(varSet,action));
		
		return prefixAction;
	}
}


//CSP Rule 64
operation readStateA(varSet: Set<String>, action: Z!CircusAction):Z!CircusAction{
	if(varSet.size()=0){
		return action;
	} else {
		
		var var_name = varSet.at(0);

		var commu = createInputCommunication("get_"+var_name, var_name);
		varSet.removeAt(0);	
		var prefixAction = createPrefixingAction(commu, readStateAtomic(varSet,action));
		var leftAction = "SSTOP".createCallAction();
		
		var action1 = createAction2("InterruptAction", leftAction, prefixAction);
		return action1;
	}
}




//to create a internal input communication 
//used in readState()
operation createInputCommunication(
	chan_name: String,
	var_name:String
	): Z!Communication{
	
	var commu = new Z!Communication;

	commu.commUsage = Z!CommUsage#Normal;
	commu.indexed = false;
	commu.multiSych = 0;
	commu.channelExpr = chan_name.createRefExpr(false,false);
	
	commu.commPattern = Z!CommPattern#Input;
	commu.fieldList = new Z!CircusFieldList; 
		
	var field = new Z!InputField;
	field.varialbeName = var_name.createZName();
	commu.fieldList.fields = Sequence{field};
	
//	if(type = "INPUT"){ 
//		commu.commPattern = Z!CommPattern#Input;
//
//		var field = new Z!InputField;
//		field.varialbeName = var_name.createZName();
//		commu.fieldList.fields = Sequence{field};
//	} 
	

	
	return commu;
}


//to create a internal output communication, can be outputfield !, or dotfield .
//used in Rule 69 for output and Sync type of RoboChart Communiation
operation createOutputCommunication(
	chan_name: String,
	expr:RC!Expression,
	type: String
	): Z!Communication{
	
	var commu = new Z!Communication;

	commu.commUsage = Z!CommUsage#Normal;
	commu.indexed = false;
	commu.multiSych = 0;
	commu.channelExpr = chan_name.createRefExpr(false,false);

	commu.fieldList = new Z!CircusFieldList; 
		
	
	commu.commPattern = Z!CommPattern#Output;		
	var field = new Z!DotField;
	("line 2874 expr = " + expr).println();
	field.expr = expr.createExpr();
		
	if(type = "OUTPUT"){ 
		field.outputField = true;
	} else
	if(type = "SYNC"){ 
		field.outputField = false;
	}
	
	commu.fieldList.fields = Sequence{field};
	
	return commu;
}



//to create a internal sync communication 
operation createSynchCommunication(
	channel_name:String
	): Z!Communication{
	
	var commu = new Z!Communication;
	commu.commUsage = Z!CommUsage#Normal;
	commu.indexed = false;
	commu.multiSych = 0;
	commu.channelExpr = channel_name.createRefExpr(false,false);
	commu.fieldList = new Z!CircusFieldList; 
	
	commu.commPattern = Z!CommPattern#Synch;
	commu.fieldList.fields = Sequence{};		
		
	return commu;
}




//CSP Rule 65
operation RC!Statement createStmtInContextAsAction(): Z!CircusAction{

	return readState(usedVariables(self), self.createStmtAsAction());
}

//CSP Rule 65_1
operation RC!Statement createStmtAsAction(): Z!CircusAction{
	if(self.instanceOf(RC!Assignment)){
		return self.createAssignmentStmtAsAction();
	} else
	if(self.instanceOf(RC!Call)){
		return self.createCallStmtAsAction();
	} else
	if(self.instanceOf(RC!Skip)){
		return self.createSkipStmtAsAction();
	} else
	if(self.instanceOf(RC!CommunicationStmt)){
		return self.createCommuStmtAsAction();
	} else
	if(self.instanceOf(RC!ParStmt)){
		return self.createParStmtAsAction();
	} else
	if(self.instanceOf(RC!IfStmt)){
		return self.createIfStmtAsAction();
	} else
	if(self.instanceOf(RC!SeqStatement)){
		return self.createSeqStmtAsAction();
	} else
	{}
}




//CSP Rule 66
operation RC!Assignment createAssignmentStmtAsAction(): Z!CircusAction{
	
	/*/
	//assignment is an interrupt actio in Circus
	//left action is SStop
	//right action is a prefixing action
	/*/
	
	/* CallAction permits a name to be an action.	*/
	var leftAction = "SSTOP".createCallAction();
	var chan_name = "set_" + self.left.name.name;
	
	var prefix = createOutputCommunication(chan_name, self.right, "OUTPUT");

	var rightAction = createPrefixingAction(prefix, createSkipAction());
	//PrefixingAction is a type of Action1, so can not use createAction2()

	var circusAction = createAction2("InterruptAction", leftAction, rightAction);
	
	
	//if assignment.right is a function call, and the function has a precondition, then circusAction should be guarded with function.precondition
	//e.g., pre_Chemical_location(gs) & (share__choice(set_anl!Chemical_location(gs) -> SKIP)
	if(self.right.instanceOf(RC!CallExp)){
		("line 3207, self.right.`function`.type = " + self.right.`function`.type()).println();
		("line 3208, self.right.`function`.ref = " + self.right.`function`.ref).println();
		
		var size = self.right.`function`.ref.preconditions.size();
			
		if(size>0){
			var precond = self.right.`function`.ref.preconditions.at(0).createExpr();
			if(size>1){
				precond = createAndExpr(precond, self.right.`function`.ref.preconditions.at(1).createExpr());
				var i = 2;
				while(i<size){
					precond = createAndExpr(precond, self.right.`function`.ref.preconditions.at(i).createExpr());
					i++;
				} 
			}
			
			var pred = precond.createMemPredEquality();
			circusAction = createGuardedAction(pred, circusAction);
	
		}
	}
	
	return circusAction;
}


operation createAndExpr(
	l:Z!Expr,
	r:Z!Expr): Z!ApplExpr{
	
	var expr = new Z!ApplExpr;
	
	expr.mixFix = true; //CZT: C.6.21 (Function Operator Application). For example: S + T.
	
	expr.leftExpr = "_And_".createRefExpr(false,false);

	expr.rightExpr = Sequence{l, r}.createTupleExpr();	
	
	return 	expr;
}

//CSP Rule 67
operation RC!Call createCallStmtAsAction(): Z!CircusAction{
	
	var list = new Sequence<Z!Expr>;
	
	for(elem in self.args){
		list.add(elem.createExpr());
	}
//	var circusAction = self.`operation`.name.createCallAction(list);
	var circusAction = ("CALL__" + self.`operation`.name).createCallAction(list);
	return circusAction;
}



//CSP Rule 68
operation RC!IfStmt createIfStmtAsAction(): Z!IfGuardedCommand{
	
	var if_expr = self.expression;
		"line999".println();
	self.expression.println();
//		var ifAction = createGuardedAction(pred_expr, self.then.createStmtAsAction());
	var if_pred = self.expression.createExpr().createMemPredEquality();
	
	var ifActionInContext = createGuardedAction(if_pred, self.then.createStmtInContextAsAction());
	
	var else_expr = new RC!Not;
	else_expr.exp = clone(if_expr);
	//else_pred.exp = self.expression;

	var pred_else = else_expr.createExpr().createMemPredEquality();
	
	var elseActionInContext = createGuardedAction(pred_else, self.`else`.createStmtInContextAsAction());
	
	var actions = Sequence{ifActionInContext, elseActionInContext};
	
	
	var action = createIFGuardedCommand(actions);
	
	return action;
}


operation createIFGuardedCommand(actions: Sequence<Z!GuardedAction>): Z!IfGuardedCommand{
	var action = new Z!IfGuardedCommand;
	action.actionList = new Z!CircusActionList;
	action.actionList.circusActions = actions;
	
	return action;
}


operation clone(exp : RC!Expression) : RC!Expression   {
	var emfTool = new Native("org.eclipse.epsilon.emc.emf.tools.EmfTool");
	var ecoreUtil = emfTool.ecoreUtil;
	var cloned = ecoreUtil.copy(exp);
	return cloned;
}




/*
operation if_pred(actions: Sequence<Z!GuardedAction>): Z!IfGuardedCommand{
	var action = new Z!IfGuardedCommand;
	action.actionList = new Z!CircusActionList;
	action.actionList.circusActions = actions;
	
	return action;
}
*/
operation createGuardedAction(
	pred: Z!Pred, 
	action: Z!CircusAction
	): Z!GuardedAction{
	var guardedaction = new Z!GuardedAction;
	
	guardedaction.pred = pred;
	guardedaction.circusAction = action;
	return guardedaction;
}





//
//operation String createRCRefExp():RC!RefExp{
//
// 	var refExp = new RC!RefExp;
// 	refExp.ref = new RC!Variable;
// 	refExp.ref.name = self;
// 	
// 	return refExp;
//}


//CSP Rule 69
operation RC!CommunicationStmt createCommuStmtAsAction(): Z!CircusAction{

	
	if(self.communication._type.name = "INPUT"){
		"this is an INPUT type communication".println();
		("line 3038, nc(self) = " + nc(self)).println();
		return self.communication.createCommuINPUTAsAction(nc(self));
	} else

	if(self.communication._type.name = "OUTPUT" or self.communication._type.name = "SYNC"){
		"this is an OUTPUT or SYNC type communication".println();
		return self.communication.createCommuOUTPUT_SYNCAsAction(nc(self));
//		if(self.communication.value.isTypeOf(RC!RefExp)){
//			return self.communication.createCommuOUTPUT_SYNCRefAsAction();
//		} else{
//			return self.communication.createCommuOUTPUT_SYNCConcreteAsAction();
//		}
	} else
	
	if(self.communication._type.name = "SIMPLE"){
		"this is an SIMPLE type communication".println();
		return self.communication.createCommuSIMPLEAsAction(nc(self));
	} 

}

//CSP Rule 69 - RC commu.type = Input
operation RC!Communication createCommuINPUTAsAction(nc:RC!NodeContainer): Z!InterruptAction{
	/*************************************************
	RoboChart example: event1 ? a1	
	CSPM example: SStop /\ (event1.in?a1 -> (SStop /\ set_a1!a1 -> SKIP))) 

	CommunicationStmt is an interrupt action in Circus
	left action is SStop
	right action is a prefixing action
	************************************************/
	var leftAction = "SSTOP".createCallAction();
	

	var chan_name = "set_" + self.parameter.name;
	var expr_string = self.parameter.name;
	var inner_prefix = createOutputCommunicationFromString(chan_name, expr_string,"OUTPUT");
	


	var inner_prefix_action = createPrefixingAction(inner_prefix, createSkipAction());
	var inner_interrupt_action = createAction2("InterruptAction", "SSTOP".createCallAction(),inner_prefix_action);
	
	var outer_prefix = self.createCommuAsCommunication(self.event.name + "_in","INPUT");
	var outer_prefix_action = createPrefixingAction(outer_prefix, inner_interrupt_action);
	
	var circusAction = createAction2("InterruptAction", leftAction, outer_prefix_action);
	
	return circusAction;
}


operation createOutputCommunicationFromString(
	chan_name: String,
	expr_string:String,
	type: String
	): Z!Communication{
	
	var commu = new Z!Communication;

	commu.commUsage = Z!CommUsage#Normal;
	commu.indexed = false;
	commu.multiSych = 0;
	commu.channelExpr = chan_name.createRefExpr(false,false);

	commu.fieldList = new Z!CircusFieldList; 
		
	
	commu.commPattern = Z!CommPattern#Output;		
	var field = new Z!DotField;
	field.expr = expr_string.createRefExpr(false,false);
//	field.outputField = true;
	if(type = "OUTPUT"){ 
		field.outputField = true;
	} else
	if(type = "SYNC"){ 
		field.outputField = false;
	}
	
	commu.fieldList.fields = Sequence{field};
	
	return commu;
}



operation createDotInputCommunication(
	chan_name: String,
	dot_para:String,
	input_var: String
	): Z!Communication{
	
	var commu = new Z!Communication;

	commu.commUsage = Z!CommUsage#Normal;
	commu.indexed = false;
	commu.multiSych = 0;
	commu.channelExpr = chan_name.createRefExpr(false,false);

	commu.fieldList = new Z!CircusFieldList; 
		
	
	commu.commPattern = Z!CommPattern#Mixed;		
	var field1 = new Z!DotField;
	field1.expr = dot_para.createRefExpr(false,false);
	field1.outputField = false;
	
	
	var field2 = new Z!InputField;
	field2.varialbeName = input_var.createZName();
	
	commu.fieldList.fields = Sequence{field1,field2};
	
	return commu;
}




//CSP Rule 69 - RC commu.type = Output/Sync
operation RC!Communication createCommuOUTPUT_SYNCAsAction(nc:RC!NodeContainer): Z!InterruptAction{
	
	/*
	CommunicationStmt is an interrupt action in Circus
	left action is SStop

	right action is a prefixing action
	*/
	
	

	/*to create prefixing of the prefixingAction,i.e., the setting part
	e.g., status_out!input, status_out.input
	*/

	var prefix = createOutputCommunication(self.event.name + "_out", self.value, self._type.name);
	
//	var prefix = createOutputCommunication(self.event.name + "_" + nc.FQN() + "_out", self.value, self._type.name);
	
	var prefix_action = createPrefixingAction(prefix, createSkipAction());
	var interrupt_action = createAction2("InterruptAction", "SSTOP".createCallAction(), prefix_action);
		
	return interrupt_action;
}


//CSP Rule 69 - 3:  RC comm.type = simple
operation RC!Communication createCommuSIMPLEAsAction(nc:RC!NodeContainer): Z!InterruptAction{
	
	var prefix = self.createCommuAsCommunication(self.event.name +"_out","SIMPLE");
//	var prefix = self.createCommuAsCommunication(self.event.name + "_" + nc.FQN() +"_out","SIMPLE");

	var prefix_action = createPrefixingAction(prefix, createSkipAction());
	
	var circusAction = createAction2("InterruptAction", "SSTOP".createCallAction(), prefix_action);
	
	return circusAction;	

}


//not necessary
//status_out!6; status_out.6
//operation RC!Communication createCommuOUTPUT_SYNCConcreteAsAction(): Z!InterruptAction{
//	
	/*
	CommunicationStmt is an interrupt action in Circus
	left action is SStop
	right action is a prefixing action
	*/
//	var leftAction = "SSTOP".createCallAction();
//			
//	var prefix = self.createCommunication(self.event.name + "_out",self._type.name);
//	var prefix_action = createPrefixingAction(prefix, createSkipAction());
//	
//	var circusAction = createAction2("InterruptAction", leftAction, prefix_action);
//	
//	return circusAction;
//}




operation String createInputField(): Z!InputField{
	var field = new Z!InputField;
	field.varialbeName = self.createZName();
	
	return field;
}


operation RC!Expression createOutputField(): Z!DotField{
	var field = new Z!DotField;
	field.expr = self.createExpr();
	field.outputField = true;
	return field;
}


operation RC!Expression createDotField(): Z!DotField{
	var field = new Z!DotField;
	field.expr = self.createExpr();
	field.outputField = false;
	return field;
}
 
////this is used for the communication statement
//operation RC!Communication createOutputField(): Z!DotField{
//	var field = new Z!DotField;
//	var expr;
//	if(self._type = CommunicationType#INPUT){
//	("self.parameter: "+self.parameter).println();
//		expr = self.parameter.name.createRefExpr(false,false);
//	} else
//	if(self._type = CommunicationType#OUTPUT or self._type = CommunicationType#SYNC){
//
////		if(self.value.type().name = "RefExp"){
////			expr = self.value.ref.name.createRefExpr(false,false);		
////		} else{
////			//expr = self.value.createNumExpr(); //the output can be any expr, not only a var or a concreate number
////			expr = self.value.createExpr();
////		}
//		expr = self.value.createExpr();
//	
//	}
//	field.expr = expr;
//	field.outputField = true;
//	
//	return field;
//}


//operation RC!Communication createDotField(): Z!DotField{
//	var dotField = new Z!DotField;
//	dotField.outputField = false;
//	
//	dotField.expr = self.value.createExpr();
////	if(self.value.type().name = "RefExp"){
////		dotField.expr = self.value.ref.name.createRefExpr(false,false);		
////	} else{
////		dotField.expr = self.value.createNumExpr();
////	}
//	
//	return dotField;
//}




//operation RC!Communication createInputField(): Z!InputField{
//	var inputField = new Z!InputField;
//	var name = new String;
//	if(self._type = CommunicationType#INPUT){
//		inputField.varialbeName = self.parameter.name.createZName();
//	} else
//	if(self._type = CommunicationType#OUTPUT){
//		inputField.varialbeName = self.value.ref.name.createZName();
//	} 
//	
//	return inputField;
//}



//operation RC!Assignment createAssignmentAsOutputCommunication():Z!Communication{
//	var commu = new Z!Communication;
//	
//	commu.commUsage = Z!CommUsage#Normal;
//	commu.indexed = false;
//	commu.multiSych = 0;
//	commu.commPattern = Z!CommPattern#Output;	
//	("line 588 commPattern = "+commu.commPattern).println();
//	commu.channelExpr = ("set_" + self.left.name.name).createRefExpr(false,false);
//	
//	commu.fieldList = new Z!CircusFieldList;
//	commu.fieldList.fields = Sequence{self.right.createOutputField()};
//
//	return commu;
//}


//RoboChart Commu to Circus Commu
operation RC!Communication createCommuAsCommunication(
	channel_name:String,
	type:String
	): Z!Communication{
	
	var commu = new Z!Communication;

	commu.commUsage = Z!CommUsage#Normal;
	commu.indexed = false;
	commu.multiSych = 0;
	commu.channelExpr = channel_name.createRefExpr(false,false);
	commu.fieldList = new Z!CircusFieldList; 
	
	if(type = "INPUT"){ 
		commu.commPattern = Z!CommPattern#Input;
		commu.fieldList.fields = Sequence{self.parameter.name.createInputField()};
//		commu.fieldList.fields = Sequence{self.createInputField()};
	} else
	
	if(type = "OUTPUT"){ 
		commu.commPattern = Z!CommPattern#Output;
		commu.fieldList.fields = Sequence{self.value.createOutputField()};
	} else
	
	if(type = "SIMPLE"){ 
		commu.commPattern = Z!CommPattern#Synch;
		commu.fieldList.fields = Sequence{};		
	} else
	
	if(type = "SYNC"){
		commu.commPattern = Z!CommPattern#Output;
		commu.fieldList.fields = Sequence{self.value.createDotField()};		
	} 
	
	return commu;
}



//CSP Rule 70
operation RC!SeqStatement createSeqStmtAsAction(): Z!CircusAction{
	var seq = self.statements;
	return seq.createSeqAsAction();

}

//CSP Rule 70 - auxilary
operation OrderedSet<Any> createSeqAsAction(): Z!CircusAction{
	var seq = self.clone();
	if(seq.size()= 0){
		return null; //TO DO: need to confirm
	} else
	if(seq.size()= 1){
		//return seq.at(0).createStmtAsAction();
		return seq.at(0).createStmtInContextAsAction();
		
	} else	
	if(seq.size()>1){
//		var leftAction = seq.at(0).createStmtAsAction();
		var leftAction = seq.at(0).createStmtInContextAsAction();
		seq.removeAt(0);
		var rightAction = seq.createSeqAsAction();
		return createAction2("SeqAction", leftAction, rightAction);

	}
}




//CSP Rule 71
operation RC!Skip createSkipStmtAsAction(): Z!InterruptAction{

	var leftAction = "SSTOP".createCallAction();
	var rightAction = createSkipAction();
	var circusAction = createAction2("InterruptAction", leftAction, rightAction);
	
	return circusAction;
}


//CSP Rule 72
//parenthesis is removed in Circus
operation RC!ParStmt createParStmtAsAction(): Z!CircusAction{
	return self.stmt.createStmtInContextAsAction();
}




//CSP Rule 73
operation RC!State createStateActionAsCircusAction(actionType:String): Z!CircusAction{
	
	if(self.stateActionDefined(actionType)){
		var index = self.indexOfStateAction(actionType);
		
		return self.actions.at(index).action.createStmtInContextAsAction();
	} else{
		return createSkipAction();
	}
}

//this is to check if the specific type (actionType) of state action is defined
operation RC!State stateActionDefined(actionType: String): Boolean{
	var bool = false;
	if(self.actions.size()>0){
		for(act in self.actions){
			if(act.type().name = actionType){
				bool = true;
			}
		}
	} 
	return bool;
}




operation RC!State indexOfStateAction(actionType: String): Integer{
	var index = 0;
	
	for(act in self.actions){
		if(act.type().name = actionType){
			return index;
		} else{
			index++;
		}
	}
	
}



//TO DO: to confirm if this is used: No
//operation RC!Communication createCommuAsAction(): Z!CircusAction{
//
//	if(self._type.name = "INPUT"){
//		"this is an INPUT type communication".println();
//		return self.createCommuINPUTAsAction();
//	} else
//
//	if(self._type.name = "OUTPUT" or self.communication._type.name = "SYNC"){
//		"this is an OUTPUT or SYNC type communication".println();
//		return self.createCommuOUTPUT_SYNCRefAsAction();
////		if(self.value.isTypeOf(RefExp)){
////			return self.createCommuOUTPUT_SYNCRefAsAction();
////		} else{
////			return self.createCommuOUTPUT_SYNCConcreteAsAction();
////		}
//	} else
//	
//	if(self._type.name = "SIMPLE"){
//		"this is an SIMPLE type communication".println();
//		return self.createCommuSIMPLEAsAction();
//	} 
//
//}






operation createSkipAction(): Z!SkipAction {
	var skipAction = new Z!SkipAction;
	return skipAction;
}

//2024.6.25 a new version 
//create RefExpr as Generic Operator Application: explicit = true, mixFix = true
//used for Robochart SeqType transformation: name = seq_, expr = refExpr
operation createRefExprAsGenOpAppl(
	name_str: String,
	expr: Z!Expr
	): Z!RefExpr{
	
	var refExpr = new Z!RefExpr;
	refExpr.mixFix = true;
	refExpr.explicit = true;
	refExpr.name = name_str.createZName();
	refExpr.exprList = new Z!ZExprList;
	refExpr.exprList.exprs.add(expr);
	
	return refExpr;

}


//create RefExpr as Generic Operator Application: explicit = true, mixFix = true
//used for Robochart SeqType transformation: name = seq_, expr = refExpr
operation createRefExprAsGenOpAppl(
	name_str: String,
	expr_str: String
	): Z!RefExpr{
	
	var refExpr = new Z!RefExpr;
	refExpr.mixFix = true;
	refExpr.explicit = true;
	refExpr.name = name_str.createZName();
	refExpr.exprList = new Z!ZExprList;
	refExpr.exprList.exprs.add(expr_str.createRefExpr(false,false));
	
	return refExpr;

}


//create RefExpr as Reference: explicit = false, mixFix = false
operation String createRefExpr(explicit: Boolean, mixFix: Boolean): Z!RefExpr{
	var refExpr = new Z!RefExpr;
	refExpr.mixFix = mixFix;
	refExpr.explicit = explicit;
	refExpr.name = self.createZName();
	
	return refExpr;

}

operation Sequence<String> createRefExprSeq(explicit: Boolean, mixFix: Boolean): Sequence<Z!RefExpr>{
	var seq = new Sequence<Z!RefExpr>;
	for (name in self){
	
		var refExpr = new Z!RefExpr;
		refExpr.mixFix = mixFix;
		refExpr.explicit = explicit;
		refExpr.name = name.createZName();
		seq.add(refExpr);
	}
		
	return seq;

}

operation RC!BooleanExp createBooleanExpr(): Z!RefExpr{
	var boolExpr = new Z!RefExpr;
	boolExpr.mixFix = false;
	boolExpr.explicit = false;
	boolExpr.name = new Z!ZName;
	if(self.value = "true"){
		boolExpr.name.word ="True";
	} else {
		boolExpr.name.word ="False";
	}
	
	return boolExpr;
}


operation RC!FloatExp createFloatExpr(): Z!RefExpr{
	var floatExpr = new Z!RefExpr;
	floatExpr.mixFix = false;
	floatExpr.explicit = false;
	floatExpr.name = new Z!ZName;
	floatExpr.name.word = self.value.asString();
		
	return floatExpr;
}



operation RC!EnumExp createEnumExpr(): Z!SetExpr{
	var expr = new Z!SetExpr;
	expr.exprList = new Z!ZExprList;
	expr.exprList.exprs.add(self.literal.name.createRefExpr(false,false));
		
	return expr;
}





operation  RC!IntegerExp createNumExpr(): Z!NumExpr{
	var numExpr = new Z!NumExpr;
	numExpr.numeral = new Z!ZNumeral;
	numExpr.numeral.value = self.value;
	
	return numExpr;
}
	
/*
operation RC!Minus createMinusExpr(){
				
	var minus_left = self.left.createNumExpr();
	var minus_right = self.right.createNumExpr();
				
	var minusExpr = new Z!ApplExpr;
	minusExpr.mixFix = true;
				
	minusExpr.leftExpr = "_-_".createRefExpr(false,false);

				
	minusExpr.rightExpr = new Z!TupleExpr;
	minusExpr.rightExpr.exprList = new Z!ZExprList;
	minusExpr.rightExpr.exprList.exprs = Sequence{minus_left, minus_right};
	minusExpr.rightExpr.exprList.exprs.println();
}
*/

/*
operation RC!LessOrEqual createLessOrEqualExpr() {
	var left = self.left.createNumExpr();
	var right = self.right.createNumExpr();
	var lessOrEqualExpr = new Z!ApplExpr;
	lessOrEqualExpr.mixFix = true;
				
	lessOrEqualExpr.leftExpr = "_leq_".createRefExpr(false,false);
							
	lessOrEqualExpr.rightExpr = Sequence{left, right}.createTupleExpr();
}
*/


//CZT: C.6.21 (Function Operator Application). For example: S + T.
operation Any createApplExpr(operator: String): Z!ApplExpr{
	var expr = new Z!ApplExpr;
	expr.mixFix = true; //CZT: C.6.21 (Function Operator Application). For example: S + T.
	
	var operand_left = self.left.createExpr();
	var operand_right = self.right.createExpr();

	expr.leftExpr = operator.createRefExpr(false,false);

	expr.rightExpr = Sequence{operand_left, operand_right}.createTupleExpr();	
//	var left = operator.createRefExpr(false,false);
//	var right = Sequence{operand_left, operand_right}.createTupleExpr();	

//	expr.exprList = new Z!ZExprList;
//	expr.exprList.exprs = Sequence{left, right};
	
	return 	expr;
}



//CZT: C.6.22 (Application)
//RC CallExp is a Z ApplExpr
operation RC!CallExp createCallExpr(): Z!ApplExpr{
	var expr = new Z!ApplExpr;
	expr.mixFix = false; 

	expr.leftExpr = self.`function`.createExpr();
	
	("self.function = " + self.`function`).println();
	("self.function.type = " + self.`function`.type()).println();
	
	("self.function.asString() = " + self.`function`.asString()).println();
	
	var arg_seq = new Sequence<Z!Expr>;
	for(arg in self.args){
		arg_seq.add(arg.createExpr());
	}
	expr.rightExpr = arg_seq.createTupleExpr();	
//	var left = operator.createRefExpr(false,false);
//	var right = Sequence{operand_left, operand_right}.createTupleExpr();	

//	expr.exprList = new Z!ZExprList;
//	expr.exprList.exprs = Sequence{left, right};
	
	return 	expr;
}


//covers Neg, Not
//TO DO: is there other unaryApplExpr?
operation Any createUnaryApplExpr(operator: String): Z!ApplExpr{

	var expr = new Z!ApplExpr;
	expr.mixFix = true;
	
	expr.leftExpr = operator.createRefExpr(false,false);
	
	if(self.isTypeOf(Neg) or self.isTypeOf(Not)){
		expr.rightExpr = self.exp.createExpr();
	} 
		
//	expr.exprList = new Z!ZExprList;
//	expr.exprList.exprs = Sequence{expr.leftExpr, expr.rightExpr};

	return 	expr;
}

operation RC!LessThan createLessThanExpr():Z!ApplExpr{
	return self.createApplExpr("_less_");
}


operation RC!GreaterThan createGreaterThanExpr():Z!ApplExpr{
	return self.createApplExpr("_greater_");
}


operation RC!LessOrEqual createLessOrEqualExpr():Z!ApplExpr{
	return self.createApplExpr("_leq_");
}

operation RC!GreaterOrEqual createGreaterOrEqualExpr():Z!ApplExpr{
	return self.createApplExpr("_geq_");
}

operation RC!Equals createEqualsExpr():Z!ApplExpr{
	return self.createApplExpr("_equals_");
}

operation RC!Different createNequalExpr():Z!ApplExpr{
	return self.createApplExpr("_nequals_");
}


operation RC!And createAndExpr():Z!ApplExpr{
	return self.createApplExpr("_And_");
}

operation RC!Or createOrExpr():Z!ApplExpr{
	return self.createApplExpr("_Or_");
}



operation RC!Iff createIffExpr():Z!ApplExpr{
	return self.createApplExpr("_Equivalence_");
}

operation RC!Implies createImpliesExpr():Z!ApplExpr{
	return self.createApplExpr("_Implies_");
}


operation RC!Plus createPlusExpr():Z!ApplExpr{
	return self.createApplExpr("_+_");
}

operation RC!Minus createMinusExpr():Z!ApplExpr{
	return self.createApplExpr("_-_");
}

operation RC!Mult createMultExpr():Z!ApplExpr{
	return self.createApplExpr("_*_");
}

operation RC!Div createDivExpr():Z!ApplExpr{
	return self.createApplExpr("_div_");
}

operation RC!Modulus createModExpr():Z!ApplExpr{
	return self.createApplExpr("_mod_");
}

operation RC!SeqExp createSeqExpr(): Z!ApplExpr{
	var expr = new Z!ApplExpr;
	expr.mixFix = true; //CZT: C.6.21 (Function Operator Application). 
	
	expr.leftExpr = "<,,>".createRefExpr(false,false);

	var setExpr = new Z!SetExpr;
	var exprList = new Z!ZExprList;
	var exprs = new Sequence<Z!Expr>;
	exprs = Sequence{};
	
	//to do
	var i = 1;//in CZT, this index starts from 1, why?
	for(v in self.values){

		var seq = new Sequence<Z!Expr>;
		seq.add(createNumExpr(i));//index of the element
		seq.add(v.createExpr());//element
		exprs.add(seq.createTupleExpr());//Z list is a list of tupleExpr (index and value)
		i++;
	}
	exprList.exprs = exprs;
	setExpr.exprList = exprList;
	expr.rightExpr = setExpr;	

	
	return 	expr;
}

operation RC!Not createNotExpr():Z!ApplExpr{
	return self.createUnaryApplExpr("Not_");
}	
 	
operation RC!Neg createNegExpr():Z!ApplExpr{
	return self.createUnaryApplExpr("-_");
}	









//ELSE must be removed, otherwise the program runs for a very long time 
operation RC!Expression createExpr():Z!Expr{
	if(self.isTypeOf(RC!LessThan)){
		return self.createLessThanExpr();
	} //else 
	if(self.isTypeOf(RC!GreaterThan)){
		return self.createGreaterThanExpr();
	} //else 
	if(self.isTypeOf(RC!LessOrEqual)){
		return self.createLessOrEqualExpr();
	} //else 
	if(self.isTypeOf(RC!GreaterOrEqual)){
		return self.createGreaterOrEqualExpr();
	} //else 
	if(self.isTypeOf(RC!Equals)){
		return self.createEqualsExpr();
	} //else 
	if(self.isTypeOf(RC!Different)){
		return self.createNequalExpr();
	} //else 
	if (self.isTypeOf(RC!And)){
		return self.createAndExpr();
	} //else 
	if (self.isTypeOf(RC!Or)){
		return self.createOrExpr();
	} //else 
	if (self.isTypeOf(RC!Not)){
		return self.createNotExpr();
	} //else 
	if (self.isTypeOf(RC!Plus)){
		return self.createPlusExpr();
	} //else 
	if (self.isTypeOf(RC!Minus)){
		return self.createMinusExpr();
	} //else 
	
	if (self.isTypeOf(RC!Mult)){
		return self.createMultExpr();
	} //else 
	
	if (self.isTypeOf(RC!Div)){
		return self.createDivExpr();
	} //else
	
	if (self.isTypeOf(RC!Modulus)){
		return self.createModExpr();
	} //else
	
	if (self.isTypeOf(RC!Neg)){
		return self.createNegExpr();
	} //else
	
	if(self.isTypeOf(RC!Iff)){
	 return self.createIffExpr();
	} //else
	
	if(self.isTypeOf(RC!Implies)){
		return self.createImpliesExpr();
	} //else
	
	if(self.isTypeOf(RC!IntegerExp)){
		return self.createNumExpr();
	} //else
	
	if(self.isTypeOf(RC!RefExp)){
		return self.ref.name.createRefExpr(false, false);
	} //else
	
	if(self.isTypeOf(RC!BooleanExp)){
		return self.createBooleanExpr();
	} //else
	
	if(self.isTypeOf(RC!FloatExp)){
		return self.createFloatExpr();
	} //else
	
	if(self.isTypeOf(RC!ParExp)){
		return self.exp.createExpr();
	} //else
	
	if(self.isTypeOf(RC!EnumExp)){
		return self.createEnumExpr();
	} //else
	
	if(self.isTypeOf(RC!CallExp)){
		return self.createCallExpr();
	} //else
	
	if(self.isTypeOf(RC!SeqExp)){
		return self.createSeqExpr();
	} 
	
//	//TO DO
//	if(self.isTypeOf(RC!IfExpression)  or self.isTypeOf(RC!ResultExp) or self.isTypeOf(RC!Selection) or self.isTypeOf(RC!ArrayExp) or self.isTypeOf(RC!TupleExp) or self.isTypeOf(RC!ClockExp) ){
//		return self.createUnaryExpr();
//	} 
}


//TupleExpr is tuple extension expression
operation Sequence<Z!Expr> createTupleExpr(): Z!TupleExpr{
	var tupleExpr = new Z!TupleExpr;
	tupleExpr.exprList = new Z!ZExprList;
	("line 4044 self = " + self).println();
//	("line 4044 self.name = " + self.name).println();
	tupleExpr.exprList.exprs = self;
	return tupleExpr;

}
