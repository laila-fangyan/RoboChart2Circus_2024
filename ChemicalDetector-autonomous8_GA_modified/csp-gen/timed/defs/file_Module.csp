
--
-- RoboChart generator version 3.0.0.202401231330
-- Automatically generated on 01-05-2025 09:52:17
--
-- Iterated compression status: true
-- Assertions compression status: false
--


module ChemicalDetector
	exports
	
	transparent diamond
	transparent sbisim
	transparent dbisim
	transparent chase
	
	-- declaring channels
	-- declaring robotic platform events
	channel flag: InOut
	channel gas: InOut.LSeq(Chemical_GasSensor,2)
	channel obstacle: InOut.Location_Loc
	channel odometer: InOut.core_real
	
	channel moveCall: core_real.Chemical_Angle
	channel randomWalkCall
	channel shortRandomWalkCall
	
	-- declaring module termination channel
	channel terminate
	
	-- declaring robotic platform variables
	
	-- channel set with all visible events
	sem__events = {|
		flag,
		gas,
		obstacle,
		odometer
	,	moveCall,
		randomWalkCall,
		shortRandomWalkCall
	|}
	
	-- declaring controller
		module ctrl_ref0
			shared_variable_events = {|
			|}
			
		exports
			transparent diamond
			transparent sbisim
			transparent dbisim
			transparent chase
	
			-- declaring controller events
			channel turn: InOut.Chemical_Angle
			channel obstacle: InOut.Location_Loc
			channel flag: InOut
			channel stop: InOut
			channel resume: InOut
			channel odometer: InOut.core_real
			
			
			
			-- declaring call and ret events for undefined operations
			channel moveCall: core_real.Chemical_Angle
			channel randomWalkCall
			channel shortRandomWalkCall
			
			-- declaring controller termination channel
			channel terminate
			
			-- channel set with all visible events
			sem__events = {|
				terminate
			,	turn,
				obstacle,
				flag,
				stop,
				resume,
				odometer
			,	moveCall,
				randomWalkCall,
				shortRandomWalkCall
			|}
			
			-- set of visible memory events
			visibleMemoryEvents = {||}
	
			-- defined operations
			-- compileOperationDef
			module OP_changeDirection
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
				
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_From|
				              NID_j0
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				
				-- Declaring call and ret events for undefined operations
				channel moveCall: core_real.Chemical_Angle
				channel randomWalkCall
				channel shortRandomWalkCall
				
				enterSS = {|
				i0::enter,
				From::enter,
				j0::enter
				|}
				
				enteredSS = 	{|
				From::entered,
				j0::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	moveCall,
					randomWalkCall,
					shortRandomWalkCall
					, share__
					|}
				
				channel clockReset, clockResetL, clockResetR 
				
				localClockResets = {||}
				
				
				channel get_CLID_j0 : core_clock_type 
				channel get_CLID_From : core_clock_type 
				--channel increment__
				
				CLID_j0_clock_type(id__,
						          const_Location_changeDirection_lv) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_From_clock_type(id__,
						          const_Location_changeDirection_lv) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				
				
					-- Nodes --
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i0
					module i0
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__,
										param_l,
									    const_Location_changeDirection_lv) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
							
							VS_O__(id__,
										param_l,
									    const_Location_changeDirection_lv) = D__(id__,
										param_l,
									    const_Location_changeDirection_lv)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: From
					module From
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
										param_l,
									    const_Location_changeDirection_lv) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
										param_l,
									    const_Location_changeDirection_lv) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_Location_changeDirection_lv) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- Final state: j0
					module j0
					
					exports
					
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							D__(id__,
										param_l,
									    const_Location_changeDirection_lv) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
									
									Entering 	= entered -> SKIP ; Active
									Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
									Interrupted	= share__choice(exit -> exited -> Inactive)
								within
									Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
										param_l,
									    const_Location_changeDirection_lv) = D__(id__,
										param_l,
									    const_Location_changeDirection_lv)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					-- END of Nodes --
					
					Timed(OneStep) {
					-- Operation calls --
					-- Only the undefined operations are declared here.
					-- If the state machine is in isolation, all required operations will be undefined.
					-- If it is in the context of a controller, the required operations not provided by the
					-- controller will be declared here, and the defined operations will be defined in the
					-- context of the Controller module, and therefore within scope of the state machine module.
					CALL__move(id__,
							    const_Location_changeDirection_lv,
								param_lv,
								param_a) = EDeadline(moveCall.param_lv.param_a,0)
					CALL__randomWalk(id__,
							    const_Location_changeDirection_lv) = EDeadline(randomWalkCall,0)
					CALL__shortRandomWalk(id__,
							    const_Location_changeDirection_lv) = EDeadline(shortRandomWalkCall,0)
					
					-- END of Operation calls --
				
					-- STM processes
					STM(id__,
								param_l,
							    const_Location_changeDirection_lv) = -- RULE: [[stm:OperationDef]]_STM^nops : CSPProcess
					Stateful(id__,
								param_l,
							    const_Location_changeDirection_lv) \ {terminate}
					
					STM_VS_O(id__,
								param_l,
							    const_Location_changeDirection_lv) = -- RULE: [[stm:OperationDef]]_STM^nops : CSPProcess
					Stateful(id__,
								param_l,
							    const_Location_changeDirection_lv) \ {terminate}
					
					-- Transitions
					Transitions(id__,
								param_l,
							    const_Location_changeDirection_lv) = ((let
						Trans = TimeOut_1(
							 (share__ -> SKIP
							 [] dbisim(((param_l==Location_Loc_left))&(internal__!NID_From -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&CALL__move(
							 			id__,
							 		    const_Location_changeDirection_lv,
							 			const_Location_changeDirection_lv,
							 			Chemical_Angle_Right
							 		) ; j0::enter -> SKIP)))
							 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((SKIP ; From::enter -> SKIP))))
							 [] dbisim(((param_l==Location_Loc_right))&(internal__!NID_From -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&CALL__move(
							 			id__,
							 		    const_Location_changeDirection_lv,
							 			const_Location_changeDirection_lv,
							 			Chemical_Angle_Left
							 		) ; j0::enter -> SKIP)))
							 [] dbisim(((param_l==Location_Loc_front))&(internal__!NID_From -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&CALL__move(
							 			id__,
							 		    const_Location_changeDirection_lv,
							 			const_Location_changeDirection_lv,
							 			Chemical_Angle_Back
							 		) ; j0::enter -> SKIP)))
							 []
							 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
							 []
							 terminate -> SKIP
							 )
						,SKIP);Trans
					within
						Trans [|{terminate}|> SKIP
					)
					)
					
					-- Stateful
					-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
					
					-- Named process definitions
					MachineBody(id__,
								param_l,
							    const_Location_changeDirection_lv) = 
						dbisim((
						let
							finalNodesEntered = {|j0::entered|}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								From::enter,
								j0::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_From,internal__.NID_i0,internal__.NID_From,internal__.NID_From|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::D__(id__,
									   			param_l,
									   		    const_Location_changeDirection_lv)
									   [| { share__, terminate } |] (
									   From::D__(id__,
									   			param_l,
									   		    const_Location_changeDirection_lv)
									   [| { share__, terminate } |] (
									   j0::D__(id__,
									   			param_l,
									   		    const_Location_changeDirection_lv)
									   )
									   )
									 )
									 [[From::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_From,internal__.NID_From,internal__.NID_From|}]]
									 [[j0::interrupt <- x__ | x__ <- {|interrupt|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									|}) |]
									 ((i0::enter -> Transitions(id__,
									 			param_l,
									 		    const_Location_changeDirection_lv))
									  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									 )
									)
									)
								)
								 \ hideSet)
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_Location_changeDirection_lv)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour(id__,
								param_l,
							    const_Location_changeDirection_lv) = 
						dbisim((let
							stateClockSync = {|get_CLID_From,From::entered|}
						 within
							(MachineBody(id__,
										param_l,
									    const_Location_changeDirection_lv) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_Location_changeDirection_lv)) \ union(stateClockSync,enteredSS)
						)
						)
					
					
					Stateful(id__,
								param_l,
							    const_Location_changeDirection_lv) = 
						((let
							getsetLocalChannels = {||}
							clockSync = {||}
						within
							(Behaviour(id__,
										param_l,
									    const_Location_changeDirection_lv) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 			param_l,
							 		    const_Location_changeDirection_lv) [| {terminate} |] Clocks(id__,
							 		          const_Location_changeDirection_lv))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					
					-- Visible counterparts
					MachineBody_VS_O(id__,
								param_l,
							    const_Location_changeDirection_lv) = 
						dbisim((
						let
							finalNodesEntered = {|j0::entered|}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								From::enter,
								j0::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_From,internal__.NID_i0,internal__.NID_From,internal__.NID_From|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::VS_O__(id__,
									   			param_l,
									   		    const_Location_changeDirection_lv)
									   [| { share__, terminate } |] (
									   From::VS_O__(id__,
									   			param_l,
									   		    const_Location_changeDirection_lv)
									   [| { share__, terminate } |] (
									   j0::VS_O__(id__,
									   			param_l,
									   		    const_Location_changeDirection_lv)
									   )
									   )
									 )
									 [[From::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_From,internal__.NID_From,internal__.NID_From|}]]
									 [[j0::interrupt <- x__ | x__ <- {|interrupt|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									|}) |]
									 ((i0::enter -> Transitions(id__,
									 			param_l,
									 		    const_Location_changeDirection_lv))
									  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									 )
									)
									)
								)
								 \ hideSet)
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_Location_changeDirection_lv)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour_VS_O(id__,
								param_l,
							    const_Location_changeDirection_lv) = 
						dbisim((let
							stateClockSync = {|get_CLID_From,From::entered|}
						 within
							(MachineBody_VS_O(id__,
										param_l,
									    const_Location_changeDirection_lv) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_Location_changeDirection_lv)) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					
					Stateful_VS_O(id__,
								param_l,
							    const_Location_changeDirection_lv) = 
						dbisim((let
							getsetLocalChannels = {||}
							clockSync = {||}
						within
							(Behaviour_VS_O(id__,
										param_l,
									    const_Location_changeDirection_lv) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 			param_l,
							 		    const_Location_changeDirection_lv) [| {terminate} |] Clocks(id__,
							 		          const_Location_changeDirection_lv))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					
					-- END
					
					-- Memory
					-- Memory variables
					
					-- varMemory process
					varMemory(id__,
								param_l,
							    const_Location_changeDirection_lv) = terminate -> SKIP
					
					getsetLocalChannels = {||}
					
					-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
					FVS__(id__,
								param_l,
							    const_Location_changeDirection_lv) = STM_VS_O(id__,
								param_l,
							    const_Location_changeDirection_lv) \ localClockResets
					D__(id__,
								param_l,
							    const_Location_changeDirection_lv) = timed_priority(STM(id__,
								param_l,
							    const_Location_changeDirection_lv) \ union(internal_events,localClockResets))
					O__(id__,
								param_l,
							    const_Location_changeDirection_lv) = dbisim(D__(id__,
								param_l,
							    const_Location_changeDirection_lv))
					VS__(id__,
								param_l,
							    const_Location_changeDirection_lv) = FVS__(id__,
								param_l,
							    const_Location_changeDirection_lv)
					VS_O__(id__,
								param_l,
							    const_Location_changeDirection_lv) = dbisim(FVS__(id__,
								param_l,
							    const_Location_changeDirection_lv))
					HEXT__(id__,
								param_l,
							    const_Location_changeDirection_lv) = O__(id__,
								param_l,
							    const_Location_changeDirection_lv) [|shared_variable_events|] SKIP
					FVS_C__(id__,
								param_l,
							    const_Location_changeDirection_lv) = dbisim(timed_priority(STM(id__,
								param_l,
							    const_Location_changeDirection_lv) \ internal_events))
					HUP__(id__,
								param_l,
							    const_Location_changeDirection_lv) = timed_priority(O__(id__,
								param_l,
							    const_Location_changeDirection_lv) [|{share__}|] SKIP)
					
					-- Clocks
					
					Clocks(id__,
							          const_Location_changeDirection_lv) = terminate -> SKIP
					
					clockSync = {||}
					
					Clock_CLID_From(id__,x__,
							          const_Location_changeDirection_lv) = 
						TimeOut_1(
							From::entered -> Clock_CLID_From(id__,0,
									          const_Location_changeDirection_lv)
							[]
							get_CLID_From!x__ -> Clock_CLID_From(id__,x__,
									          const_Location_changeDirection_lv)
							[]
							terminate -> SKIP,Clock_CLID_From(id__,clock_type_plus(x__,1,CLID_From_clock_type(id__,
									          const_Location_changeDirection_lv)),
									          const_Location_changeDirection_lv))
					
					StateClocks(id__,
							          const_Location_changeDirection_lv) = dbisim(Clock_CLID_From(id__,0,
							          const_Location_changeDirection_lv))
					
					stateClockSync = {|get_CLID_From,From::entered|}
					}
						endmodule
		
			-- declaring machines
			module stm_ref0
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i1|
				              NID_Waiting|
				              NID_Going|
				              NID_Found|
				              NID_j1|
				              NID_Avoiding|
				              NID_TryingAgain|
				              NID_AvoidingAgain|
				              NID_GettingOut
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_a, set_a, setL_a, setR_a: Chemical_Angle
				channel get_d0, set_d0, setL_d0, setR_d0: core_real
				channel get_d1, set_d1, setL_d1, setR_d1: core_real
				channel get_l, set_l, setL_l, setR_l: Location_Loc
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel obstacle__: NIDS.InOut.Location_Loc
				channel obstacle: InOut.Location_Loc
				channel odometer__: NIDS.InOut.core_real
				channel odometer: InOut.core_real
				channel resume__: NIDS.InOut
				channel resume: InOut
				channel turn__: NIDS.InOut.Chemical_Angle
				channel turn: InOut.Chemical_Angle
				channel stop__: NIDS.InOut
				channel stop: InOut
				channel flag__: NIDS.InOut
				channel flag: InOut
				
				-- Declaring call and ret events for undefined operations
				channel moveCall: core_real.Chemical_Angle
				channel randomWalkCall
				channel shortRandomWalkCall
				
				enterSS = {|
				i1::enter,
				Waiting::enter,
				Going::enter,
				Found::enter,
				j1::enter,
				Avoiding::enter,
				TryingAgain::enter,
				AvoidingAgain::enter,
				GettingOut::enter
				|}
				
				enteredSS = 	{|
				Waiting::entered,
				Going::entered,
				Found::entered,
				j1::entered,
				Avoiding::entered,
				TryingAgain::entered,
				AvoidingAgain::entered,
				GettingOut::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	obstacle,
					odometer,
					resume,
					turn,
					stop,
					flag
				,	moveCall,
					randomWalkCall,
					shortRandomWalkCall
					|}
				datatype ClockSet = 
					CLID_T
				
				channel clockReset, clockResetL, clockResetR : ClockSet
				
				localClockResets = {|clockReset.CLID_T|}
				
				
				channel get_CLID_AvoidingAgain : core_clock_type 
				channel get_CLID_Waiting : core_clock_type 
				channel get_CLID_Avoiding : core_clock_type 
				channel get_CLID_Going : core_clock_type 
				channel get_CLID_Found : core_clock_type 
				channel get_CLID_j1 : core_clock_type 
				channel get_CLID_T : core_clock_type 
				channel get_CLID_GettingOut : core_clock_type 
				channel get_CLID_TryingAgain : core_clock_type 
				--channel increment__
				
				CLID_AvoidingAgain_clock_type(id__,
						          const_Movement_lv,
						          const_Movement_evadeTime,
						          const_Movement_stuckPeriod,
						          const_Movement_stuckDist,
						          const_Movement_outPeriod,
						          const_Location_changeDirection_lv) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_Waiting_clock_type(id__,
						          const_Movement_lv,
						          const_Movement_evadeTime,
						          const_Movement_stuckPeriod,
						          const_Movement_stuckDist,
						          const_Movement_outPeriod,
						          const_Location_changeDirection_lv) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_Avoiding_clock_type(id__,
						          const_Movement_lv,
						          const_Movement_evadeTime,
						          const_Movement_stuckPeriod,
						          const_Movement_stuckDist,
						          const_Movement_outPeriod,
						          const_Location_changeDirection_lv) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_Going_clock_type(id__,
						          const_Movement_lv,
						          const_Movement_evadeTime,
						          const_Movement_stuckPeriod,
						          const_Movement_stuckDist,
						          const_Movement_outPeriod,
						          const_Location_changeDirection_lv) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_Found_clock_type(id__,
						          const_Movement_lv,
						          const_Movement_evadeTime,
						          const_Movement_stuckPeriod,
						          const_Movement_stuckDist,
						          const_Movement_outPeriod,
						          const_Location_changeDirection_lv) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_j1_clock_type(id__,
						          const_Movement_lv,
						          const_Movement_evadeTime,
						          const_Movement_stuckPeriod,
						          const_Movement_stuckDist,
						          const_Movement_outPeriod,
						          const_Location_changeDirection_lv) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_T_clock_type(id__,
						          const_Movement_lv,
						          const_Movement_evadeTime,
						          const_Movement_stuckPeriod,
						          const_Movement_stuckDist,
						          const_Movement_outPeriod,
						          const_Location_changeDirection_lv) = 
					let
						max = (clock_type_max(Union({
				({const_Movement_stuckPeriod|stuckPeriod <- core_nat}),
				({const_Movement_stuckPeriod|stuckPeriod <- core_nat})
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_GettingOut_clock_type(id__,
						          const_Movement_lv,
						          const_Movement_evadeTime,
						          const_Movement_stuckPeriod,
						          const_Movement_stuckDist,
						          const_Movement_outPeriod,
						          const_Location_changeDirection_lv) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_TryingAgain_clock_type(id__,
						          const_Movement_lv,
						          const_Movement_evadeTime,
						          const_Movement_stuckPeriod,
						          const_Movement_stuckDist,
						          const_Movement_outPeriod,
						          const_Location_changeDirection_lv) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				
			
					-- Nodes --
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i1
					module i1
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__,
									    const_Movement_lv,
									    const_Movement_evadeTime,
									    const_Movement_stuckPeriod,
									    const_Movement_stuckDist,
									    const_Movement_outPeriod,
									    const_Location_changeDirection_lv) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
							
							VS_O__(id__,
									    const_Movement_lv,
									    const_Movement_evadeTime,
									    const_Movement_stuckPeriod,
									    const_Movement_stuckDist,
									    const_Movement_outPeriod,
									    const_Location_changeDirection_lv) = D__(id__,
									    const_Movement_lv,
									    const_Movement_evadeTime,
									    const_Movement_stuckPeriod,
									    const_Movement_stuckDist,
									    const_Movement_outPeriod,
									    const_Location_changeDirection_lv)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Waiting
					module Waiting
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_Movement_lv,
									    const_Movement_evadeTime,
									    const_Movement_stuckPeriod,
									    const_Movement_stuckDist,
									    const_Movement_outPeriod,
									    const_Location_changeDirection_lv) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((true&CALL__randomWalk(
											id__,
										    const_Movement_lv,
										    const_Movement_evadeTime,
										    const_Movement_stuckPeriod,
										    const_Movement_stuckDist,
										    const_Movement_outPeriod,
											const_Location_changeDirection_lv
										) ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_Movement_lv,
									    const_Movement_evadeTime,
									    const_Movement_stuckPeriod,
									    const_Movement_stuckDist,
									    const_Movement_outPeriod,
									    const_Location_changeDirection_lv) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((true&CALL__randomWalk(
											id__,
										    const_Movement_lv,
										    const_Movement_evadeTime,
										    const_Movement_stuckPeriod,
										    const_Movement_stuckDist,
										    const_Movement_outPeriod,
											const_Location_changeDirection_lv
										) ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Going
					module Going
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_Movement_lv,
									    const_Movement_evadeTime,
									    const_Movement_stuckPeriod,
									    const_Movement_stuckDist,
									    const_Movement_outPeriod,
									    const_Location_changeDirection_lv) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(get_a?a -> true&CALL__move(
											id__,
										    const_Movement_lv,
										    const_Movement_evadeTime,
										    const_Movement_stuckPeriod,
										    const_Movement_stuckDist,
										    const_Movement_outPeriod,
											const_Movement_lv,
											a,
											const_Location_changeDirection_lv
										)) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_Movement_lv,
									    const_Movement_evadeTime,
									    const_Movement_stuckPeriod,
									    const_Movement_stuckDist,
									    const_Movement_outPeriod,
									    const_Location_changeDirection_lv) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(get_a?a -> true&CALL__move(
											id__,
										    const_Movement_lv,
										    const_Movement_evadeTime,
										    const_Movement_stuckPeriod,
										    const_Movement_stuckDist,
										    const_Movement_outPeriod,
											const_Movement_lv,
											a,
											const_Location_changeDirection_lv
										)) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Found
					module Found
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_Movement_lv,
									    const_Movement_evadeTime,
									    const_Movement_stuckPeriod,
									    const_Movement_stuckDist,
									    const_Movement_outPeriod,
									    const_Location_changeDirection_lv) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&CALL__move(
											id__,
										    const_Movement_lv,
										    const_Movement_evadeTime,
										    const_Movement_stuckPeriod,
										    const_Movement_stuckDist,
										    const_Movement_outPeriod,
											0,
											Chemical_Angle_Front,
											const_Location_changeDirection_lv
										);true&(share__choice(flag.out -> SKIP)) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_Movement_lv,
									    const_Movement_evadeTime,
									    const_Movement_stuckPeriod,
									    const_Movement_stuckDist,
									    const_Movement_outPeriod,
									    const_Location_changeDirection_lv) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&CALL__move(
											id__,
										    const_Movement_lv,
										    const_Movement_evadeTime,
										    const_Movement_stuckPeriod,
										    const_Movement_stuckDist,
										    const_Movement_outPeriod,
											0,
											Chemical_Angle_Front,
											const_Location_changeDirection_lv
										);true&(share__choice(flag.out -> SKIP)) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- Final state: j1
					module j1
					
					exports
					
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							D__(id__,
									    const_Movement_lv,
									    const_Movement_evadeTime,
									    const_Movement_stuckPeriod,
									    const_Movement_stuckDist,
									    const_Movement_outPeriod,
									    const_Location_changeDirection_lv) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
									
									Entering 	= entered -> SKIP ; Active
									Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
									Interrupted	= share__choice(exit -> exited -> Inactive)
								within
									Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_Movement_lv,
									    const_Movement_evadeTime,
									    const_Movement_stuckPeriod,
									    const_Movement_stuckDist,
									    const_Movement_outPeriod,
									    const_Location_changeDirection_lv) = D__(id__,
									    const_Movement_lv,
									    const_Movement_evadeTime,
									    const_Movement_stuckPeriod,
									    const_Movement_stuckDist,
									    const_Movement_outPeriod,
									    const_Location_changeDirection_lv)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Avoiding
					module Avoiding
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_Movement_lv,
									    const_Movement_evadeTime,
									    const_Movement_stuckPeriod,
									    const_Movement_stuckDist,
									    const_Movement_outPeriod,
									    const_Location_changeDirection_lv) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&(share__choice(odometer.in?d0 -> (SStop /\ set_d0!d0 -> SKIP)));share__choice(get_l?l -> true&CALL__changeDirection(
											id__,
										    const_Movement_lv,
										    const_Movement_evadeTime,
										    const_Movement_stuckPeriod,
										    const_Movement_stuckDist,
										    const_Movement_outPeriod,
											l, 
											const_Location_changeDirection_lv
										));SHARE_WAIT(const_Movement_evadeTime) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_Movement_lv,
									    const_Movement_evadeTime,
									    const_Movement_stuckPeriod,
									    const_Movement_stuckDist,
									    const_Movement_outPeriod,
									    const_Location_changeDirection_lv) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&(share__choice(odometer.in?d0 -> (SStop /\ set_d0!d0 -> SKIP)));share__choice(get_l?l -> true&CALL__changeDirection(
											id__,
										    const_Movement_lv,
										    const_Movement_evadeTime,
										    const_Movement_stuckPeriod,
										    const_Movement_stuckDist,
										    const_Movement_outPeriod,
											l, 
											const_Location_changeDirection_lv
										));SHARE_WAIT(const_Movement_evadeTime) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: TryingAgain
					module TryingAgain
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_Movement_lv,
									    const_Movement_evadeTime,
									    const_Movement_stuckPeriod,
									    const_Movement_stuckDist,
									    const_Movement_outPeriod,
									    const_Location_changeDirection_lv) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(get_a?a -> true&CALL__move(
											id__,
										    const_Movement_lv,
										    const_Movement_evadeTime,
										    const_Movement_stuckPeriod,
										    const_Movement_stuckDist,
										    const_Movement_outPeriod,
											const_Movement_lv,
											a,
											const_Location_changeDirection_lv
										)) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_Movement_lv,
									    const_Movement_evadeTime,
									    const_Movement_stuckPeriod,
									    const_Movement_stuckDist,
									    const_Movement_outPeriod,
									    const_Location_changeDirection_lv) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(get_a?a -> true&CALL__move(
											id__,
										    const_Movement_lv,
										    const_Movement_evadeTime,
										    const_Movement_stuckPeriod,
										    const_Movement_stuckDist,
										    const_Movement_outPeriod,
											const_Movement_lv,
											a,
											const_Location_changeDirection_lv
										)) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: AvoidingAgain
					module AvoidingAgain
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_Movement_lv,
									    const_Movement_evadeTime,
									    const_Movement_stuckPeriod,
									    const_Movement_stuckDist,
									    const_Movement_outPeriod,
									    const_Location_changeDirection_lv) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_Movement_lv,
									    const_Movement_evadeTime,
									    const_Movement_stuckPeriod,
									    const_Movement_stuckDist,
									    const_Movement_outPeriod,
									    const_Location_changeDirection_lv) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: GettingOut
					module GettingOut
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_Movement_lv,
									    const_Movement_evadeTime,
									    const_Movement_stuckPeriod,
									    const_Movement_stuckDist,
									    const_Movement_outPeriod,
									    const_Location_changeDirection_lv) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&CALL__shortRandomWalk(
											id__,
										    const_Movement_lv,
										    const_Movement_evadeTime,
										    const_Movement_stuckPeriod,
										    const_Movement_stuckDist,
										    const_Movement_outPeriod,
											const_Location_changeDirection_lv
										);SHARE_WAIT(const_Movement_outPeriod) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_Movement_lv,
									    const_Movement_evadeTime,
									    const_Movement_stuckPeriod,
									    const_Movement_stuckDist,
									    const_Movement_outPeriod,
									    const_Location_changeDirection_lv) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&CALL__shortRandomWalk(
											id__,
										    const_Movement_lv,
										    const_Movement_evadeTime,
										    const_Movement_stuckPeriod,
										    const_Movement_stuckDist,
										    const_Movement_outPeriod,
											const_Location_changeDirection_lv
										);SHARE_WAIT(const_Movement_outPeriod) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					-- END of Nodes --
					
					Timed(OneStep) {
					-- Operation calls --
					-- Only the undefined operations are declared here.
					-- If the state machine is in isolation, all required operations will be undefined.
					-- If it is in the context of a controller, the required operations not provided by the
					-- controller will be declared here, and the defined operations will be defined in the
					-- context of the Controller module, and therefore within scope of the state machine module.
					CALL__move(id__,
							    const_Movement_lv,
							    const_Movement_evadeTime,
							    const_Movement_stuckPeriod,
							    const_Movement_stuckDist,
							    const_Movement_outPeriod,
								param_lv,
								param_a,
							    const_Location_changeDirection_lv) = EDeadline(moveCall.param_lv.param_a,0)
					CALL__randomWalk(id__,
							    const_Movement_lv,
							    const_Movement_evadeTime,
							    const_Movement_stuckPeriod,
							    const_Movement_stuckDist,
							    const_Movement_outPeriod,
							    const_Location_changeDirection_lv) = EDeadline(randomWalkCall,0)
					CALL__shortRandomWalk(id__,
							    const_Movement_lv,
							    const_Movement_evadeTime,
							    const_Movement_stuckPeriod,
							    const_Movement_stuckDist,
							    const_Movement_outPeriod,
							    const_Location_changeDirection_lv) = EDeadline(shortRandomWalkCall,0)
					
					CALL__changeDirection(id__,
							    const_Movement_lv,
							    const_Movement_evadeTime,
							    const_Movement_stuckPeriod,
							    const_Movement_stuckDist,
							    const_Movement_outPeriod,
								param_l,
							    const_Location_changeDirection_lv) = (OP_changeDirection::O__(id__,
								param_l,
							    const_Location_changeDirection_lv))
					[[
						OP_changeDirection::moveCall <- moveCall,
						OP_changeDirection::randomWalkCall <- randomWalkCall,
						OP_changeDirection::shortRandomWalkCall <- shortRandomWalkCall
					]]
					-- END of Operation calls --
				
					-- STM processes
					STM(id__,
							    const_Movement_lv,
							    const_Movement_evadeTime,
							    const_Movement_stuckPeriod,
							    const_Movement_stuckDist,
							    const_Movement_outPeriod,
							    const_Location_changeDirection_lv) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful(id__,
										    const_Movement_lv,
										    const_Movement_evadeTime,
										    const_Movement_stuckPeriod,
										    const_Movement_stuckDist,
										    const_Movement_outPeriod,
										    const_Location_changeDirection_lv) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_Movement_lv,
								    const_Movement_evadeTime,
								    const_Movement_stuckPeriod,
								    const_Movement_stuckDist,
								    const_Movement_outPeriod,
								    const_Location_changeDirection_lv))
					)\sharedVarHide
					
					STM_VS_O(id__,
							    const_Movement_lv,
							    const_Movement_evadeTime,
							    const_Movement_stuckPeriod,
							    const_Movement_stuckDist,
							    const_Movement_outPeriod,
							    const_Location_changeDirection_lv) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful_VS_O(id__,
										    const_Movement_lv,
										    const_Movement_evadeTime,
										    const_Movement_stuckPeriod,
										    const_Movement_stuckDist,
										    const_Movement_outPeriod,
										    const_Location_changeDirection_lv) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_Movement_lv,
								    const_Movement_evadeTime,
								    const_Movement_stuckPeriod,
								    const_Movement_stuckDist,
								    const_Movement_outPeriod,
								    const_Location_changeDirection_lv))
					)\sharedVarHide
					
					-- Transitions
					Transitions(id__,
							    const_Movement_lv,
							    const_Movement_evadeTime,
							    const_Movement_stuckPeriod,
							    const_Movement_stuckDist,
							    const_Movement_outPeriod,
							    const_Location_changeDirection_lv) = ((let
						Trans = share__choice(get_d1?d1 -> get_d0?d0 -> get_CLID_T?T:CLID_T_clock_type(id__,
								          const_Movement_lv,
								          const_Movement_evadeTime,
								          const_Movement_stuckPeriod,
								          const_Movement_stuckDist,
								          const_Movement_outPeriod,
								          const_Location_changeDirection_lv) -> TimeOut_1(
							 (share__ -> SKIP
							 [] dbisim((true)&(internal__!NID_i1 -> SKIP ;  ((SKIP ; Waiting::enter -> SKIP))))
							 [] dbisim((true)&(turn__!NID_Waiting.in?a:{a|a <- Chemical_Angle, true} -> share__choice(set_a!a -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Going::enter -> SKIP)))
							 [] dbisim((true)&(turn__!NID_Going.in?a:{a|a <- Chemical_Angle, true} -> share__choice(set_a!a -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Going::enter -> SKIP)))
							 [] dbisim((true)&(stop__!NID_Going.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Found::enter -> SKIP)))
							 [] dbisim((true)&(internal__!NID_Found -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; j1::enter -> SKIP)))
							 [] dbisim((true)&(obstacle__!NID_Going.in?l:{l|l <- Location_Loc, true} -> share__choice(set_l!l -> SKIP) ; (share__choice(clockReset.CLID_T -> SKIP) ; share__choice(SKIP))
							 ; share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Avoiding::enter -> SKIP)))
							 [] dbisim((true)&(turn__!NID_Avoiding.in?a:{a|a <- Chemical_Angle, true} -> share__choice(set_a!a -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; TryingAgain::enter -> SKIP)))
							 [] dbisim((true)&(turn__!NID_TryingAgain.in?a:{a|a <- Chemical_Angle, true} -> share__choice(set_a!a -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; TryingAgain::enter -> SKIP)))
							 [] dbisim((true)&(stop__!NID_TryingAgain.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Found::enter -> SKIP)))
							 [] dbisim((true)&(resume__!NID_TryingAgain.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Waiting::enter -> SKIP)))
							 [] dbisim((true)&(obstacle__!NID_TryingAgain.in?l:{l|l <- Location_Loc, true} -> share__choice(set_l!l -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(odometer.in?d1 -> (SStop /\ set_d1!d1 -> SKIP))) ; AvoidingAgain::enter -> SKIP)))
							 [] dbisim((((T<const_Movement_stuckPeriod) or (Minus(d1, d0, core_real)>const_Movement_stuckDist)))&(internal__!NID_AvoidingAgain -> SKIP ; (share__choice(clockReset.CLID_T -> SKIP) ; share__choice(SKIP))
							 ; share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Avoiding::enter -> SKIP)))
							 [] dbisim((((T>=const_Movement_stuckPeriod) and (Minus(d1, d0, core_real)<=const_Movement_stuckDist)))&(internal__!NID_AvoidingAgain -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; GettingOut::enter -> SKIP)))
							 [] dbisim((true)&(turn__!NID_GettingOut.in?a:{a|a <- Chemical_Angle, true} -> share__choice(set_a!a -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Going::enter -> SKIP)))
							 [] dbisim((true)&(resume__!NID_Waiting.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Waiting::enter -> SKIP)))
							 [] dbisim((true)&(stop__!NID_Waiting.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Found::enter -> SKIP)))
							 [] dbisim((true)&(stop__!NID_GettingOut.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Found::enter -> SKIP)))
							 [] dbisim((true)&(stop__!NID_AvoidingAgain.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Found::enter -> SKIP)))
							 [] dbisim((true)&(stop__!NID_Avoiding.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Found::enter -> SKIP)))
							 [] dbisim((true)&(resume__!NID_Avoiding.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Waiting::enter -> SKIP)))
							 [] dbisim((true)&(resume__!NID_GettingOut.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Waiting::enter -> SKIP)))
							 [] dbisim((true)&(resume__!NID_AvoidingAgain.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Waiting::enter -> SKIP)))
							 [] dbisim((true)&(resume__!NID_Going.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Waiting::enter -> SKIP)))
							 []
							 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
							 []
							 terminate -> SKIP
							 )
						,SKIP);Trans
						)
					within
						Trans [|{terminate}|> SKIP
					)
					)
					
					-- Stateful
					-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
					
					-- Named process definitions
					MachineBody(id__,
							    const_Movement_lv,
							    const_Movement_evadeTime,
							    const_Movement_stuckPeriod,
							    const_Movement_stuckDist,
							    const_Movement_outPeriod,
							    const_Location_changeDirection_lv) = 
						dbisim((
						let
							finalNodesEntered = {|j1::entered|}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i1::enter,
								Waiting::enter,
								Going::enter,
								Found::enter,
								j1::enter,
								Avoiding::enter,
								TryingAgain::enter,
								AvoidingAgain::enter,
								GettingOut::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i1,turn__.NID_Waiting.in,turn__.NID_Going.in,stop__.NID_Going.in,internal__.NID_Found,obstacle__.NID_Going.in,turn__.NID_Avoiding.in,turn__.NID_TryingAgain.in,stop__.NID_TryingAgain.in,resume__.NID_TryingAgain.in,obstacle__.NID_TryingAgain.in,internal__.NID_AvoidingAgain,internal__.NID_AvoidingAgain,turn__.NID_GettingOut.in,resume__.NID_Waiting.in,stop__.NID_Waiting.in,stop__.NID_GettingOut.in,stop__.NID_AvoidingAgain.in,stop__.NID_Avoiding.in,resume__.NID_Avoiding.in,resume__.NID_GettingOut.in,resume__.NID_AvoidingAgain.in,resume__.NID_Going.in|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i1::D__(id__,
									   		    const_Movement_lv,
									   		    const_Movement_evadeTime,
									   		    const_Movement_stuckPeriod,
									   		    const_Movement_stuckDist,
									   		    const_Movement_outPeriod,
									   		    const_Location_changeDirection_lv)
									   [| { share__, terminate } |] (
									   Waiting::D__(id__,
									   		    const_Movement_lv,
									   		    const_Movement_evadeTime,
									   		    const_Movement_stuckPeriod,
									   		    const_Movement_stuckDist,
									   		    const_Movement_outPeriod,
									   		    const_Location_changeDirection_lv)
									   [| { share__, terminate } |] (
									   Going::D__(id__,
									   		    const_Movement_lv,
									   		    const_Movement_evadeTime,
									   		    const_Movement_stuckPeriod,
									   		    const_Movement_stuckDist,
									   		    const_Movement_outPeriod,
									   		    const_Location_changeDirection_lv)
									   [| { share__, terminate } |] (
									   Found::D__(id__,
									   		    const_Movement_lv,
									   		    const_Movement_evadeTime,
									   		    const_Movement_stuckPeriod,
									   		    const_Movement_stuckDist,
									   		    const_Movement_outPeriod,
									   		    const_Location_changeDirection_lv)
									   [| { share__, terminate } |] (
									   j1::D__(id__,
									   		    const_Movement_lv,
									   		    const_Movement_evadeTime,
									   		    const_Movement_stuckPeriod,
									   		    const_Movement_stuckDist,
									   		    const_Movement_outPeriod,
									   		    const_Location_changeDirection_lv)
									   [| { share__, terminate } |] (
									   Avoiding::D__(id__,
									   		    const_Movement_lv,
									   		    const_Movement_evadeTime,
									   		    const_Movement_stuckPeriod,
									   		    const_Movement_stuckDist,
									   		    const_Movement_outPeriod,
									   		    const_Location_changeDirection_lv)
									   [| { share__, terminate } |] (
									   TryingAgain::D__(id__,
									   		    const_Movement_lv,
									   		    const_Movement_evadeTime,
									   		    const_Movement_stuckPeriod,
									   		    const_Movement_stuckDist,
									   		    const_Movement_outPeriod,
									   		    const_Location_changeDirection_lv)
									   [| { share__, terminate } |] (
									   AvoidingAgain::D__(id__,
									   		    const_Movement_lv,
									   		    const_Movement_evadeTime,
									   		    const_Movement_stuckPeriod,
									   		    const_Movement_stuckDist,
									   		    const_Movement_outPeriod,
									   		    const_Location_changeDirection_lv)
									   [| { share__, terminate } |] (
									   GettingOut::D__(id__,
									   		    const_Movement_lv,
									   		    const_Movement_evadeTime,
									   		    const_Movement_stuckPeriod,
									   		    const_Movement_stuckDist,
									   		    const_Movement_outPeriod,
									   		    const_Location_changeDirection_lv)
									   )
									   )
									   )
									   )
									   )
									   )
									   )
									   )
									 )
									 [[Waiting::interrupt <- x__ | x__ <- {|interrupt,turn__.NID_Waiting.in,resume__.NID_Waiting.in,stop__.NID_Waiting.in|}]]
									 [[Going::interrupt <- x__ | x__ <- {|interrupt,turn__.NID_Going.in,stop__.NID_Going.in,obstacle__.NID_Going.in,resume__.NID_Going.in|}]]
									 [[Found::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Found|}]]
									 [[j1::interrupt <- x__ | x__ <- {|interrupt|}]]
									 [[Avoiding::interrupt <- x__ | x__ <- {|interrupt,turn__.NID_Avoiding.in,stop__.NID_Avoiding.in,resume__.NID_Avoiding.in|}]]
									 [[TryingAgain::interrupt <- x__ | x__ <- {|interrupt,turn__.NID_TryingAgain.in,stop__.NID_TryingAgain.in,resume__.NID_TryingAgain.in,obstacle__.NID_TryingAgain.in|}]]
									 [[AvoidingAgain::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_AvoidingAgain,internal__.NID_AvoidingAgain,stop__.NID_AvoidingAgain.in,resume__.NID_AvoidingAgain.in|}]]
									 [[GettingOut::interrupt <- x__ | x__ <- {|interrupt,turn__.NID_GettingOut.in,stop__.NID_GettingOut.in,resume__.NID_GettingOut.in|}]]
									 [[i1::interrupt <- x__ | x__ <- {|internal__.NID_i1|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_l,setR_a |} ]] 
									  [[set_d1 <- setL_d1,set_d0 <- setL_d0,clockReset.CLID_T <- clockResetL.CLID_T]]
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setL_d1
									 			,setL_d0
									 			,clockResetL.CLID_T
									 			,setR_l
									 			 			,setR_a
									 			|}) |]
									 ((i1::enter -> Transitions(id__,
									 		    const_Movement_lv,
									 		    const_Movement_evadeTime,
									 		    const_Movement_stuckPeriod,
									 		    const_Movement_stuckDist,
									 		    const_Movement_outPeriod,
									 		    const_Location_changeDirection_lv))
									  [[ share__ <- x__ | x__ <- {| share__,setL_d1,setL_d0,clockResetL.CLID_T |} ]]
									  [[set_l <- setR_l,set_a <- setR_a]]
									 )
									)[[setL_d1 <- set_d1,setL_d0 <- set_d0,clockResetL.CLID_T <- clockReset.CLID_T]]
									 [[setR_l <- set_l,setR_a <- set_a]]
									)
								)
								 \ hideSet)
								[[
									obstacle__.x____ <- obstacle,
									odometer__.x____ <- odometer,
									resume__.x____ <- resume,
									turn__.x____ <- turn,
									stop__.x____ <- stop,
									flag__.x____ <- flag
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_Movement_lv,
							 		          const_Movement_evadeTime,
							 		          const_Movement_stuckPeriod,
							 		          const_Movement_stuckDist,
							 		          const_Movement_outPeriod,
							 		          const_Location_changeDirection_lv)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour(id__,
							    const_Movement_lv,
							    const_Movement_evadeTime,
							    const_Movement_stuckPeriod,
							    const_Movement_stuckDist,
							    const_Movement_outPeriod,
							    const_Location_changeDirection_lv) = 
						dbisim((let
							stateClockSync = {|get_CLID_AvoidingAgain,AvoidingAgain::entered,get_CLID_Waiting,Waiting::entered,get_CLID_Avoiding,Avoiding::entered,get_CLID_Going,Going::entered,get_CLID_Found,Found::entered,get_CLID_GettingOut,GettingOut::entered,get_CLID_TryingAgain,TryingAgain::entered|}
						 within
							(MachineBody(id__,
									    const_Movement_lv,
									    const_Movement_evadeTime,
									    const_Movement_stuckPeriod,
									    const_Movement_stuckDist,
									    const_Movement_outPeriod,
									    const_Location_changeDirection_lv) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv)) \ union(stateClockSync,enteredSS)
						)
						)
					
					IteratedBehaviour(id__,
							    const_Movement_lv,
							    const_Movement_evadeTime,
							    const_Movement_stuckPeriod,
							    const_Movement_stuckDist,
							    const_Movement_outPeriod,
							    const_Location_changeDirection_lv) = 
						dbisim((let
							stateClockSync = {|get_CLID_AvoidingAgain,AvoidingAgain::entered,get_CLID_Waiting,Waiting::entered,get_CLID_Avoiding,Avoiding::entered,get_CLID_Going,Going::entered,get_CLID_Found,Found::entered,get_CLID_GettingOut,GettingOut::entered,get_CLID_TryingAgain,TryingAgain::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															dbisim(
																sbisim(
																	dbisim(
																		sbisim(
																			dbisim(
																				sbisim(
																					MachineBody(id__,
																							    const_Movement_lv,
																							    const_Movement_evadeTime,
																							    const_Movement_stuckPeriod,
																							    const_Movement_stuckDist,
																							    const_Movement_outPeriod,
																							    const_Location_changeDirection_lv)
																					[| {|get_CLID_TryingAgain,TryingAgain::entered,terminate|} |]
																					dbisim(Clock_CLID_TryingAgain(id__,0,
																							          const_Movement_lv,
																							          const_Movement_evadeTime,
																							          const_Movement_stuckPeriod,
																							          const_Movement_stuckDist,
																							          const_Movement_outPeriod,
																							          const_Location_changeDirection_lv))
																				)\{|get_CLID_TryingAgain|}
																			)
																			[| {|get_CLID_GettingOut,GettingOut::entered,terminate|} |]
																			dbisim(Clock_CLID_GettingOut(id__,0,
																					          const_Movement_lv,
																					          const_Movement_evadeTime,
																					          const_Movement_stuckPeriod,
																					          const_Movement_stuckDist,
																					          const_Movement_outPeriod,
																					          const_Location_changeDirection_lv))
																		)\{|get_CLID_GettingOut|}
																	)
																	[| {|get_CLID_Found,Found::entered,terminate|} |]
																	dbisim(Clock_CLID_Found(id__,0,
																			          const_Movement_lv,
																			          const_Movement_evadeTime,
																			          const_Movement_stuckPeriod,
																			          const_Movement_stuckDist,
																			          const_Movement_outPeriod,
																			          const_Location_changeDirection_lv))
																)\{|get_CLID_Found|}
															)
															[| {|get_CLID_Going,Going::entered,terminate|} |]
															dbisim(Clock_CLID_Going(id__,0,
																	          const_Movement_lv,
																	          const_Movement_evadeTime,
																	          const_Movement_stuckPeriod,
																	          const_Movement_stuckDist,
																	          const_Movement_outPeriod,
																	          const_Location_changeDirection_lv))
														)\{|get_CLID_Going|}
													)
													[| {|get_CLID_Avoiding,Avoiding::entered,terminate|} |]
													dbisim(Clock_CLID_Avoiding(id__,0,
															          const_Movement_lv,
															          const_Movement_evadeTime,
															          const_Movement_stuckPeriod,
															          const_Movement_stuckDist,
															          const_Movement_outPeriod,
															          const_Location_changeDirection_lv))
												)\{|get_CLID_Avoiding|}
											)
											[| {|get_CLID_Waiting,Waiting::entered,terminate|} |]
											dbisim(Clock_CLID_Waiting(id__,0,
													          const_Movement_lv,
													          const_Movement_evadeTime,
													          const_Movement_stuckPeriod,
													          const_Movement_stuckDist,
													          const_Movement_outPeriod,
													          const_Location_changeDirection_lv))
										)\{|get_CLID_Waiting|}
									)
									[| {|get_CLID_AvoidingAgain,AvoidingAgain::entered,terminate|} |]
									dbisim(Clock_CLID_AvoidingAgain(id__,0,
											          const_Movement_lv,
											          const_Movement_evadeTime,
											          const_Movement_stuckPeriod,
											          const_Movement_stuckDist,
											          const_Movement_outPeriod,
											          const_Location_changeDirection_lv))
								)\{|get_CLID_AvoidingAgain|}
							)
							) \ union(stateClockSync,enteredSS)
						)
						)
					
					Stateful(id__,
							    const_Movement_lv,
							    const_Movement_evadeTime,
							    const_Movement_stuckPeriod,
							    const_Movement_stuckDist,
							    const_Movement_outPeriod,
							    const_Location_changeDirection_lv) = 
						((let
							getsetLocalChannels = {|get_a,set_a,
							get_d0,set_d0,
							get_d1,set_d1,
							get_l,set_l|}
							clockSync = {|get_CLID_T,clockReset.CLID_T|}
						within
							(Behaviour(id__,
									    const_Movement_lv,
									    const_Movement_evadeTime,
									    const_Movement_stuckPeriod,
									    const_Movement_stuckDist,
									    const_Movement_outPeriod,
									    const_Location_changeDirection_lv) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_Movement_lv,
							 		    const_Movement_evadeTime,
							 		    const_Movement_stuckPeriod,
							 		    const_Movement_stuckDist,
							 		    const_Movement_outPeriod,
							 		    const_Location_changeDirection_lv) [| {terminate} |] Clocks(id__,
							 		          const_Movement_lv,
							 		          const_Movement_evadeTime,
							 		          const_Movement_stuckPeriod,
							 		          const_Movement_stuckDist,
							 		          const_Movement_outPeriod,
							 		          const_Location_changeDirection_lv))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful(id__,
							    const_Movement_lv,
							    const_Movement_evadeTime,
							    const_Movement_stuckPeriod,
							    const_Movement_stuckDist,
							    const_Movement_outPeriod,
							    const_Location_changeDirection_lv) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										dbisim(
											sbisim(
												dbisim(
													sbisim(
														dbisim(
															sbisim(
																IteratedBehaviour(id__,
																		    const_Movement_lv,
																		    const_Movement_evadeTime,
																		    const_Movement_stuckPeriod,
																		    const_Movement_stuckDist,
																		    const_Movement_outPeriod,
																		    const_Location_changeDirection_lv)
																[| {|get_CLID_T,clockReset.CLID_T,terminate|} |]
																dbisim(Clock_CLID_T(id__,0,
																		          const_Movement_lv,
																		          const_Movement_evadeTime,
																		          const_Movement_stuckPeriod,
																		          const_Movement_stuckDist,
																		          const_Movement_outPeriod,
																		          const_Location_changeDirection_lv))
															)\{|get_CLID_T,clockReset.CLID_T|}
														)
														[| {|get_l,set_l,terminate|} |]
														Memory_l(Location_Loc_left)
													)\{|get_l,set_l|}
												)
												[| {|get_d1,set_d1,terminate|} |]
												Memory_d1(0)
											)\{|get_d1,set_d1|}
										)
										[| {|get_d0,set_d0,terminate|} |]
										Memory_d0(0)
									)\{|get_d0,set_d0|}
								)
								[| {|get_a,set_a,terminate|} |]
								Memory_a(Chemical_Angle_Left)
							)\{|get_a,set_a|}
						)
						)
					
					-- Visible counterparts
					MachineBody_VS_O(id__,
							    const_Movement_lv,
							    const_Movement_evadeTime,
							    const_Movement_stuckPeriod,
							    const_Movement_stuckDist,
							    const_Movement_outPeriod,
							    const_Location_changeDirection_lv) = 
						dbisim((
						let
							finalNodesEntered = {|j1::entered|}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i1::enter,
								Waiting::enter,
								Going::enter,
								Found::enter,
								j1::enter,
								Avoiding::enter,
								TryingAgain::enter,
								AvoidingAgain::enter,
								GettingOut::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i1,turn__.NID_Waiting.in,turn__.NID_Going.in,stop__.NID_Going.in,internal__.NID_Found,obstacle__.NID_Going.in,turn__.NID_Avoiding.in,turn__.NID_TryingAgain.in,stop__.NID_TryingAgain.in,resume__.NID_TryingAgain.in,obstacle__.NID_TryingAgain.in,internal__.NID_AvoidingAgain,internal__.NID_AvoidingAgain,turn__.NID_GettingOut.in,resume__.NID_Waiting.in,stop__.NID_Waiting.in,stop__.NID_GettingOut.in,stop__.NID_AvoidingAgain.in,stop__.NID_Avoiding.in,resume__.NID_Avoiding.in,resume__.NID_GettingOut.in,resume__.NID_AvoidingAgain.in,resume__.NID_Going.in|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i1::VS_O__(id__,
									   		    const_Movement_lv,
									   		    const_Movement_evadeTime,
									   		    const_Movement_stuckPeriod,
									   		    const_Movement_stuckDist,
									   		    const_Movement_outPeriod,
									   		    const_Location_changeDirection_lv)
									   [| { share__, terminate } |] (
									   Waiting::VS_O__(id__,
									   		    const_Movement_lv,
									   		    const_Movement_evadeTime,
									   		    const_Movement_stuckPeriod,
									   		    const_Movement_stuckDist,
									   		    const_Movement_outPeriod,
									   		    const_Location_changeDirection_lv)
									   [| { share__, terminate } |] (
									   Going::VS_O__(id__,
									   		    const_Movement_lv,
									   		    const_Movement_evadeTime,
									   		    const_Movement_stuckPeriod,
									   		    const_Movement_stuckDist,
									   		    const_Movement_outPeriod,
									   		    const_Location_changeDirection_lv)
									   [| { share__, terminate } |] (
									   Found::VS_O__(id__,
									   		    const_Movement_lv,
									   		    const_Movement_evadeTime,
									   		    const_Movement_stuckPeriod,
									   		    const_Movement_stuckDist,
									   		    const_Movement_outPeriod,
									   		    const_Location_changeDirection_lv)
									   [| { share__, terminate } |] (
									   j1::VS_O__(id__,
									   		    const_Movement_lv,
									   		    const_Movement_evadeTime,
									   		    const_Movement_stuckPeriod,
									   		    const_Movement_stuckDist,
									   		    const_Movement_outPeriod,
									   		    const_Location_changeDirection_lv)
									   [| { share__, terminate } |] (
									   Avoiding::VS_O__(id__,
									   		    const_Movement_lv,
									   		    const_Movement_evadeTime,
									   		    const_Movement_stuckPeriod,
									   		    const_Movement_stuckDist,
									   		    const_Movement_outPeriod,
									   		    const_Location_changeDirection_lv)
									   [| { share__, terminate } |] (
									   TryingAgain::VS_O__(id__,
									   		    const_Movement_lv,
									   		    const_Movement_evadeTime,
									   		    const_Movement_stuckPeriod,
									   		    const_Movement_stuckDist,
									   		    const_Movement_outPeriod,
									   		    const_Location_changeDirection_lv)
									   [| { share__, terminate } |] (
									   AvoidingAgain::VS_O__(id__,
									   		    const_Movement_lv,
									   		    const_Movement_evadeTime,
									   		    const_Movement_stuckPeriod,
									   		    const_Movement_stuckDist,
									   		    const_Movement_outPeriod,
									   		    const_Location_changeDirection_lv)
									   [| { share__, terminate } |] (
									   GettingOut::VS_O__(id__,
									   		    const_Movement_lv,
									   		    const_Movement_evadeTime,
									   		    const_Movement_stuckPeriod,
									   		    const_Movement_stuckDist,
									   		    const_Movement_outPeriod,
									   		    const_Location_changeDirection_lv)
									   )
									   )
									   )
									   )
									   )
									   )
									   )
									   )
									 )
									 [[Waiting::interrupt <- x__ | x__ <- {|interrupt,turn__.NID_Waiting.in,resume__.NID_Waiting.in,stop__.NID_Waiting.in|}]]
									 [[Going::interrupt <- x__ | x__ <- {|interrupt,turn__.NID_Going.in,stop__.NID_Going.in,obstacle__.NID_Going.in,resume__.NID_Going.in|}]]
									 [[Found::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Found|}]]
									 [[j1::interrupt <- x__ | x__ <- {|interrupt|}]]
									 [[Avoiding::interrupt <- x__ | x__ <- {|interrupt,turn__.NID_Avoiding.in,stop__.NID_Avoiding.in,resume__.NID_Avoiding.in|}]]
									 [[TryingAgain::interrupt <- x__ | x__ <- {|interrupt,turn__.NID_TryingAgain.in,stop__.NID_TryingAgain.in,resume__.NID_TryingAgain.in,obstacle__.NID_TryingAgain.in|}]]
									 [[AvoidingAgain::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_AvoidingAgain,internal__.NID_AvoidingAgain,stop__.NID_AvoidingAgain.in,resume__.NID_AvoidingAgain.in|}]]
									 [[GettingOut::interrupt <- x__ | x__ <- {|interrupt,turn__.NID_GettingOut.in,stop__.NID_GettingOut.in,resume__.NID_GettingOut.in|}]]
									 [[i1::interrupt <- x__ | x__ <- {|internal__.NID_i1|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_l,setR_a |} ]] 
									  [[set_d1 <- setL_d1,set_d0 <- setL_d0,clockReset.CLID_T <- clockResetL.CLID_T]]
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setL_d1
									 			,setL_d0
									 			,clockResetL.CLID_T
									 			,setR_l
									 			 			,setR_a
									 			|}) |]
									 ((i1::enter -> Transitions(id__,
									 		    const_Movement_lv,
									 		    const_Movement_evadeTime,
									 		    const_Movement_stuckPeriod,
									 		    const_Movement_stuckDist,
									 		    const_Movement_outPeriod,
									 		    const_Location_changeDirection_lv))
									  [[ share__ <- x__ | x__ <- {| share__,setL_d1,setL_d0,clockResetL.CLID_T |} ]]
									  [[set_l <- setR_l,set_a <- setR_a]]
									 )
									)[[setL_d1 <- set_d1,setL_d0 <- set_d0,clockResetL.CLID_T <- clockReset.CLID_T]]
									 [[setR_l <- set_l,setR_a <- set_a]]
									)
								)
								 \ hideSet)
								[[
									obstacle__.x____ <- obstacle,
									odometer__.x____ <- odometer,
									resume__.x____ <- resume,
									turn__.x____ <- turn,
									stop__.x____ <- stop,
									flag__.x____ <- flag
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_Movement_lv,
							 		          const_Movement_evadeTime,
							 		          const_Movement_stuckPeriod,
							 		          const_Movement_stuckDist,
							 		          const_Movement_outPeriod,
							 		          const_Location_changeDirection_lv)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour_VS_O(id__,
							    const_Movement_lv,
							    const_Movement_evadeTime,
							    const_Movement_stuckPeriod,
							    const_Movement_stuckDist,
							    const_Movement_outPeriod,
							    const_Location_changeDirection_lv) = 
						dbisim((let
							stateClockSync = {|get_CLID_AvoidingAgain,AvoidingAgain::entered,get_CLID_Waiting,Waiting::entered,get_CLID_Avoiding,Avoiding::entered,get_CLID_Going,Going::entered,get_CLID_Found,Found::entered,get_CLID_GettingOut,GettingOut::entered,get_CLID_TryingAgain,TryingAgain::entered|}
						 within
							(MachineBody_VS_O(id__,
									    const_Movement_lv,
									    const_Movement_evadeTime,
									    const_Movement_stuckPeriod,
									    const_Movement_stuckDist,
									    const_Movement_outPeriod,
									    const_Location_changeDirection_lv) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv)) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					IteratedBehaviour_VS_O(id__,
							    const_Movement_lv,
							    const_Movement_evadeTime,
							    const_Movement_stuckPeriod,
							    const_Movement_stuckDist,
							    const_Movement_outPeriod,
							    const_Location_changeDirection_lv) = 
						dbisim((let
							stateClockSync = {|get_CLID_AvoidingAgain,AvoidingAgain::entered,get_CLID_Waiting,Waiting::entered,get_CLID_Avoiding,Avoiding::entered,get_CLID_Going,Going::entered,get_CLID_Found,Found::entered,get_CLID_GettingOut,GettingOut::entered,get_CLID_TryingAgain,TryingAgain::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															dbisim(
																sbisim(
																	dbisim(
																		sbisim(
																			dbisim(
																				sbisim(
																					MachineBody_VS_O(id__,
																							    const_Movement_lv,
																							    const_Movement_evadeTime,
																							    const_Movement_stuckPeriod,
																							    const_Movement_stuckDist,
																							    const_Movement_outPeriod,
																							    const_Location_changeDirection_lv)
																					[| {|get_CLID_TryingAgain,TryingAgain::entered,terminate|} |]
																					dbisim(Clock_CLID_TryingAgain(id__,0,
																							          const_Movement_lv,
																							          const_Movement_evadeTime,
																							          const_Movement_stuckPeriod,
																							          const_Movement_stuckDist,
																							          const_Movement_outPeriod,
																							          const_Location_changeDirection_lv))
																				)\{|get_CLID_TryingAgain|}
																			)
																			[| {|get_CLID_GettingOut,GettingOut::entered,terminate|} |]
																			dbisim(Clock_CLID_GettingOut(id__,0,
																					          const_Movement_lv,
																					          const_Movement_evadeTime,
																					          const_Movement_stuckPeriod,
																					          const_Movement_stuckDist,
																					          const_Movement_outPeriod,
																					          const_Location_changeDirection_lv))
																		)\{|get_CLID_GettingOut|}
																	)
																	[| {|get_CLID_Found,Found::entered,terminate|} |]
																	dbisim(Clock_CLID_Found(id__,0,
																			          const_Movement_lv,
																			          const_Movement_evadeTime,
																			          const_Movement_stuckPeriod,
																			          const_Movement_stuckDist,
																			          const_Movement_outPeriod,
																			          const_Location_changeDirection_lv))
																)\{|get_CLID_Found|}
															)
															[| {|get_CLID_Going,Going::entered,terminate|} |]
															dbisim(Clock_CLID_Going(id__,0,
																	          const_Movement_lv,
																	          const_Movement_evadeTime,
																	          const_Movement_stuckPeriod,
																	          const_Movement_stuckDist,
																	          const_Movement_outPeriod,
																	          const_Location_changeDirection_lv))
														)\{|get_CLID_Going|}
													)
													[| {|get_CLID_Avoiding,Avoiding::entered,terminate|} |]
													dbisim(Clock_CLID_Avoiding(id__,0,
															          const_Movement_lv,
															          const_Movement_evadeTime,
															          const_Movement_stuckPeriod,
															          const_Movement_stuckDist,
															          const_Movement_outPeriod,
															          const_Location_changeDirection_lv))
												)\{|get_CLID_Avoiding|}
											)
											[| {|get_CLID_Waiting,Waiting::entered,terminate|} |]
											dbisim(Clock_CLID_Waiting(id__,0,
													          const_Movement_lv,
													          const_Movement_evadeTime,
													          const_Movement_stuckPeriod,
													          const_Movement_stuckDist,
													          const_Movement_outPeriod,
													          const_Location_changeDirection_lv))
										)\{|get_CLID_Waiting|}
									)
									[| {|get_CLID_AvoidingAgain,AvoidingAgain::entered,terminate|} |]
									dbisim(Clock_CLID_AvoidingAgain(id__,0,
											          const_Movement_lv,
											          const_Movement_evadeTime,
											          const_Movement_stuckPeriod,
											          const_Movement_stuckDist,
											          const_Movement_outPeriod,
											          const_Location_changeDirection_lv))
								)\{|get_CLID_AvoidingAgain|}
							)
							) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					Stateful_VS_O(id__,
							    const_Movement_lv,
							    const_Movement_evadeTime,
							    const_Movement_stuckPeriod,
							    const_Movement_stuckDist,
							    const_Movement_outPeriod,
							    const_Location_changeDirection_lv) = 
						dbisim((let
							getsetLocalChannels = {|get_a,set_a,
							get_d0,set_d0,
							get_d1,set_d1,
							get_l,set_l|}
							clockSync = {|get_CLID_T,clockReset.CLID_T|}
						within
							(Behaviour_VS_O(id__,
									    const_Movement_lv,
									    const_Movement_evadeTime,
									    const_Movement_stuckPeriod,
									    const_Movement_stuckDist,
									    const_Movement_outPeriod,
									    const_Location_changeDirection_lv) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_Movement_lv,
							 		    const_Movement_evadeTime,
							 		    const_Movement_stuckPeriod,
							 		    const_Movement_stuckDist,
							 		    const_Movement_outPeriod,
							 		    const_Location_changeDirection_lv) [| {terminate} |] Clocks(id__,
							 		          const_Movement_lv,
							 		          const_Movement_evadeTime,
							 		          const_Movement_stuckPeriod,
							 		          const_Movement_stuckDist,
							 		          const_Movement_outPeriod,
							 		          const_Location_changeDirection_lv))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful_VS_O(id__,
							    const_Movement_lv,
							    const_Movement_evadeTime,
							    const_Movement_stuckPeriod,
							    const_Movement_stuckDist,
							    const_Movement_outPeriod,
							    const_Location_changeDirection_lv) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										dbisim(
											sbisim(
												dbisim(
													sbisim(
														dbisim(
															sbisim(
																IteratedBehaviour_VS_O(id__,
																		    const_Movement_lv,
																		    const_Movement_evadeTime,
																		    const_Movement_stuckPeriod,
																		    const_Movement_stuckDist,
																		    const_Movement_outPeriod,
																		    const_Location_changeDirection_lv)
																[| {|get_CLID_T,clockReset.CLID_T,terminate|} |]
																dbisim(Clock_CLID_T(id__,0,
																		          const_Movement_lv,
																		          const_Movement_evadeTime,
																		          const_Movement_stuckPeriod,
																		          const_Movement_stuckDist,
																		          const_Movement_outPeriod,
																		          const_Location_changeDirection_lv))
															)\{|get_CLID_T,clockReset.CLID_T|}
														)
														[| {|get_l,set_l,terminate|} |]
														Memory_l(Location_Loc_left)
													)\{|get_l,set_l|}
												)
												[| {|get_d1,set_d1,terminate|} |]
												Memory_d1(0)
											)\{|get_d1,set_d1|}
										)
										[| {|get_d0,set_d0,terminate|} |]
										Memory_d0(0)
									)\{|get_d0,set_d0|}
								)
								[| {|get_a,set_a,terminate|} |]
								Memory_a(Chemical_Angle_Left)
							)\{|get_a,set_a|}
						)
						)
					
					-- END
					
					-- Memory
					-- Memory variables
					Memory_a(a) =
						get_a!a -> Memory_a(a)
						[]
						set_a?x__ -> Memory_a(x__)
						[]
						terminate -> SKIP
					Memory_d0(d0) =
						get_d0!d0 -> Memory_d0(d0)
						[]
						set_d0?x__ -> Memory_d0(x__)
						[]
						terminate -> SKIP
					Memory_d1(d1) =
						get_d1!d1 -> Memory_d1(d1)
						[]
						set_d1?x__ -> Memory_d1(x__)
						[]
						terminate -> SKIP
					Memory_l(l) =
						get_l!l -> Memory_l(l)
						[]
						set_l?x__ -> Memory_l(x__)
						[]
						terminate -> SKIP
					
					-- varMemory process
					varMemory(id__,
							    const_Movement_lv,
							    const_Movement_evadeTime,
							    const_Movement_stuckPeriod,
							    const_Movement_stuckDist,
							    const_Movement_outPeriod,
							    const_Location_changeDirection_lv) = Memory_a(Chemical_Angle_Left)
					[| { terminate } |] (
					Memory_d0(0)
					[| { terminate } |] (
					Memory_d1(0)
					[| { terminate } |] (
					Memory_l(Location_Loc_left)
					)
					)
					)
					
					getsetLocalChannels = {|get_a,set_a,get_d0,set_d0,get_d1,set_d1,get_l,set_l|}
					
					-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
					FVS__(id__,
							    const_Movement_lv,
							    const_Movement_evadeTime,
							    const_Movement_stuckPeriod,
							    const_Movement_stuckDist,
							    const_Movement_outPeriod,
							    const_Location_changeDirection_lv) = STM_VS_O(id__,
							    const_Movement_lv,
							    const_Movement_evadeTime,
							    const_Movement_stuckPeriod,
							    const_Movement_stuckDist,
							    const_Movement_outPeriod,
							    const_Location_changeDirection_lv) \ localClockResets
					D__(id__,
							    const_Movement_lv,
							    const_Movement_evadeTime,
							    const_Movement_stuckPeriod,
							    const_Movement_stuckDist,
							    const_Movement_outPeriod,
							    const_Location_changeDirection_lv) = timed_priority(STM(id__,
							    const_Movement_lv,
							    const_Movement_evadeTime,
							    const_Movement_stuckPeriod,
							    const_Movement_stuckDist,
							    const_Movement_outPeriod,
							    const_Location_changeDirection_lv) \ union(internal_events,localClockResets))
					O__(id__,
							    const_Movement_lv,
							    const_Movement_evadeTime,
							    const_Movement_stuckPeriod,
							    const_Movement_stuckDist,
							    const_Movement_outPeriod,
							    const_Location_changeDirection_lv) = dbisim(D__(id__,
							    const_Movement_lv,
							    const_Movement_evadeTime,
							    const_Movement_stuckPeriod,
							    const_Movement_stuckDist,
							    const_Movement_outPeriod,
							    const_Location_changeDirection_lv))
					VS__(id__,
							    const_Movement_lv,
							    const_Movement_evadeTime,
							    const_Movement_stuckPeriod,
							    const_Movement_stuckDist,
							    const_Movement_outPeriod,
							    const_Location_changeDirection_lv) = FVS__(id__,
							    const_Movement_lv,
							    const_Movement_evadeTime,
							    const_Movement_stuckPeriod,
							    const_Movement_stuckDist,
							    const_Movement_outPeriod,
							    const_Location_changeDirection_lv)
					VS_O__(id__,
							    const_Movement_lv,
							    const_Movement_evadeTime,
							    const_Movement_stuckPeriod,
							    const_Movement_stuckDist,
							    const_Movement_outPeriod,
							    const_Location_changeDirection_lv) = dbisim(FVS__(id__,
							    const_Movement_lv,
							    const_Movement_evadeTime,
							    const_Movement_stuckPeriod,
							    const_Movement_stuckDist,
							    const_Movement_outPeriod,
							    const_Location_changeDirection_lv))
					HEXT__(id__,
							    const_Movement_lv,
							    const_Movement_evadeTime,
							    const_Movement_stuckPeriod,
							    const_Movement_stuckDist,
							    const_Movement_outPeriod,
							    const_Location_changeDirection_lv) = O__(id__,
							    const_Movement_lv,
							    const_Movement_evadeTime,
							    const_Movement_stuckPeriod,
							    const_Movement_stuckDist,
							    const_Movement_outPeriod,
							    const_Location_changeDirection_lv) [|shared_variable_events|] SKIP
					FVS_C__(id__,
							    const_Movement_lv,
							    const_Movement_evadeTime,
							    const_Movement_stuckPeriod,
							    const_Movement_stuckDist,
							    const_Movement_outPeriod,
							    const_Location_changeDirection_lv) = dbisim(timed_priority(STM(id__,
							    const_Movement_lv,
							    const_Movement_evadeTime,
							    const_Movement_stuckPeriod,
							    const_Movement_stuckDist,
							    const_Movement_outPeriod,
							    const_Location_changeDirection_lv) \ internal_events))
					HUP__(id__,
							    const_Movement_lv,
							    const_Movement_evadeTime,
							    const_Movement_stuckPeriod,
							    const_Movement_stuckDist,
							    const_Movement_outPeriod,
							    const_Location_changeDirection_lv) = timed_priority(O__(id__,
							    const_Movement_lv,
							    const_Movement_evadeTime,
							    const_Movement_stuckPeriod,
							    const_Movement_stuckDist,
							    const_Movement_outPeriod,
							    const_Location_changeDirection_lv) [|{share__}|] SKIP)
					
					-- Clocks
					Clock_CLID_T(id__,x__,
							          const_Movement_lv,
							          const_Movement_evadeTime,
							          const_Movement_stuckPeriod,
							          const_Movement_stuckDist,
							          const_Movement_outPeriod,
							          const_Location_changeDirection_lv) = 
						TimeOut_1(
							clockReset.CLID_T -> Clock_CLID_T(id__,0,
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv)
							[]
							get_CLID_T!x__ -> Clock_CLID_T(id__,x__,
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv)
							[]
							terminate -> SKIP,Clock_CLID_T(id__,clock_type_plus(x__,1,CLID_T_clock_type(id__,
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv)),
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv))
					
					Clocks(id__,
							          const_Movement_lv,
							          const_Movement_evadeTime,
							          const_Movement_stuckPeriod,
							          const_Movement_stuckDist,
							          const_Movement_outPeriod,
							          const_Location_changeDirection_lv) = dbisim(Clock_CLID_T(id__,0,
							          const_Movement_lv,
							          const_Movement_evadeTime,
							          const_Movement_stuckPeriod,
							          const_Movement_stuckDist,
							          const_Movement_outPeriod,
							          const_Location_changeDirection_lv))
					
					clockSync = {|get_CLID_T,clockReset.CLID_T|}
					
					Clock_CLID_AvoidingAgain(id__,x__,
							          const_Movement_lv,
							          const_Movement_evadeTime,
							          const_Movement_stuckPeriod,
							          const_Movement_stuckDist,
							          const_Movement_outPeriod,
							          const_Location_changeDirection_lv) = 
						TimeOut_1(
							AvoidingAgain::entered -> Clock_CLID_AvoidingAgain(id__,0,
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv)
							[]
							get_CLID_AvoidingAgain!x__ -> Clock_CLID_AvoidingAgain(id__,x__,
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv)
							[]
							terminate -> SKIP,Clock_CLID_AvoidingAgain(id__,clock_type_plus(x__,1,CLID_AvoidingAgain_clock_type(id__,
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv)),
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv))
					Clock_CLID_Waiting(id__,x__,
							          const_Movement_lv,
							          const_Movement_evadeTime,
							          const_Movement_stuckPeriod,
							          const_Movement_stuckDist,
							          const_Movement_outPeriod,
							          const_Location_changeDirection_lv) = 
						TimeOut_1(
							Waiting::entered -> Clock_CLID_Waiting(id__,0,
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv)
							[]
							get_CLID_Waiting!x__ -> Clock_CLID_Waiting(id__,x__,
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv)
							[]
							terminate -> SKIP,Clock_CLID_Waiting(id__,clock_type_plus(x__,1,CLID_Waiting_clock_type(id__,
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv)),
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv))
					Clock_CLID_Avoiding(id__,x__,
							          const_Movement_lv,
							          const_Movement_evadeTime,
							          const_Movement_stuckPeriod,
							          const_Movement_stuckDist,
							          const_Movement_outPeriod,
							          const_Location_changeDirection_lv) = 
						TimeOut_1(
							Avoiding::entered -> Clock_CLID_Avoiding(id__,0,
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv)
							[]
							get_CLID_Avoiding!x__ -> Clock_CLID_Avoiding(id__,x__,
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv)
							[]
							terminate -> SKIP,Clock_CLID_Avoiding(id__,clock_type_plus(x__,1,CLID_Avoiding_clock_type(id__,
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv)),
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv))
					Clock_CLID_Going(id__,x__,
							          const_Movement_lv,
							          const_Movement_evadeTime,
							          const_Movement_stuckPeriod,
							          const_Movement_stuckDist,
							          const_Movement_outPeriod,
							          const_Location_changeDirection_lv) = 
						TimeOut_1(
							Going::entered -> Clock_CLID_Going(id__,0,
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv)
							[]
							get_CLID_Going!x__ -> Clock_CLID_Going(id__,x__,
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv)
							[]
							terminate -> SKIP,Clock_CLID_Going(id__,clock_type_plus(x__,1,CLID_Going_clock_type(id__,
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv)),
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv))
					Clock_CLID_Found(id__,x__,
							          const_Movement_lv,
							          const_Movement_evadeTime,
							          const_Movement_stuckPeriod,
							          const_Movement_stuckDist,
							          const_Movement_outPeriod,
							          const_Location_changeDirection_lv) = 
						TimeOut_1(
							Found::entered -> Clock_CLID_Found(id__,0,
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv)
							[]
							get_CLID_Found!x__ -> Clock_CLID_Found(id__,x__,
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv)
							[]
							terminate -> SKIP,Clock_CLID_Found(id__,clock_type_plus(x__,1,CLID_Found_clock_type(id__,
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv)),
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv))
					Clock_CLID_GettingOut(id__,x__,
							          const_Movement_lv,
							          const_Movement_evadeTime,
							          const_Movement_stuckPeriod,
							          const_Movement_stuckDist,
							          const_Movement_outPeriod,
							          const_Location_changeDirection_lv) = 
						TimeOut_1(
							GettingOut::entered -> Clock_CLID_GettingOut(id__,0,
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv)
							[]
							get_CLID_GettingOut!x__ -> Clock_CLID_GettingOut(id__,x__,
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv)
							[]
							terminate -> SKIP,Clock_CLID_GettingOut(id__,clock_type_plus(x__,1,CLID_GettingOut_clock_type(id__,
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv)),
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv))
					Clock_CLID_TryingAgain(id__,x__,
							          const_Movement_lv,
							          const_Movement_evadeTime,
							          const_Movement_stuckPeriod,
							          const_Movement_stuckDist,
							          const_Movement_outPeriod,
							          const_Location_changeDirection_lv) = 
						TimeOut_1(
							TryingAgain::entered -> Clock_CLID_TryingAgain(id__,0,
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv)
							[]
							get_CLID_TryingAgain!x__ -> Clock_CLID_TryingAgain(id__,x__,
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv)
							[]
							terminate -> SKIP,Clock_CLID_TryingAgain(id__,clock_type_plus(x__,1,CLID_TryingAgain_clock_type(id__,
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv)),
									          const_Movement_lv,
									          const_Movement_evadeTime,
									          const_Movement_stuckPeriod,
									          const_Movement_stuckDist,
									          const_Movement_outPeriod,
									          const_Location_changeDirection_lv))
					
					StateClocks(id__,
							          const_Movement_lv,
							          const_Movement_evadeTime,
							          const_Movement_stuckPeriod,
							          const_Movement_stuckDist,
							          const_Movement_outPeriod,
							          const_Location_changeDirection_lv) = dbisim(Clock_CLID_AvoidingAgain(id__,0,
							          const_Movement_lv,
							          const_Movement_evadeTime,
							          const_Movement_stuckPeriod,
							          const_Movement_stuckDist,
							          const_Movement_outPeriod,
							          const_Location_changeDirection_lv))
					[| { terminate } |] (
					dbisim(Clock_CLID_Waiting(id__,0,
							          const_Movement_lv,
							          const_Movement_evadeTime,
							          const_Movement_stuckPeriod,
							          const_Movement_stuckDist,
							          const_Movement_outPeriod,
							          const_Location_changeDirection_lv))
					[| { terminate } |] (
					dbisim(Clock_CLID_Avoiding(id__,0,
							          const_Movement_lv,
							          const_Movement_evadeTime,
							          const_Movement_stuckPeriod,
							          const_Movement_stuckDist,
							          const_Movement_outPeriod,
							          const_Location_changeDirection_lv))
					[| { terminate } |] (
					dbisim(Clock_CLID_Going(id__,0,
							          const_Movement_lv,
							          const_Movement_evadeTime,
							          const_Movement_stuckPeriod,
							          const_Movement_stuckDist,
							          const_Movement_outPeriod,
							          const_Location_changeDirection_lv))
					[| { terminate } |] (
					dbisim(Clock_CLID_Found(id__,0,
							          const_Movement_lv,
							          const_Movement_evadeTime,
							          const_Movement_stuckPeriod,
							          const_Movement_stuckDist,
							          const_Movement_outPeriod,
							          const_Location_changeDirection_lv))
					[| { terminate } |] (
					dbisim(Clock_CLID_GettingOut(id__,0,
							          const_Movement_lv,
							          const_Movement_evadeTime,
							          const_Movement_stuckPeriod,
							          const_Movement_stuckDist,
							          const_Movement_outPeriod,
							          const_Location_changeDirection_lv))
					[| { terminate } |] (
					dbisim(Clock_CLID_TryingAgain(id__,0,
							          const_Movement_lv,
							          const_Movement_evadeTime,
							          const_Movement_stuckPeriod,
							          const_Movement_stuckDist,
							          const_Movement_outPeriod,
							          const_Location_changeDirection_lv))
					)
					)
					)
					)
					)
					)
					
					stateClockSync = {|get_CLID_AvoidingAgain,AvoidingAgain::entered,get_CLID_Waiting,Waiting::entered,get_CLID_Avoiding,Avoiding::entered,get_CLID_Going,Going::entered,get_CLID_Found,Found::entered,get_CLID_GettingOut,GettingOut::entered,get_CLID_TryingAgain,TryingAgain::entered|}
					
					-- Shared memory
					-- Shared memory variables
					
					-- sharedVarMemory process
					sharedVarMemory(id__,
							    const_Movement_lv,
							    const_Movement_evadeTime,
							    const_Movement_stuckPeriod,
							    const_Movement_stuckDist,
							    const_Movement_outPeriod,
							    const_Location_changeDirection_lv) = terminate -> SKIP
					
					sharedVarSync = {||}
					
					sharedVarHide = {||}
					}
			endmodule
			
			Timed(OneStep) {
					-- undefined operations
					CALL__move(id__,
							    param_lv,
							    param_a) 	= moveCall.param_lv.param_a -> SKIP
					CALL__randomWalk(id__) 	= randomWalkCall -> SKIP
					CALL__shortRandomWalk(id__) 	= shortRandomWalkCall -> SKIP
					
					-- declaring controller memory
					Memory(id__) = SKIP
					
					D__(id__,
							    const_MicroController_stm_ref0_lv,
							    const_MicroController_stm_ref0_evadeTime,
							    const_MicroController_stm_ref0_stuckPeriod,
							    const_MicroController_stm_ref0_stuckDist,
							    const_MicroController_stm_ref0_outPeriod,
							   	const_MicroController_op_ref0_lv) = prioritise(	((
							let
								const_Movement_lv = const_MicroController_stm_ref0_lv
								const_Movement_evadeTime = const_MicroController_stm_ref0_evadeTime
								const_Movement_stuckPeriod = const_MicroController_stm_ref0_stuckPeriod
								const_Movement_stuckDist = const_MicroController_stm_ref0_stuckDist
								const_Movement_outPeriod = const_MicroController_stm_ref0_outPeriod
								const_Location_changeDirection_lv = const_MicroController_op_ref0_lv
							within 
							stm_ref0::D__(id__,
									    const_Movement_lv,
									    const_Movement_evadeTime,
									    const_Movement_stuckPeriod,
									    const_Movement_stuckDist,
									    const_Movement_outPeriod,
									    const_Location_changeDirection_lv)[[
								stm_ref0::terminate <- terminate,
								stm_ref0::turn <- turn,
								stm_ref0::obstacle <- obstacle,
								stm_ref0::flag <- flag,
								stm_ref0::resume <- resume,
								stm_ref0::stop <- stop,
								stm_ref0::odometer <- odometer,
								stm_ref0::moveCall <- moveCall,
								stm_ref0::randomWalkCall <- randomWalkCall,
								stm_ref0::shortRandomWalkCall <- shortRandomWalkCall
							]]
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						Memory(id__)
					)
					\ union(
						{|
						|},
						{|
						|}
					)
					[|{|terminate|}|>SKIP
					,<visibleMemoryEvents,{tock}>)
					
					-- VS version
					VS__(id__,
							    const_MicroController_stm_ref0_lv,
							    const_MicroController_stm_ref0_evadeTime,
							    const_MicroController_stm_ref0_stuckPeriod,
							    const_MicroController_stm_ref0_stuckDist,
							    const_MicroController_stm_ref0_outPeriod,
							   	const_MicroController_op_ref0_lv) = prioritise(	((
							let
								const_Movement_lv = const_MicroController_stm_ref0_lv
								const_Movement_evadeTime = const_MicroController_stm_ref0_evadeTime
								const_Movement_stuckPeriod = const_MicroController_stm_ref0_stuckPeriod
								const_Movement_stuckDist = const_MicroController_stm_ref0_stuckDist
								const_Movement_outPeriod = const_MicroController_stm_ref0_outPeriod
								const_Location_changeDirection_lv = const_MicroController_op_ref0_lv
							within 
							stm_ref0::VS__(id__,
									    const_Movement_lv,
									    const_Movement_evadeTime,
									    const_Movement_stuckPeriod,
									    const_Movement_stuckDist,
									    const_Movement_outPeriod,
									    const_Location_changeDirection_lv)[[
								stm_ref0::terminate <- terminate,
								stm_ref0::turn <- turn,
								stm_ref0::obstacle <- obstacle,
								stm_ref0::flag <- flag,
								stm_ref0::resume <- resume,
								stm_ref0::stop <- stop,
								stm_ref0::odometer <- odometer,
								stm_ref0::moveCall <- moveCall,
								stm_ref0::randomWalkCall <- randomWalkCall,
								stm_ref0::shortRandomWalkCall <- shortRandomWalkCall
							]]
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						Memory(id__)
					)
					\ union(
						{|
						|},
						{|
						|}
					)
					[|{|terminate|}|>SKIP
					,<visibleMemoryEvents,{tock}>)
				
					-- O version (optimised) THESE TWO PROCESSES SHOULD BE KEPT IN SYNC WITH THE ABOVE TWO
					O__(id__,
							    const_MicroController_stm_ref0_lv,
							    const_MicroController_stm_ref0_evadeTime,
							    const_MicroController_stm_ref0_stuckPeriod,
							    const_MicroController_stm_ref0_stuckDist,
							    const_MicroController_stm_ref0_outPeriod,
							   	const_MicroController_op_ref0_lv) = dbisim(prioritise(	((
							let
								const_Movement_lv = const_MicroController_stm_ref0_lv
								const_Movement_evadeTime = const_MicroController_stm_ref0_evadeTime
								const_Movement_stuckPeriod = const_MicroController_stm_ref0_stuckPeriod
								const_Movement_stuckDist = const_MicroController_stm_ref0_stuckDist
								const_Movement_outPeriod = const_MicroController_stm_ref0_outPeriod
								const_Location_changeDirection_lv = const_MicroController_op_ref0_lv
							within 
							stm_ref0::O__(id__,
									    const_Movement_lv,
									    const_Movement_evadeTime,
									    const_Movement_stuckPeriod,
									    const_Movement_stuckDist,
									    const_Movement_outPeriod,
									    const_Location_changeDirection_lv)[[
								stm_ref0::terminate <- terminate,
								stm_ref0::turn <- turn,
								stm_ref0::obstacle <- obstacle,
								stm_ref0::flag <- flag,
								stm_ref0::resume <- resume,
								stm_ref0::stop <- stop,
								stm_ref0::odometer <- odometer,
								stm_ref0::moveCall <- moveCall,
								stm_ref0::randomWalkCall <- randomWalkCall,
								stm_ref0::shortRandomWalkCall <- shortRandomWalkCall
							]]
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						dbisim(Memory(id__))
					)
					\ union(
						{|
						|},
						{|
						|}
					)
					[|{|terminate|}|>SKIP
					,<visibleMemoryEvents,{tock}>))
									
					-- VS_O version
					VS_O__(id__,
							    const_MicroController_stm_ref0_lv,
							    const_MicroController_stm_ref0_evadeTime,
							    const_MicroController_stm_ref0_stuckPeriod,
							    const_MicroController_stm_ref0_stuckDist,
							    const_MicroController_stm_ref0_outPeriod,
							   	const_MicroController_op_ref0_lv) = dbisim(prioritise(	((
							let
								const_Movement_lv = const_MicroController_stm_ref0_lv
								const_Movement_evadeTime = const_MicroController_stm_ref0_evadeTime
								const_Movement_stuckPeriod = const_MicroController_stm_ref0_stuckPeriod
								const_Movement_stuckDist = const_MicroController_stm_ref0_stuckDist
								const_Movement_outPeriod = const_MicroController_stm_ref0_outPeriod
								const_Location_changeDirection_lv = const_MicroController_op_ref0_lv
							within 
							stm_ref0::VS_O__(id__,
									    const_Movement_lv,
									    const_Movement_evadeTime,
									    const_Movement_stuckPeriod,
									    const_Movement_stuckDist,
									    const_Movement_outPeriod,
									    const_Location_changeDirection_lv)[[
								stm_ref0::terminate <- terminate,
								stm_ref0::turn <- turn,
								stm_ref0::obstacle <- obstacle,
								stm_ref0::flag <- flag,
								stm_ref0::resume <- resume,
								stm_ref0::stop <- stop,
								stm_ref0::odometer <- odometer,
								stm_ref0::moveCall <- moveCall,
								stm_ref0::randomWalkCall <- randomWalkCall,
								stm_ref0::shortRandomWalkCall <- shortRandomWalkCall
							]]
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						dbisim(Memory(id__))
					)
					\ union(
						{|
						|},
						{|
						|}
					)
					[|{|terminate|}|>SKIP
					,<visibleMemoryEvents,{tock}>))
				
					HEXT(id__,
							    const_MicroController_stm_ref0_lv,
							    const_MicroController_stm_ref0_evadeTime,
							    const_MicroController_stm_ref0_stuckPeriod,
							    const_MicroController_stm_ref0_stuckDist,
							    const_MicroController_stm_ref0_outPeriod,
							   	const_MicroController_op_ref0_lv) = O__(id__,
							    const_MicroController_stm_ref0_lv,
							    const_MicroController_stm_ref0_evadeTime,
							    const_MicroController_stm_ref0_stuckPeriod,
							    const_MicroController_stm_ref0_stuckDist,
							    const_MicroController_stm_ref0_outPeriod,
							   	const_MicroController_op_ref0_lv) [|shared_variable_events|] SKIP			
			}
	
		endmodule
		module ctrl_ref1
			shared_variable_events = {|
			|}
			
		exports
			transparent diamond
			transparent sbisim
			transparent dbisim
			transparent chase
	
			-- declaring controller events
			channel turn: InOut.Chemical_Angle
			channel stop: InOut
			channel gas: InOut.LSeq(Chemical_GasSensor,2)
			channel resume: InOut
			
			
			
			-- declaring call and ret events for undefined operations
			
			-- declaring controller termination channel
			channel terminate
			
			-- channel set with all visible events
			sem__events = {|
				terminate
			,	turn,
				stop,
				gas,
				resume
			|}
			
			-- set of visible memory events
			visibleMemoryEvents = {||}
	
			-- defined operations
		
			-- declaring machines
			module stm_ref0
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i1|
				              NID_GasDetected|
				              NID_j1|
				              NID_Reading|
				              NID_Analysis|
				              NID_NoGas
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_sts, set_sts, setL_sts, setR_sts: Chemical_Status
				channel get_gs, set_gs, setL_gs, setR_gs: LSeq(Chemical_GasSensor,2)
				channel get_ins, set_ins, setL_ins, setR_ins: Chemical_Intensity
				channel get_anl, set_anl, setL_anl, setR_anl: Chemical_Angle
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel gas__: NIDS.InOut.LSeq(Chemical_GasSensor,2)
				channel gas: InOut.LSeq(Chemical_GasSensor,2)
				channel resume__: NIDS.InOut
				channel resume: InOut
				channel turn__: NIDS.InOut.Chemical_Angle
				channel turn: InOut.Chemical_Angle
				channel stop__: NIDS.InOut
				channel stop: InOut
				
				-- Declaring call and ret events for undefined operations
				
				enterSS = {|
				i1::enter,
				GasDetected::enter,
				j1::enter,
				Reading::enter,
				Analysis::enter,
				NoGas::enter
				|}
				
				enteredSS = 	{|
				GasDetected::entered,
				j1::entered,
				Reading::entered,
				Analysis::entered,
				NoGas::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	gas,
					resume,
					turn,
					stop
					|}
				
				channel clockReset, clockResetL, clockResetR 
				
				localClockResets = {||}
				
				
				channel get_CLID_Analysis : core_clock_type 
				channel get_CLID_Reading : core_clock_type 
				channel get_CLID_j1 : core_clock_type 
				channel get_CLID_GasDetected : core_clock_type 
				channel get_CLID_NoGas : core_clock_type 
				--channel increment__
				
				CLID_Analysis_clock_type(id__,
						          const_GasAnalysis_thr) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_Reading_clock_type(id__,
						          const_GasAnalysis_thr) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_j1_clock_type(id__,
						          const_GasAnalysis_thr) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_GasDetected_clock_type(id__,
						          const_GasAnalysis_thr) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_NoGas_clock_type(id__,
						          const_GasAnalysis_thr) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				
			
					-- Nodes --
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i1
					module i1
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__,
									    const_GasAnalysis_thr) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
							
							VS_O__(id__,
									    const_GasAnalysis_thr) = D__(id__,
									    const_GasAnalysis_thr)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: GasDetected
					module GasDetected
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_GasAnalysis_thr) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(share__choice(get_gs?gs -> true & (share__choice(set_ins!Chemical_intensity(gs) -> SKIP)))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_GasAnalysis_thr) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(share__choice(get_gs?gs -> true & (share__choice(set_ins!Chemical_intensity(gs) -> SKIP)))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_GasAnalysis_thr) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- Final state: j1
					module j1
					
					exports
					
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							D__(id__,
									    const_GasAnalysis_thr) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
									
									Entering 	= entered -> SKIP ; Active
									Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
									Interrupted	= share__choice(exit -> exited -> Inactive)
								within
									Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_GasAnalysis_thr) = D__(id__,
									    const_GasAnalysis_thr)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Reading
					module Reading
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_GasAnalysis_thr) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_GasAnalysis_thr) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_GasAnalysis_thr) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Analysis
					module Analysis
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_GasAnalysis_thr) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((share__choice(share__choice(get_gs?gs -> true & (share__choice(set_sts!Chemical_analysis(gs) -> SKIP)))) ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_GasAnalysis_thr) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((share__choice(share__choice(get_gs?gs -> true & (share__choice(set_sts!Chemical_analysis(gs) -> SKIP)))) ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_GasAnalysis_thr) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: NoGas
					module NoGas
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_GasAnalysis_thr) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_GasAnalysis_thr) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_GasAnalysis_thr) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					-- END of Nodes --
					
					Timed(OneStep) {
					-- Operation calls --
					-- Only the undefined operations are declared here.
					-- If the state machine is in isolation, all required operations will be undefined.
					-- If it is in the context of a controller, the required operations not provided by the
					-- controller will be declared here, and the defined operations will be defined in the
					-- context of the Controller module, and therefore within scope of the state machine module.
					
					-- END of Operation calls --
				
					-- STM processes
					STM(id__,
							    const_GasAnalysis_thr) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful(id__,
										    const_GasAnalysis_thr) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_GasAnalysis_thr))
					)\sharedVarHide
					
					STM_VS_O(id__,
							    const_GasAnalysis_thr) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful_VS_O(id__,
										    const_GasAnalysis_thr) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_GasAnalysis_thr))
					)\sharedVarHide
					
					-- Transitions
					Transitions(id__,
							    const_GasAnalysis_thr) = ((let
						Trans = share__choice(get_ins?ins -> get_sts?sts -> TimeOut_1(
							 (share__ -> SKIP
							 [] dbisim((true)&(internal__!NID_i1 -> SKIP ;  ((share__choice(true & (share__choice(set_gs!<> -> SKIP)));share__choice(true & (share__choice(set_anl!Chemical_Angle_Front -> SKIP))) ; Reading::enter -> SKIP))))
							 [] dbisim((true)&(gas__!NID_Reading.in?gs:{gs|gs <- LSeq(Chemical_GasSensor,2), true} -> share__choice(set_gs!gs -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Analysis::enter -> SKIP)))
							 [] dbisim((true)&(internal__!NID_NoGas -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Reading::enter -> SKIP)))
							 [] dbisim(((sts==Chemical_Status_noGas))&(internal__!NID_Analysis -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(resume.out -> SKIP)) ; NoGas::enter -> SKIP)))
							 [] dbisim(((sts==Chemical_Status_gasD))&(internal__!NID_Analysis -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; GasDetected::enter -> SKIP)))
							 [] dbisim((Chemical_goreq(ins,const_GasAnalysis_thr))&(internal__!NID_GasDetected -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(stop.out -> SKIP)) ; j1::enter -> SKIP)))
							 [] dbisim(((not (Chemical_goreq(ins,const_GasAnalysis_thr))))&(internal__!NID_GasDetected -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(share__choice(get_gs?gs -> true & (share__choice(set_anl!Chemical_location(gs) -> SKIP))));share__choice(get_anl?anl -> true&(share__choice(turn.out!anl -> SKIP))) ; Reading::enter -> SKIP)))
							 []
							 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
							 []
							 terminate -> SKIP
							 )
						,SKIP);Trans
						)
					within
						Trans [|{terminate}|> SKIP
					)
					)
					
					-- Stateful
					-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
					
					-- Named process definitions
					MachineBody(id__,
							    const_GasAnalysis_thr) = 
						dbisim((
						let
							finalNodesEntered = {|j1::entered|}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i1::enter,
								GasDetected::enter,
								j1::enter,
								Reading::enter,
								Analysis::enter,
								NoGas::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i1,gas__.NID_Reading.in,internal__.NID_NoGas,internal__.NID_Analysis,internal__.NID_Analysis,internal__.NID_GasDetected,internal__.NID_GasDetected|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i1::D__(id__,
									   		    const_GasAnalysis_thr)
									   [| { share__, terminate } |] (
									   GasDetected::D__(id__,
									   		    const_GasAnalysis_thr)
									   [| { share__, terminate } |] (
									   j1::D__(id__,
									   		    const_GasAnalysis_thr)
									   [| { share__, terminate } |] (
									   Reading::D__(id__,
									   		    const_GasAnalysis_thr)
									   [| { share__, terminate } |] (
									   Analysis::D__(id__,
									   		    const_GasAnalysis_thr)
									   [| { share__, terminate } |] (
									   NoGas::D__(id__,
									   		    const_GasAnalysis_thr)
									   )
									   )
									   )
									   )
									   )
									 )
									 [[GasDetected::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_GasDetected,internal__.NID_GasDetected|}]]
									 [[j1::interrupt <- x__ | x__ <- {|interrupt|}]]
									 [[Reading::interrupt <- x__ | x__ <- {|interrupt,gas__.NID_Reading.in|}]]
									 [[Analysis::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Analysis,internal__.NID_Analysis|}]]
									 [[NoGas::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_NoGas|}]]
									 [[i1::interrupt <- x__ | x__ <- {|internal__.NID_i1|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_gs |} ]] 
									  [[set_ins <- setL_ins,set_sts <- setL_sts]]
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setL_ins
									 			,setL_sts
									 			,setR_gs
									 			|}) |]
									 ((i1::enter -> Transitions(id__,
									 		    const_GasAnalysis_thr))
									  [[ share__ <- x__ | x__ <- {| share__,setL_ins,setL_sts |} ]]
									  [[set_gs <- setR_gs]]
									 )
									)[[setL_ins <- set_ins,setL_sts <- set_sts]]
									 [[setR_gs <- set_gs]]
									)
								)
								 \ hideSet)
								[[
									gas__.x____ <- gas,
									resume__.x____ <- resume,
									turn__.x____ <- turn,
									stop__.x____ <- stop
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_GasAnalysis_thr)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour(id__,
							    const_GasAnalysis_thr) = 
						dbisim((let
							stateClockSync = {|get_CLID_Analysis,Analysis::entered,get_CLID_Reading,Reading::entered,get_CLID_GasDetected,GasDetected::entered,get_CLID_NoGas,NoGas::entered|}
						 within
							(MachineBody(id__,
									    const_GasAnalysis_thr) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_GasAnalysis_thr)) \ union(stateClockSync,enteredSS)
						)
						)
					
					IteratedBehaviour(id__,
							    const_GasAnalysis_thr) = 
						dbisim((let
							stateClockSync = {|get_CLID_Analysis,Analysis::entered,get_CLID_Reading,Reading::entered,get_CLID_GasDetected,GasDetected::entered,get_CLID_NoGas,NoGas::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															MachineBody(id__,
																	    const_GasAnalysis_thr)
															[| {|get_CLID_NoGas,NoGas::entered,terminate|} |]
															dbisim(Clock_CLID_NoGas(id__,0,
																	          const_GasAnalysis_thr))
														)\{|get_CLID_NoGas|}
													)
													[| {|get_CLID_GasDetected,GasDetected::entered,terminate|} |]
													dbisim(Clock_CLID_GasDetected(id__,0,
															          const_GasAnalysis_thr))
												)\{|get_CLID_GasDetected|}
											)
											[| {|get_CLID_Reading,Reading::entered,terminate|} |]
											dbisim(Clock_CLID_Reading(id__,0,
													          const_GasAnalysis_thr))
										)\{|get_CLID_Reading|}
									)
									[| {|get_CLID_Analysis,Analysis::entered,terminate|} |]
									dbisim(Clock_CLID_Analysis(id__,0,
											          const_GasAnalysis_thr))
								)\{|get_CLID_Analysis|}
							)
							) \ union(stateClockSync,enteredSS)
						)
						)
					
					Stateful(id__,
							    const_GasAnalysis_thr) = 
						((let
							getsetLocalChannels = {|get_sts,set_sts,
							get_gs,set_gs,
							get_ins,set_ins,
							get_anl,set_anl|}
							clockSync = {||}
						within
							(Behaviour(id__,
									    const_GasAnalysis_thr) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_GasAnalysis_thr) [| {terminate} |] Clocks(id__,
							 		          const_GasAnalysis_thr))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful(id__,
							    const_GasAnalysis_thr) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										dbisim(
											sbisim(
												dbisim(
													sbisim(
														IteratedBehaviour(id__,
																    const_GasAnalysis_thr)
														[| {|get_anl,set_anl,terminate|} |]
														Memory_anl(Chemical_Angle_Left)
													)\{|get_anl,set_anl|}
												)
												[| {|get_ins,set_ins,terminate|} |]
												Memory_ins(0)
											)\{|get_ins,set_ins|}
										)
										[| {|get_gs,set_gs,terminate|} |]
										Memory_gs(<>)
									)\{|get_gs,set_gs|}
								)
								[| {|get_sts,set_sts,terminate|} |]
								Memory_sts(Chemical_Status_noGas)
							)\{|get_sts,set_sts|}
						)
						)
					
					-- Visible counterparts
					MachineBody_VS_O(id__,
							    const_GasAnalysis_thr) = 
						dbisim((
						let
							finalNodesEntered = {|j1::entered|}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i1::enter,
								GasDetected::enter,
								j1::enter,
								Reading::enter,
								Analysis::enter,
								NoGas::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i1,gas__.NID_Reading.in,internal__.NID_NoGas,internal__.NID_Analysis,internal__.NID_Analysis,internal__.NID_GasDetected,internal__.NID_GasDetected|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i1::VS_O__(id__,
									   		    const_GasAnalysis_thr)
									   [| { share__, terminate } |] (
									   GasDetected::VS_O__(id__,
									   		    const_GasAnalysis_thr)
									   [| { share__, terminate } |] (
									   j1::VS_O__(id__,
									   		    const_GasAnalysis_thr)
									   [| { share__, terminate } |] (
									   Reading::VS_O__(id__,
									   		    const_GasAnalysis_thr)
									   [| { share__, terminate } |] (
									   Analysis::VS_O__(id__,
									   		    const_GasAnalysis_thr)
									   [| { share__, terminate } |] (
									   NoGas::VS_O__(id__,
									   		    const_GasAnalysis_thr)
									   )
									   )
									   )
									   )
									   )
									 )
									 [[GasDetected::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_GasDetected,internal__.NID_GasDetected|}]]
									 [[j1::interrupt <- x__ | x__ <- {|interrupt|}]]
									 [[Reading::interrupt <- x__ | x__ <- {|interrupt,gas__.NID_Reading.in|}]]
									 [[Analysis::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Analysis,internal__.NID_Analysis|}]]
									 [[NoGas::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_NoGas|}]]
									 [[i1::interrupt <- x__ | x__ <- {|internal__.NID_i1|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_gs |} ]] 
									  [[set_ins <- setL_ins,set_sts <- setL_sts]]
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setL_ins
									 			,setL_sts
									 			,setR_gs
									 			|}) |]
									 ((i1::enter -> Transitions(id__,
									 		    const_GasAnalysis_thr))
									  [[ share__ <- x__ | x__ <- {| share__,setL_ins,setL_sts |} ]]
									  [[set_gs <- setR_gs]]
									 )
									)[[setL_ins <- set_ins,setL_sts <- set_sts]]
									 [[setR_gs <- set_gs]]
									)
								)
								 \ hideSet)
								[[
									gas__.x____ <- gas,
									resume__.x____ <- resume,
									turn__.x____ <- turn,
									stop__.x____ <- stop
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_GasAnalysis_thr)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour_VS_O(id__,
							    const_GasAnalysis_thr) = 
						dbisim((let
							stateClockSync = {|get_CLID_Analysis,Analysis::entered,get_CLID_Reading,Reading::entered,get_CLID_GasDetected,GasDetected::entered,get_CLID_NoGas,NoGas::entered|}
						 within
							(MachineBody_VS_O(id__,
									    const_GasAnalysis_thr) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_GasAnalysis_thr)) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					IteratedBehaviour_VS_O(id__,
							    const_GasAnalysis_thr) = 
						dbisim((let
							stateClockSync = {|get_CLID_Analysis,Analysis::entered,get_CLID_Reading,Reading::entered,get_CLID_GasDetected,GasDetected::entered,get_CLID_NoGas,NoGas::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															MachineBody_VS_O(id__,
																	    const_GasAnalysis_thr)
															[| {|get_CLID_NoGas,NoGas::entered,terminate|} |]
															dbisim(Clock_CLID_NoGas(id__,0,
																	          const_GasAnalysis_thr))
														)\{|get_CLID_NoGas|}
													)
													[| {|get_CLID_GasDetected,GasDetected::entered,terminate|} |]
													dbisim(Clock_CLID_GasDetected(id__,0,
															          const_GasAnalysis_thr))
												)\{|get_CLID_GasDetected|}
											)
											[| {|get_CLID_Reading,Reading::entered,terminate|} |]
											dbisim(Clock_CLID_Reading(id__,0,
													          const_GasAnalysis_thr))
										)\{|get_CLID_Reading|}
									)
									[| {|get_CLID_Analysis,Analysis::entered,terminate|} |]
									dbisim(Clock_CLID_Analysis(id__,0,
											          const_GasAnalysis_thr))
								)\{|get_CLID_Analysis|}
							)
							) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					Stateful_VS_O(id__,
							    const_GasAnalysis_thr) = 
						dbisim((let
							getsetLocalChannels = {|get_sts,set_sts,
							get_gs,set_gs,
							get_ins,set_ins,
							get_anl,set_anl|}
							clockSync = {||}
						within
							(Behaviour_VS_O(id__,
									    const_GasAnalysis_thr) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_GasAnalysis_thr) [| {terminate} |] Clocks(id__,
							 		          const_GasAnalysis_thr))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful_VS_O(id__,
							    const_GasAnalysis_thr) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										dbisim(
											sbisim(
												dbisim(
													sbisim(
														IteratedBehaviour_VS_O(id__,
																    const_GasAnalysis_thr)
														[| {|get_anl,set_anl,terminate|} |]
														Memory_anl(Chemical_Angle_Left)
													)\{|get_anl,set_anl|}
												)
												[| {|get_ins,set_ins,terminate|} |]
												Memory_ins(0)
											)\{|get_ins,set_ins|}
										)
										[| {|get_gs,set_gs,terminate|} |]
										Memory_gs(<>)
									)\{|get_gs,set_gs|}
								)
								[| {|get_sts,set_sts,terminate|} |]
								Memory_sts(Chemical_Status_noGas)
							)\{|get_sts,set_sts|}
						)
						)
					
					-- END
					
					-- Memory
					-- Memory variables
					Memory_sts(sts) =
						get_sts!sts -> Memory_sts(sts)
						[]
						set_sts?x__ -> Memory_sts(x__)
						[]
						terminate -> SKIP
					Memory_gs(gs) =
						get_gs!gs -> Memory_gs(gs)
						[]
						set_gs?x__ -> Memory_gs(x__)
						[]
						terminate -> SKIP
					Memory_ins(ins) =
						get_ins!ins -> Memory_ins(ins)
						[]
						set_ins?x__ -> Memory_ins(x__)
						[]
						terminate -> SKIP
					Memory_anl(anl) =
						get_anl!anl -> Memory_anl(anl)
						[]
						set_anl?x__ -> Memory_anl(x__)
						[]
						terminate -> SKIP
					
					-- varMemory process
					varMemory(id__,
							    const_GasAnalysis_thr) = Memory_sts(Chemical_Status_noGas)
					[| { terminate } |] (
					Memory_gs(<>)
					[| { terminate } |] (
					Memory_ins(0)
					[| { terminate } |] (
					Memory_anl(Chemical_Angle_Left)
					)
					)
					)
					
					getsetLocalChannels = {|get_sts,set_sts,get_gs,set_gs,get_ins,set_ins,get_anl,set_anl|}
					
					-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
					FVS__(id__,
							    const_GasAnalysis_thr) = STM_VS_O(id__,
							    const_GasAnalysis_thr) \ localClockResets
					D__(id__,
							    const_GasAnalysis_thr) = timed_priority(STM(id__,
							    const_GasAnalysis_thr) \ union(internal_events,localClockResets))
					O__(id__,
							    const_GasAnalysis_thr) = dbisim(D__(id__,
							    const_GasAnalysis_thr))
					VS__(id__,
							    const_GasAnalysis_thr) = FVS__(id__,
							    const_GasAnalysis_thr)
					VS_O__(id__,
							    const_GasAnalysis_thr) = dbisim(FVS__(id__,
							    const_GasAnalysis_thr))
					HEXT__(id__,
							    const_GasAnalysis_thr) = O__(id__,
							    const_GasAnalysis_thr) [|shared_variable_events|] SKIP
					FVS_C__(id__,
							    const_GasAnalysis_thr) = dbisim(timed_priority(STM(id__,
							    const_GasAnalysis_thr) \ internal_events))
					HUP__(id__,
							    const_GasAnalysis_thr) = timed_priority(O__(id__,
							    const_GasAnalysis_thr) [|{share__}|] SKIP)
					
					-- Clocks
					
					Clocks(id__,
							          const_GasAnalysis_thr) = terminate -> SKIP
					
					clockSync = {||}
					
					Clock_CLID_Analysis(id__,x__,
							          const_GasAnalysis_thr) = 
						TimeOut_1(
							Analysis::entered -> Clock_CLID_Analysis(id__,0,
									          const_GasAnalysis_thr)
							[]
							get_CLID_Analysis!x__ -> Clock_CLID_Analysis(id__,x__,
									          const_GasAnalysis_thr)
							[]
							terminate -> SKIP,Clock_CLID_Analysis(id__,clock_type_plus(x__,1,CLID_Analysis_clock_type(id__,
									          const_GasAnalysis_thr)),
									          const_GasAnalysis_thr))
					Clock_CLID_Reading(id__,x__,
							          const_GasAnalysis_thr) = 
						TimeOut_1(
							Reading::entered -> Clock_CLID_Reading(id__,0,
									          const_GasAnalysis_thr)
							[]
							get_CLID_Reading!x__ -> Clock_CLID_Reading(id__,x__,
									          const_GasAnalysis_thr)
							[]
							terminate -> SKIP,Clock_CLID_Reading(id__,clock_type_plus(x__,1,CLID_Reading_clock_type(id__,
									          const_GasAnalysis_thr)),
									          const_GasAnalysis_thr))
					Clock_CLID_GasDetected(id__,x__,
							          const_GasAnalysis_thr) = 
						TimeOut_1(
							GasDetected::entered -> Clock_CLID_GasDetected(id__,0,
									          const_GasAnalysis_thr)
							[]
							get_CLID_GasDetected!x__ -> Clock_CLID_GasDetected(id__,x__,
									          const_GasAnalysis_thr)
							[]
							terminate -> SKIP,Clock_CLID_GasDetected(id__,clock_type_plus(x__,1,CLID_GasDetected_clock_type(id__,
									          const_GasAnalysis_thr)),
									          const_GasAnalysis_thr))
					Clock_CLID_NoGas(id__,x__,
							          const_GasAnalysis_thr) = 
						TimeOut_1(
							NoGas::entered -> Clock_CLID_NoGas(id__,0,
									          const_GasAnalysis_thr)
							[]
							get_CLID_NoGas!x__ -> Clock_CLID_NoGas(id__,x__,
									          const_GasAnalysis_thr)
							[]
							terminate -> SKIP,Clock_CLID_NoGas(id__,clock_type_plus(x__,1,CLID_NoGas_clock_type(id__,
									          const_GasAnalysis_thr)),
									          const_GasAnalysis_thr))
					
					StateClocks(id__,
							          const_GasAnalysis_thr) = dbisim(Clock_CLID_Analysis(id__,0,
							          const_GasAnalysis_thr))
					[| { terminate } |] (
					dbisim(Clock_CLID_Reading(id__,0,
							          const_GasAnalysis_thr))
					[| { terminate } |] (
					dbisim(Clock_CLID_GasDetected(id__,0,
							          const_GasAnalysis_thr))
					[| { terminate } |] (
					dbisim(Clock_CLID_NoGas(id__,0,
							          const_GasAnalysis_thr))
					)
					)
					)
					
					stateClockSync = {|get_CLID_Analysis,Analysis::entered,get_CLID_Reading,Reading::entered,get_CLID_GasDetected,GasDetected::entered,get_CLID_NoGas,NoGas::entered|}
					
					-- Shared memory
					-- Shared memory variables
					
					-- sharedVarMemory process
					sharedVarMemory(id__,
							    const_GasAnalysis_thr) = terminate -> SKIP
					
					sharedVarSync = {||}
					
					sharedVarHide = {||}
					}
			endmodule
			
			Timed(OneStep) {
					-- undefined operations
					
					-- declaring controller memory
					Memory(id__) = SKIP
					
					D__(id__,
							    const_MainController_stm_ref0_thr) = prioritise(	((
							let
								const_GasAnalysis_thr = const_MainController_stm_ref0_thr
							within 
							stm_ref0::D__(id__,
									    const_GasAnalysis_thr)[[
								stm_ref0::terminate <- terminate,
								stm_ref0::gas <- gas,
								stm_ref0::turn <- turn,
								stm_ref0::stop <- stop,
								stm_ref0::resume <- resume
							]]
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						Memory(id__)
					)
					\ union(
						{|
						|},
						{|
						|}
					)
					[|{|terminate|}|>SKIP
					,<visibleMemoryEvents,{tock}>)
					
					-- VS version
					VS__(id__,
							    const_MainController_stm_ref0_thr) = prioritise(	((
							let
								const_GasAnalysis_thr = const_MainController_stm_ref0_thr
							within 
							stm_ref0::VS__(id__,
									    const_GasAnalysis_thr)[[
								stm_ref0::terminate <- terminate,
								stm_ref0::gas <- gas,
								stm_ref0::turn <- turn,
								stm_ref0::stop <- stop,
								stm_ref0::resume <- resume
							]]
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						Memory(id__)
					)
					\ union(
						{|
						|},
						{|
						|}
					)
					[|{|terminate|}|>SKIP
					,<visibleMemoryEvents,{tock}>)
				
					-- O version (optimised) THESE TWO PROCESSES SHOULD BE KEPT IN SYNC WITH THE ABOVE TWO
					O__(id__,
							    const_MainController_stm_ref0_thr) = dbisim(prioritise(	((
							let
								const_GasAnalysis_thr = const_MainController_stm_ref0_thr
							within 
							stm_ref0::O__(id__,
									    const_GasAnalysis_thr)[[
								stm_ref0::terminate <- terminate,
								stm_ref0::gas <- gas,
								stm_ref0::turn <- turn,
								stm_ref0::stop <- stop,
								stm_ref0::resume <- resume
							]]
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						dbisim(Memory(id__))
					)
					\ union(
						{|
						|},
						{|
						|}
					)
					[|{|terminate|}|>SKIP
					,<visibleMemoryEvents,{tock}>))
									
					-- VS_O version
					VS_O__(id__,
							    const_MainController_stm_ref0_thr) = dbisim(prioritise(	((
							let
								const_GasAnalysis_thr = const_MainController_stm_ref0_thr
							within 
							stm_ref0::VS_O__(id__,
									    const_GasAnalysis_thr)[[
								stm_ref0::terminate <- terminate,
								stm_ref0::gas <- gas,
								stm_ref0::turn <- turn,
								stm_ref0::stop <- stop,
								stm_ref0::resume <- resume
							]]
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						dbisim(Memory(id__))
					)
					\ union(
						{|
						|},
						{|
						|}
					)
					[|{|terminate|}|>SKIP
					,<visibleMemoryEvents,{tock}>))
				
					HEXT(id__,
							    const_MainController_stm_ref0_thr) = O__(id__,
							    const_MainController_stm_ref0_thr) [|shared_variable_events|] SKIP			
			}
	
		endmodule
	
	Timed(OneStep) {
		visibleMemoryEvents = {||}
		
		-- declaring module memory
		Memory(id__) = SKIP
		
		D__(id__,
				    const_MicroController_stm_ref0_lv,
				    const_MicroController_stm_ref0_evadeTime,
				    const_MicroController_stm_ref0_stuckPeriod,
				    const_MicroController_stm_ref0_stuckDist,
				    const_MicroController_stm_ref0_outPeriod,
				    const_MainController_stm_ref0_thr,
				   	const_MicroController_op_ref0_lv) = prioritise(let
			Buffer0(<v>) = 
				ctrl_ref1::turn.out?x -> Buffer0(<x>)
				[]
				ctrl_ref0::turn.in!v -> Buffer0(<>)
			Buffer0(<>) = ctrl_ref1::turn.out?x -> Buffer0(<x>)
			
		within
			(
				(
					(Buffer0(<>)
					)
						[|{|ctrl_ref0::turn,ctrl_ref1::turn|}|]
					(
						(
							(
								ctrl_ref0::D__(id__,
										    const_MicroController_stm_ref0_lv,
										    const_MicroController_stm_ref0_evadeTime,
										    const_MicroController_stm_ref0_stuckPeriod,
										    const_MicroController_stm_ref0_stuckDist,
										    const_MicroController_stm_ref0_outPeriod,
										   	const_MicroController_op_ref0_lv)[[
									ctrl_ref0::terminate <- terminate,
									ctrl_ref0::stop.in <- ctrl_ref1::stop.out,
									ctrl_ref0::stop.out <- ctrl_ref1::stop.in,
									ctrl_ref0::obstacle <- obstacle,
									ctrl_ref0::flag <- flag,
									ctrl_ref0::resume.in <- ctrl_ref1::resume.out,
									ctrl_ref0::resume.out <- ctrl_ref1::resume.in,
									ctrl_ref0::odometer <- odometer,
									ctrl_ref0::moveCall <- moveCall,
									ctrl_ref0::randomWalkCall <- randomWalkCall,
									ctrl_ref0::shortRandomWalkCall <- shortRandomWalkCall
								]]
							)
								[|{|terminate, ctrl_ref1::stop, ctrl_ref1::resume|}|]
							(
								ctrl_ref1::D__(id__,
										    const_MainController_stm_ref0_thr)[[
									ctrl_ref1::terminate <- terminate,
									ctrl_ref1::gas <- gas
								]]
							)
						)
						\
						diff(
							{|terminate, ctrl_ref1::stop, ctrl_ref1::resume|},
							{|terminate|}
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						Memory(id__)
					)
				)
				\ Union({
					{|
						ctrl_ref0::turn,
						ctrl_ref1::turn
					|},
					{|
					|},
					{|
					|}
				})
				[|{|terminate|}|>SKIP
			)
			\{|terminate|}
		,<visibleMemoryEvents,{tock}>)
		
		-- visible state equivalent
		
		VS__(id__,
				    const_MicroController_stm_ref0_lv,
				    const_MicroController_stm_ref0_evadeTime,
				    const_MicroController_stm_ref0_stuckPeriod,
				    const_MicroController_stm_ref0_stuckDist,
				    const_MicroController_stm_ref0_outPeriod,
				    const_MainController_stm_ref0_thr,
				   	const_MicroController_op_ref0_lv) = prioritise(let
			Buffer0(<v>) = 
				ctrl_ref1::turn.out?x -> Buffer0(<x>)
				[]
				ctrl_ref0::turn.in!v -> Buffer0(<>)
			Buffer0(<>) = ctrl_ref1::turn.out?x -> Buffer0(<x>)
			
		within
			(
				(
					(Buffer0(<>)
					)
						[|{|ctrl_ref0::turn,ctrl_ref1::turn|}|]
					(
						(
							(
								ctrl_ref0::VS__(id__,
										    const_MicroController_stm_ref0_lv,
										    const_MicroController_stm_ref0_evadeTime,
										    const_MicroController_stm_ref0_stuckPeriod,
										    const_MicroController_stm_ref0_stuckDist,
										    const_MicroController_stm_ref0_outPeriod,
										   	const_MicroController_op_ref0_lv)[[
									ctrl_ref0::terminate <- terminate,
									ctrl_ref0::stop.in <- ctrl_ref1::stop.out,
									ctrl_ref0::stop.out <- ctrl_ref1::stop.in,
									ctrl_ref0::obstacle <- obstacle,
									ctrl_ref0::flag <- flag,
									ctrl_ref0::resume.in <- ctrl_ref1::resume.out,
									ctrl_ref0::resume.out <- ctrl_ref1::resume.in,
									ctrl_ref0::odometer <- odometer,
									ctrl_ref0::moveCall <- moveCall,
									ctrl_ref0::randomWalkCall <- randomWalkCall,
									ctrl_ref0::shortRandomWalkCall <- shortRandomWalkCall
								]]
							)
								[|{|terminate, ctrl_ref1::stop, ctrl_ref1::resume|}|]
							(
								ctrl_ref1::VS__(id__,
										    const_MainController_stm_ref0_thr)[[
									ctrl_ref1::terminate <- terminate,
									ctrl_ref1::gas <- gas
								]]
							)
						)
						\
						diff(
							{|terminate, ctrl_ref1::stop, ctrl_ref1::resume|},
							{|terminate|}
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						Memory(id__)
					)
				)
				\ Union({
					{|
						ctrl_ref0::turn,
						ctrl_ref1::turn
					|},
					{|
					|},
					{|
					|}
				})
				[|{|terminate|}|>SKIP
			)
			\{|terminate|}
		,<visibleMemoryEvents,{tock}>)
		
		-- O version (optimised)
		
		O__(id__,
				    const_MicroController_stm_ref0_lv,
				    const_MicroController_stm_ref0_evadeTime,
				    const_MicroController_stm_ref0_stuckPeriod,
				    const_MicroController_stm_ref0_stuckDist,
				    const_MicroController_stm_ref0_outPeriod,
				    const_MainController_stm_ref0_thr,
				   	const_MicroController_op_ref0_lv) = dbisim(prioritise(let
			Buffer0(<v>) = 
				ctrl_ref1::turn.out?x -> Buffer0(<x>)
				[]
				ctrl_ref0::turn.in!v -> Buffer0(<>)
			Buffer0(<>) = ctrl_ref1::turn.out?x -> Buffer0(<x>)
			
		within
			(
				(
					(Buffer0(<>)
					)
						[|{|ctrl_ref0::turn,ctrl_ref1::turn|}|]
					(
						(
							(
								ctrl_ref0::O__(id__,
										    const_MicroController_stm_ref0_lv,
										    const_MicroController_stm_ref0_evadeTime,
										    const_MicroController_stm_ref0_stuckPeriod,
										    const_MicroController_stm_ref0_stuckDist,
										    const_MicroController_stm_ref0_outPeriod,
										   	const_MicroController_op_ref0_lv)[[
									ctrl_ref0::terminate <- terminate,
									ctrl_ref0::stop.in <- ctrl_ref1::stop.out,
									ctrl_ref0::stop.out <- ctrl_ref1::stop.in,
									ctrl_ref0::obstacle <- obstacle,
									ctrl_ref0::flag <- flag,
									ctrl_ref0::resume.in <- ctrl_ref1::resume.out,
									ctrl_ref0::resume.out <- ctrl_ref1::resume.in,
									ctrl_ref0::odometer <- odometer,
									ctrl_ref0::moveCall <- moveCall,
									ctrl_ref0::randomWalkCall <- randomWalkCall,
									ctrl_ref0::shortRandomWalkCall <- shortRandomWalkCall
								]]
							)
								[|{|terminate, ctrl_ref1::stop, ctrl_ref1::resume|}|]
							(
								ctrl_ref1::O__(id__,
										    const_MainController_stm_ref0_thr)[[
									ctrl_ref1::terminate <- terminate,
									ctrl_ref1::gas <- gas
								]]
							)
						)
						\
						diff(
							{|terminate, ctrl_ref1::stop, ctrl_ref1::resume|},
							{|terminate|}
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						dbisim(Memory(id__))
					)
				)
				\ Union({
					{|
						ctrl_ref0::turn,
						ctrl_ref1::turn
					|},
					{|
					|},
					{|
					|}
				})
				[|{|terminate|}|>SKIP
			)
			\{|terminate|}
		,<visibleMemoryEvents,{tock}>))
		
		-- visible state optimised equivalent
		
		VS_O__(id__,
				    const_MicroController_stm_ref0_lv,
				    const_MicroController_stm_ref0_evadeTime,
				    const_MicroController_stm_ref0_stuckPeriod,
				    const_MicroController_stm_ref0_stuckDist,
				    const_MicroController_stm_ref0_outPeriod,
				    const_MainController_stm_ref0_thr,
				   	const_MicroController_op_ref0_lv) = dbisim(prioritise(let
			Buffer0(<v>) = 
				ctrl_ref1::turn.out?x -> Buffer0(<x>)
				[]
				ctrl_ref0::turn.in!v -> Buffer0(<>)
			Buffer0(<>) = ctrl_ref1::turn.out?x -> Buffer0(<x>)
			
		within
			(
				(
					(Buffer0(<>)
					)
						[|{|ctrl_ref0::turn,ctrl_ref1::turn|}|]
					(
						(
							(
								ctrl_ref0::VS_O__(id__,
										    const_MicroController_stm_ref0_lv,
										    const_MicroController_stm_ref0_evadeTime,
										    const_MicroController_stm_ref0_stuckPeriod,
										    const_MicroController_stm_ref0_stuckDist,
										    const_MicroController_stm_ref0_outPeriod,
										   	const_MicroController_op_ref0_lv)[[
									ctrl_ref0::terminate <- terminate,
									ctrl_ref0::stop.in <- ctrl_ref1::stop.out,
									ctrl_ref0::stop.out <- ctrl_ref1::stop.in,
									ctrl_ref0::obstacle <- obstacle,
									ctrl_ref0::flag <- flag,
									ctrl_ref0::resume.in <- ctrl_ref1::resume.out,
									ctrl_ref0::resume.out <- ctrl_ref1::resume.in,
									ctrl_ref0::odometer <- odometer,
									ctrl_ref0::moveCall <- moveCall,
									ctrl_ref0::randomWalkCall <- randomWalkCall,
									ctrl_ref0::shortRandomWalkCall <- shortRandomWalkCall
								]]
							)
								[|{|terminate, ctrl_ref1::stop, ctrl_ref1::resume|}|]
							(
								ctrl_ref1::VS_O__(id__,
										    const_MainController_stm_ref0_thr)[[
									ctrl_ref1::terminate <- terminate,
									ctrl_ref1::gas <- gas
								]]
							)
						)
						\
						diff(
							{|terminate, ctrl_ref1::stop, ctrl_ref1::resume|},
							{|terminate|}
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						dbisim(Memory(id__))
					)
				)
				\ Union({
					{|
						ctrl_ref0::turn,
						ctrl_ref1::turn
					|},
					{|
					|},
					{|
					|}
				})
				[|{|terminate|}|>SKIP
			)
			\{|terminate|}
		,<visibleMemoryEvents,{tock}>))
		
		-- O version (optimised) with visible assignments
		
		AS_O__(id__,
				    const_MicroController_stm_ref0_lv,
				    const_MicroController_stm_ref0_evadeTime,
				    const_MicroController_stm_ref0_stuckPeriod,
				    const_MicroController_stm_ref0_stuckDist,
				    const_MicroController_stm_ref0_outPeriod,
				    const_MainController_stm_ref0_thr,
				   	const_MicroController_op_ref0_lv) = dbisim(let
			Buffer0(<v>) = 
				ctrl_ref1::turn.out?x -> Buffer0(<x>)
				[]
				ctrl_ref0::turn.in!v -> Buffer0(<>)
			Buffer0(<>) = ctrl_ref1::turn.out?x -> Buffer0(<x>)
			
		within
			(
				(
					(Buffer0(<>)
					)
						[|{|ctrl_ref0::turn,ctrl_ref1::turn|}|]
					(
						(
							(
								ctrl_ref0::O__(id__,
										    const_MicroController_stm_ref0_lv,
										    const_MicroController_stm_ref0_evadeTime,
										    const_MicroController_stm_ref0_stuckPeriod,
										    const_MicroController_stm_ref0_stuckDist,
										    const_MicroController_stm_ref0_outPeriod,
										   	const_MicroController_op_ref0_lv)[[
									ctrl_ref0::terminate <- terminate,
									ctrl_ref0::stop.in <- ctrl_ref1::stop.out,
									ctrl_ref0::stop.out <- ctrl_ref1::stop.in,
									ctrl_ref0::obstacle <- obstacle,
									ctrl_ref0::flag <- flag,
									ctrl_ref0::resume.in <- ctrl_ref1::resume.out,
									ctrl_ref0::resume.out <- ctrl_ref1::resume.in,
									ctrl_ref0::odometer <- odometer,
									ctrl_ref0::moveCall <- moveCall,
									ctrl_ref0::randomWalkCall <- randomWalkCall,
									ctrl_ref0::shortRandomWalkCall <- shortRandomWalkCall
								]]
							)
								[|{|terminate, ctrl_ref1::stop, ctrl_ref1::resume|}|]
							(
								ctrl_ref1::O__(id__,
										    const_MainController_stm_ref0_thr)[[
									ctrl_ref1::terminate <- terminate,
									ctrl_ref1::gas <- gas
								]]
							)
						)
						\
						diff(
							{|terminate, ctrl_ref1::stop, ctrl_ref1::resume|},
							{|terminate|}
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						dbisim(Memory(id__))
					)
				)
				\ Union({
					{|
						ctrl_ref0::turn,
						ctrl_ref1::turn
					|},
					{|
					|},
					{|
					|}
				})
				[|{|terminate|}|>SKIP
			)
			\{|terminate|}
		)
	}
	
endmodule



module OP_shortRandomWalk
exports
	Timed(OneStep) {
		-- These definitions are needed to make the structure of an incompletely defined operation compatible with that of fully defined operations
		MemoryTransitions(id__) = STOP -- this is STOP because MemoryTransitions is put in a choice with the state machine's MemoryTransitions. if it were SKIP, a divergence would be introduced.
		MemoryVariablesSyncSet = {}
		MemoryVariablesHideSet = {}
		MachineMemorySyncSet = {}
		MachineMemoryHidingSet = {}
		channel internal__
		D__(id__) = let
			AUX(N) = 
				if (N == 0) then SKIP else SKIP
				
		within AUX(shortRandomWalk_BOUND)
		
		O__(id__) = D__(id__)
		HUP__(id__) = D__(id__)
	}
endmodule
module OP_move
exports
	Timed(OneStep) {
		-- These definitions are needed to make the structure of an incompletely defined operation compatible with that of fully defined operations
		MemoryTransitions(id__) = STOP -- this is STOP because MemoryTransitions is put in a choice with the state machine's MemoryTransitions. if it were SKIP, a divergence would be introduced.
		MemoryVariablesSyncSet = {}
		MemoryVariablesHideSet = {}
		MachineMemorySyncSet = {}
		MachineMemoryHidingSet = {}
		channel internal__
		D__(id__,
					param_lv,
					param_a) = let
			AUX(N) = 
				if (N == 0) then SKIP else SKIP
				
		within AUX(move_BOUND)
		
		O__(id__,
					param_lv,
					param_a) = D__(id__,
					param_lv,
					param_a)
		HUP__(id__,
					param_lv,
					param_a) = D__(id__,
					param_lv,
					param_a)
	}
endmodule

