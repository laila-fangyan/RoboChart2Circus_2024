theory [*[%=z.eContents.select(s|s.instanceOf(Z!ZSect)).at(0).name%]_CirCus *]
	imports Axiomatic_Circus
begin
[%
z.eContents.println();
//z.eContents.select(s|s.instanceOf(Z!ZSect)).at(0).name.println();
z.type().println();
//z.allInstances().println();
//z.exprList.exprs.at(0).name.word.println();
//z.eContents.select(s|s.instanceOf(Z!ZSect)).paraList.println();
%]

[*
s3.entryaction.expr = [%=z.eContents.at(0).parseExpr()%]
*]


[%z.eContents.select(s|s.instanceOf(Z!ZSect)).at(0).paraList.paras.select(s|s.instanceOf(Z!ChannelPara)).println();
var channelparas = z.eContents.select(s|s.instanceOf(Z!ZSect)).at(0).paraList.paras.select(s|s.instanceOf(Z!ChannelPara));

for(chanpara in channelparas){
	var chandecl = chanpara.declList.decls.at(0);
	var chans = chandecl.channelNameList.names;%]
	
chantype [%=chanpara.name.word%] = 
	[%for(chan in chans){%]
	[%=chan.word%] [%if(chandecl.expr.name.word = "SYNCH"){%] :: unit [%} else{%] :: [%=chandecl.expr.name.word%][%}%]
	
	[%}
}%]

[*
[%var procparas = z.eContents.select(s|s.instanceOf(Z!ZSect)).at(0).paraList.paras.select(s|s.instanceOf(Z!ProcessPara));
procparas.println();
procparas.at(0).circusProcess.paraList.paras.at(0).circusAction.type().println();

procparas.at(0).circusProcess.paraList.paras.at(0).circusAction.actionList.circusActions.println();
procparas.at(0).circusProcess.paraList.paras.at(0).circusAction.leftAction.println();
procparas.at(0).circusProcess.paraList.paras.at(0).circusAction.rightAction.println();
for(procpara in procparas){
	procpara.circusProcess.parseProc();
}
%]*]
 

end


[%operation Z!ProcessPara parseProcPara(): String{
	//TO DO
}
%]


[%operation Z!ActionPara parseActionPara(): String{
	//TO DO
}
%]

[%operation Z!ChannelSetPara parseChannelSetPara(): String{
	//TO DO
}
%]


[%operation Z!CircusProcess parseProc(): String{
	if(self.instanceOf(Z!HideProcess)){
		return self.parseHideProcess();
	} else
	if(self.instanceOf(Z!RenameProcess)){
		return self.parseRenameProcess();
	} else 
	if(self.instanceOf(Z!ParallelProcess)){
		return self.parseParallelProcess();
	} else 
	if(self.instanceOf(Z!CallProcess)){
		return self.parseCallProcess();
	} 
}%]

[%operation Z!HideProcess parseHideProcess(): String{
	return  "(" + self.circusProcess.parseProc() + " \\ " + self.channelSet.parse() + ")";
}%]

[%operation Z!RenameProcess parseRenameProcess(): String{
	return  "(" + self.circusProcess.parseProc() + " [ " + self.assignmentPairs.parse() + " ])";
}%]

[%operation Z!ParallelProcess parseParallelProcess(): String{
	return  "(" + self.leftProcess.parseProc() + " \\<lbrakk> | " + self.channelSet.parse() + " | \\<rbrakk> " + self.rightProcess.parseProc() + ")";
}%]

[%operation Z!CallProcess parseCallProcess(): String{
	if(self.actuals.isDefined()){
		return  self.callExpr.name.word + "(" + self.actuals.parseZExprList() + ")";
	} else{
		return  self.callExpr.name.word;
	}
}%]




[%operation Z!CircusAction parseAction(){
	if(self.instanceOf(Z!PrefixingAction)){
		return self.parsePrefixingAction();
	} else
	if(self.instanceOf(Z!InterruptAction)){
		return self.parseInterruptAction();
	} else
	if(self.instanceOf(Z!ExtChoiceAction)){
		return self.parseExtChoiceAction();
	} else
	if(self.instanceOf(Z!CallAction)){
		return self.parseCallAction();
	} else
	if(self.instanceOf(Z!SeqAction)){
		return self.parseSeqAction();
	} else
	if(self.instanceOf(Z!GuardedAction)){
		return self.parseGuardedAction();
	} else
	if(self.instanceOf(Z!SkipAction)){
		return self.parseSkipAction();
	} else
	if(self.instanceOf(Z!ParamAction)){
		return self.parseParamAction();
	} else
	if(self.instanceOf(Z!ParallelAction)){
		return self.parseParallelAction();
	} else
	if(self.instanceOf(Z!HideAction)){
		return self.parseHideAction();
	} else
	if(self.instanceOf(Z!InterleaveActionIte)){
		return self.parseInterleaveActionIte();
	} else
	if(self.instanceOf(Z!ParallelActionIte)){
		return self.parseParallelActionIte();
	}
}%]


[%operation Z!PrefixingAction parsePrefixingAction(): String{
	return  "(" + self.communication.parse() + " \\<rightarrow> " + self.circusAction.parseAction() + ")";
}%]

[%operation Z!InterruptAction parseInterruptAction(): String{
	return  "(" + self.leftAction.parseAction() + " \\<triangle> " + self.rightAction.parseAction() + ")";
}%]

[%operation Z!ExtChoiceAction parseExtChoiceAction(): String{
	return  "(" + self.leftAction.parseAction() + " \\<box> " + self.rightAction.parseAction() + ")";
}%]


[%operation Z!CallAction parseCallAction(): String{
	if(self.exprList.isDefined()){
		return  self.name.word + "(" + self.exprList.parse() + ")";
	} else {
		return  self.name.word;
	}
}%]

[%operation Z!SeqAction parseSeqAction(): String{
	return  "(" + self.leftAction.parseAction() + "; " + self.rightAction.parseAction() + ")";
}%]

[%operation Z!GuardedAction parseGuardedAction(): String{
	return  "(" + self.pred.parse() + " & " + "(" + self.circusAction.parseAction() + ")" + ")";
	//The type of self.pred is MemPred, so self.pred.parse() points to "operation Z!MemPred parse()"
}%]

[%operation Z!SkipAction parseSkipAction(): String{
	return  "Skip";
}%]

[%operation Z!ParamAction parseParamAction(): String{
//	return  self.word;
}%]

[%operation Z!ParallelAction parseParallelAction(): String{
	return  "(" + self.leftAction.parseAction() + " \\<lbrakk> | " + self.channelSet.parse() + " | \\<rbrakk> " + self.rightAction.parseAction() + ")";
}%]

[%operation Z!HideAction parseHideAction(): String{
	return  "(" + self.circusAction.parseAction() + " \\ " + self.channelSet.parse() + ")";
}%]

[%operation Z!InterleaveActionIte parseInterleaveActionIte(): String{
//	return  self.word;
}%]

[%operation Z!ParallelActionIte parseParallelActionIte(): String{
//	return  self.word;
}%]





[%operation Z!ZName parse(): String{
	return  self.word;
}%]


[%operation Z!Communication parse(): String{
	var commu_str : String;

	if(self.commPattern = 0 or self.commPattern = 4){//commu.commPattern = Z!CommPattern#ChannelSet or Z!CommPattern#Synch;
		commu_str = self.channelExpr.parseExpr();
	} else
	
	if(self.commPattern = 1){//commu.commPattern = Z!CommPattern#Input;
		commu_str = self.channelExpr.parseExpr() + "?" + self.fieldList.fields.at(0).varialbeName.parse();
	} else
	
	if(self.commPattern = 3){//commu.commPattern = Z!CommPattern#Output;
		commu_str = self.channelExpr.parseExpr();
		var field = self.fieldList.fields.at(0);
		if(field.outputField = true){
			commu_str = commu_str + "!" + field.expr.parseExpr();
		} else
		if(field.outputField = false){
			commu_str = commu_str + "." + field.expr.parseExpr();
		} 
	} 
	
	return commu_str;
}%]

[*currently, we only create MemPred of Pred type in Circus models, other types pred is not generated.*]
[%operation Z!MemPred parse(): String{
	if(self.mixFix = true){
		return self.leftExpr.parseExpr();
	}
}%] 

[*currently in M2M, channelSet.expr may be of type createBasicChannelSetExpr or type RefExpr, the *]
[%operation Z!ChannelSet parse(): String{
	return self.expr.parseExpr();
}%]
  
  
 
[%operation Z!AssignmentPairs parse(): String{

	var pair_str : String;
	
	for(name in self.lhsElement){
		pair_str = name.parse();
		if (hasMore){
			pair_str = pair_str + ",";
		}
	}
	
	pair_str = pair_str + " ::= ";
	
	for(expr in self.rhsElement){
		pair_str = expr.parseExpr();
		if (hasMore){
			pair_str = pair_str + ",";
		}
	}
	
	return  pair_str;
}%]  


[*used in parseCallAction, e.g., the CallAciton is HiddenLayer(1,2,3), then parseCallAction returns "1,2,3" *]
[%operation Z!ZExprList parseZExprList(): String{
	var list_str : String;

	for(expr in self.exprs){
		list_str = expr.parseExpr();
		if (hasMore){
			list_str = list_str + ",";
		}
	}
	return list_str;
}%]  





[%operation Z!Expr parseExpr(): String{

	if(self.isTypeOf(ApplExpr) and self.leftExpr.name.word = "_less_"){
		return self.parseLessThan();
	} else
	if(self.isTypeOf(ApplExpr) and self.leftExpr.name.word = "_greater_"){
		return self.parseGreaterThan();
	} else
	if(self.isTypeOf(ApplExpr) and self.leftExpr.name.word = "_leq_"){
		return self.parseLessOrEqual();
	} else
	if(self.isTypeOf(ApplExpr) and self.leftExpr.name.word = "_geq_"){
		return self.parseGreaterOrEqual();
	} else
	if(self.isTypeOf(ApplExpr) and self.leftExpr.name.word = "_equals_"){
		return self.parseEquals();
	} else
	if(self.isTypeOf(ApplExpr) and self.leftExpr.name.word = "_nequals_"){
		return self.parseDifferent();
	} else
	if(self.isTypeOf(ApplExpr) and self.leftExpr.name.word = "_And_"){
		return self.parseAnd();
	} else
	if(self.isTypeOf(ApplExpr) and self.leftExpr.name.word = "_Or_"){
		return self.parseOr();
	} else
	if(self.isTypeOf(ApplExpr) and self.leftExpr.name.word = "_Equivalence_"){
		return self.parseIff();
	} else
	if(self.isTypeOf(ApplExpr) and self.leftExpr.name.word = "_Implies_"){
		return self.parseImplies();
	} else
	if(self.isTypeOf(ApplExpr) and self.leftExpr.name.word = "_+_"){
		return self.parsePlus();
	} else
	if(self.isTypeOf(ApplExpr) and self.leftExpr.name.word = "_-_"){
		return self.parseMinus();
	} else
	if(self.isTypeOf(ApplExpr) and self.leftExpr.name.word = "_*_"){
		return self.parseMult();
	} else
	if(self.isTypeOf(ApplExpr) and self.leftExpr.name.word = "_div_"){
		return self.parseDiv();
	} else
	if(self.isTypeOf(ApplExpr) and self.leftExpr.name.word = "_mod_"){
		return self.parseModulus();
	} else
	if(self.isTypeOf(ApplExpr) and self.leftExpr.name.word = "-_"){
		return self.parseNeg();
	} else
	if(self.isTypeOf(ApplExpr) and self.leftExpr.name.word = "Not_"){
		return self.parseNot();
	} else
//	if(self.isTypeOf(ApplExpr)){
//		return self.parseBinaryApplExpr();
//	} else
	if(self.isTypeOf(RefExpr)){
		return self.name.word.asString();
	} else
	if(self.isTypeOf(NumExpr)){
		return self.numeral.value.asString();
	} else
	if(self.isTypeOf(TupleExpr)){
//		return self.numeral.value.asString();
	} else
	if(self.isTypeOf(BasicChannelSetExpr)){
		return self.parseBasicChannelSetExpr();
	} 
}%]

[*
[%operation Z!ApplExpr parseUnaryApplExpr(): String{
	return  "(" + self.leftExpr.name.word + " " + self.rightExpr.parseExpr() +")";
}%]*]

[*
[%operation Z!ApplExpr parseBinaryApplExpr(): String{
	return  "("+ self.rightExpr.exprList.exprs.at(0).parseExpr() + " " + self.leftExpr.name.word + " " + self.rightExpr.exprList.exprs.at(1).parseExpr() +")";
}%]*]

[%operation Z!ApplExpr parseLessThan(): String{
	return  "("+ self.rightExpr.exprList.exprs.at(0).parseExpr() +" < " + self.rightExpr.exprList.exprs.at(1).parseExpr() +")";
}%]

[%operation Z!ApplExpr parseGreaterThan(): String{
	return  "("+ self.rightExpr.exprList.exprs.at(0).parseExpr() +" > " + self.rightExpr.exprList.exprs.at(1).parseExpr() +")";
}%]

[%operation Z!ApplExpr parseLessOrEqual(): String{
	return  "("+ self.rightExpr.exprList.exprs.at(0).parseExpr() +" \\<le> " + self.rightExpr.exprList.exprs.at(1).parseExpr() +")";
}%]

[%operation Z!ApplExpr parseGreaterOrEqual(): String{
	return  "("+ self.rightExpr.exprList.exprs.at(0).parseExpr() + " \\<ge> " + self.rightExpr.exprList.exprs.at(1).parseExpr() +")";
}%]

[%operation Z!ApplExpr parseEquals(): String{
	return  "("+ self.rightExpr.exprList.exprs.at(0).parseExpr() + " = " + self.rightExpr.exprList.exprs.at(1).parseExpr() +")";
}%]

[%operation Z!ApplExpr parseDifferent(): String{
	return  "("+ self.rightExpr.exprList.exprs.at(0).parseExpr() + " \\<noteq> " + self.rightExpr.exprList.exprs.at(1).parseExpr() +")";
}%]

[%operation Z!ApplExpr parseAnd(): String{
	return  "("+ self.rightExpr.exprList.exprs.at(0).parseExpr() + " \\<and> " + self.rightExpr.exprList.exprs.at(1).parseExpr() +")";
}%]

[%operation Z!ApplExpr parseOr(): String{
	return  "("+ self.rightExpr.exprList.exprs.at(0).parseExpr() + " \\<or> " + self.rightExpr.exprList.exprs.at(1).parseExpr() +")";
}%]

[%operation Z!ApplExpr parseIff(): String{
	return  "("+ self.rightExpr.exprList.exprs.at(0).parseExpr() + " ???????? " + self.rightExpr.exprList.exprs.at(1).parseExpr() +")";
}%]

[%operation Z!ApplExpr parseImplies(): String{
	return  "("+ self.rightExpr.exprList.exprs.at(0).parseExpr() +" => " + self.rightExpr.exprList.exprs.at(1).parseExpr() +")";
}%]

[%operation Z!ApplExpr parsePlus(): String{
	return  "("+ self.rightExpr.exprList.exprs.at(0).parseExpr() +" + " + self.rightExpr.exprList.exprs.at(1).parseExpr() +")";
}%]

[%operation Z!ApplExpr parseMinus(): String{
	return  "("+ self.rightExpr.exprList.exprs.at(0).parseExpr() +" - " + self.rightExpr.exprList.exprs.at(1).parseExpr() +")";
}%]

[%operation Z!ApplExpr parseMult(): String{
	return  "("+ self.rightExpr.exprList.exprs.at(0).parseExpr() +" * " + self.rightExpr.exprList.exprs.at(1).parseExpr() +")";
}%]

[%operation Z!ApplExpr parseDiv(): String{
	return  "("+ self.rightExpr.exprList.exprs.at(0).parseExpr() +" div " + self.rightExpr.exprList.exprs.at(1).parseExpr() +")";
}%]

[%operation Z!ApplExpr parseModulus(): String{
	return "("+ self.rightExpr.exprList.exprs.at(0).parseExpr() +" mod " + self.rightExpr.exprList.exprs.at(1).parseExpr() +")";
}%]


[%operation Z!ApplExpr parseNot(): String{
	return  "(\\<not>" + self.rightExpr.parseExpr() +")";
}%]

[%operation Z!ApplExpr parseNeg(): String{
	return  "(-" + self.rightExpr.parseExpr() +")";
}%]


[%operation Z!BasicChannelSetExpr parseBasicChannelSetExpr(): String{
	var cs_str : String;
	for (commu in self.communicationList.communications){
		cs_str = commu.parse();
		if (hasMore){
			cs_str = cs_str + ",";
		}
	}
	return  "(" + cs_str +")";
}%]




  
 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
[*to generate the CallExp expression string for the statement of CallExp type, i.e. functions*]
[% 
operation RC!CallExp callExpString(): String{
var args_string: String;
var callExp_string: String;
//to get the parameter on the right

if(self.args.at(0).isTypeOf(RefExp)){
args_string= self.args.at(0).ref.name;
}
else 
//this branch is for callexp used in functions where we have the keyword result
if(self.args.at(0).isTypeOf(ResultExp)){
args_string= "result";
}
else
if(self.args.at(0).isTypeOf(Selection)){
args_string=self.args.at(0).member.name+"("+self.args.at(0).receiver.value.ref.name+"!"+self.args.at(0).receiver.parameters.at(0).ref.name+")";
}

//for the case that there are more than 2 args, we need insert ',' between args
var j=1;
while(j<self.args.size()){
//"self.args.at(j).type:".println();
//self.args.at(j).type.println();


if(self.args.at(j).isTypeOf(RefExp)){
args_string=args_string+ ", "+ self.args.at(j).ref.name;
}
else 
//this branch is for callexp used in functions where we have the keyword result
if(self.args.at(j).isTypeOf(ResultExp)){
args_string=args_string+ ", "+ "result";
}
else
if(self.args.at(j).isTypeOf(Selection)){
self.args.at(j).receiver.println();
//ArrayExp []
//self.args.at(j).receiver.value.type.println();
//self.args.at(j).receiver.value.ref.name.println();
//gs
//self.args.at(j).receiver.parameters.at(0).ref.name.println();
//x
//self.args.at(j).member.name.println();
//i
args_string= args_string+ ", "+self.args.at(j).member.name+"("+self.args.at(j).receiver.value.ref.name+"!"+self.args.at(j).receiver.parameters.at(0).ref.name+")";
//i(gs!x)
}

//????shall j++ inside or outside?
j++;
}

callExp_string=self.`function`.ref.name+"("+args_string+")";
return callExp_string;
}
  %]
  
  
  
  
  

[*to generate the Call expression string for the statement of Call type, i.e. operations*]
[% 
operation RC!Call callString(): String{
var args_string: String;
var call_string: String;
//to get the parameter on the right
if(self.args.size()=0){
args_string="";
}
else if(self.args.size()>0){
if(self.args.at(0).isTypeOf(RefExp)){
args_string= self.args.at(0).ref.name;
}
else if(self.args.at(0).isTypeOf(IntegerExp)){
args_string= self.args.at(0).value.toString();
}
else if(self.args.at(0).isTypeOf(EnumExp)){
args_string= self.args.at(0).literal.name;
}
else 
//this branch is for callexp used in functions where we have the keyword result
if(self.args.at(0).isTypeOf(ResultExp)){
args_string= "result";
}
else
if(self.args.at(0).isTypeOf(Selection)){
args_string=self.args.at(0).member.name+"("+self.args.at(0).receiver.value.ref.name+"!"+self.args.at(0).receiver.parameters.at(0).ref.name+")";
}

//for the case that there are more than 2 args, we need insert ',' between args
var j=1;
while(j<self.args.size()){
//"self.args.at(j).type:".println();
//self.args.at(j).type.println();


if(self.args.at(j).isTypeOf(RefExp)){
args_string=args_string+ ", "+ self.args.at(j).ref.name;
}
else if(self.args.at(j).isTypeOf(IntegerExp)){
args_string= args_string+ ", "+ self.args.at(j).value.toString();
}
else if(self.args.at(j).isTypeOf(EnumExp)){
args_string= args_string+ ", "+ self.args.at(j).literal.name;
}
else 
//this branch is for callexp used in functions where we have the keyword result
if(self.args.at(j).isTypeOf(ResultExp)){
args_string=args_string+ ", "+ "result";
}
else
if(self.args.at(j).isTypeOf(Selection)){
self.args.at(j).receiver.println();
//ArrayExp []
//self.args.at(j).receiver.value.type.println();
//self.args.at(j).receiver.value.ref.name.println();
//gs
//self.args.at(j).receiver.parameters.at(0).ref.name.println();
//x
//self.args.at(j).member.name.println();
//i
args_string= args_string+ ", "+self.args.at(j).member.name+"("+self.args.at(j).receiver.value.ref.name+"!"+self.args.at(j).receiver.parameters.at(0).ref.name+")";
//i(gs!x)
}

//????shall j++ inside or outside?
j++;
}
}
call_string=self.`operation`.name+"("+args_string+")";
return call_string;
}
  %]
  


  
[%
operation RC!SeqExp sequenceString(): String{

if(self.values.size()=0){
return  "[]";
} 
else if(self.values.size()>0) {
var m=1;
var sequence_string="["+self.values.at(0);
while (m<self.values.size()){
sequence_string=sequence_string+", "+self.values.at(m);
m++;
}
sequence_string=sequence_string+"]";
return sequence_string;
}
}
%]


[%
operation RC!ProductType productString(): String{
var strings: String;
strings= "("+self.types.at(0).zmType() + "\\<times>" + self.types.at(1).zmType()+")" ;
 return strings;
}
%]
