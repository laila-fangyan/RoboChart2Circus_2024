/*this section need to be part of the transformation*/


//for(stm in RC!StateMachineDef.all().at(0)){
//	//var name = RC!StateMachineDef.all().at(0).name + "_" + n.name + "proc";
//	stm.nodes.composedNodes();
//
//}

//var cs = createChannelSet(createBasicChannelSetExpr(Set{"share", "terminate"})).createChanSetPara("cs");

var nc = RC!StateMachineDef.all().at(0);

//nc.FQN().println();

//nc.createTransitionsAsCircusProcess();
//var nodes = RC!StateMachineDef.all().at(0).nodes;
//nodes.println();
//composedNodes(nodes).createRenameProcess(Sequence{"share"},Sequence{"share", "setL_a"});
//ncCoreBehaviour(nc);
ncBehaviour(nc);


var zsect = createZSect("circus_theory", Sequence{}, Sequence{"Boolean_operators"});
	
Set{"share", "share1", "share2"}.createChannelPara();
Set{"share4", "share5"}.createChannelPara("int");

for(p in Z!Para.all().select(p|p.instanceOf(Z!ChannelSetPara) or p.instanceOf(Z!ChannelPara) or p.instanceOf(Z!ProcessPara))){
	zsect.addPara2ZSect(p);	

//	if(p.instanceOf(Z!ChannelSetPara)){
//		zsect = zsect.addPara2ZSect(p);	
//		"line 34".println();
//	} else
//	if(p.instanceOf(Z!ProcessPara)){
//		zsect.addPara2ZSect(p);	
//	} 
}

createSpec(zsect);
//RC!StateMachineDef.all().println();
//for(n in RC!StateMachineDef.all().at(1).nodes){
//
//	if (n.eClass().name = "State" and n.name = "s0"){
//		RC!StateMachineDef.all().at(1).println();
//		for(nc in RC!StateMachineDef.all()){
//			if(nc.nodes.includes(n)){
//				("the node container of this state: " + nc.name).println();
//			} 
//		}
	
//		n.actions.at(0).action.right.createExpr();
//		//To create Minus
//		if(n.actions.at(0).action.right.type().name = "Minus"){
//			"so we shall create an ApplExpr.".println();
//			n.actions.at(0).action.right.createExpr();
//		}
//		
//		
//	}
//}

//for (t in RC!StateMachineDef.all().at(1).transitions){
//	if(t.name = "t1"){
//	RC!StateMachineDef.all().at(1).println();
//		for(nc in RC!StateMachineDef.all()){
//			if(nc.transitions.includes(t)){
//				("the node container of this transition: " + nc.name).println();
//			} 
//		}
//	}
//
//}

//RC!StateMachineDef.all().at(0).createTransitionsAsCircusProcess();

//for(n in RC!StateMachineDef.all().at(0).nodes){
//	if(n.eClass().name = "State" and n.name = "s3"){
//		"line3".println();
//		n.createStateActionAsCircusAction("DuringAction");
//		//n.actions.at(0).action.createStmtInContextAsAction();
//		//usedVariables(n.actions.at(1).action).println();
//		"line5".println();
//		//set1.at(0).type().println();
//
//	}
//}

//for(n in RC!StateMachineDef.all().at(0).nodes){
//	if(n.eClass().name = "State" and n.name = "s2"){
//		"line3".println();
//		var set1 = usedVariables(n.actions.at(1).action);
//		set1.println();
//		"line5".println();
//		set1.at(0).type().println();
//
//	}
//}


//var ta;
//for (t in RC!StateMachineDef.all().at(0).transitions){
//	if(t.name = "t3"){
//		ta = t.createTransitionAsCircusAction();
//	"line162".println();
//	ta.type().println();
//	
//	}
//
//}

//for(n in RC!StateMachineDef.all().at(0).nodes){
//	if(n.eClass().name = "State" and n.name = "s4"){
//		"line3".println();
//		n.actions.at(1).println();
//		n.actions.at(1).action.println();
//		var set1 = usedVariables(n.actions.at(1).action);
//		set1.println();
//		"line5".println();
//		set1.type().println();
//				//readState(set1,"SSTOP".createCallAction());
//	}
//}
	
//for(n in RC!StateMachineDef.all().at(0).nodes){
//	if(n.eClass().name = "State" and n.name = "s3"){
//		"line11".println();
//		usedVariables(n.actions.at(0).action).println();
//		"line13".println();
//	}
//}


//TO DO: to implement
//to convert the element name into Fully Qualified Name (FQN)

operation createSpec(zsect: Z!ZSect): Z!Spec{
	var spec = new Z!Spec;
	var narrativeSect = new Z!NarrSect;
//	var zSect = new Z!ZSect;
//	zSect =  zsect;
	spec.sects = Sequence{narrativeSect, zsect};
	return spec;
}


operation createZSect(
	sect_name: String,
	paraSeq: Sequence<Z!Para>,
	parentNameSeq: Sequence<String>
	): Z!ZSect{
	
	var zsect = new Z!ZSect;
	zsect.name = sect_name;
	
	zsect.paraList = new Z!ZParaList;
	zsect.paraList.paras = paraSeq;
	
	zsect.parents = createParentList(parentNameSeq);
	
	return zsect;
}

operation createParentList(parentNameSeq: Sequence<String>): Sequence<Z!Parent>{
	var parents = Sequence<Z!Parent>;
	parents = Sequence{};
	for(p in parentNameSeq){
		parents.add(createParent(p));
	}
	return parents;
}

operation createParent(p: String): Z!Parent{
	var parent = new Z!Parent;
	parent.word = p;
	return parent;
}

operation Z!ZSect addPara2ZSect(para: Z!Para): Z!ZSect{
	var zsect =  self;
"line 178, addPara2ZSect is called".println();
zsect.paraList.isDefined.println();
zsect.paraList.println();

zsect.paraList.paras.isDefined.println();
zsect.paraList.paras.println();
//	self.paraList = new Z!ZParaList;

para.println();
//para.name.word.println();
	
	zsect.paraList.paras.add(para);
	("line 193 is executed: self.paraList.paras = " + self.paraList.paras).println();
	return zsect;

}


operation Any FQN(): String{
/*TO DO: Issue: the hierachy is not fixed, can have infinite combination.
	var fqn = new String;

	if(self.instanceOf(RC!Node)){
		for(nc in RC!NodeContainer.all()){
			if(nc.nodes.includes(n)){
				fqn = self.name + "_" + nc.name;
				if(nc.instanceOf(RC!Node)){
					//TO DO, the composite state can have infinite sublayers, when to stop?
				}
				for(ctrl in RC!ControllerDef.all()){
					if(ctrl.machines.includes(nc)){
						fqn = fqn + "_" + ctrl.name;  //s0_stm0_ctrl0
					}
				}
			}
		}
	}
*/
	return self.name;
}

operation String FQN(): String{
	return self;
}

operation Set<String> FQN():  Set<String>{
	return self;
}

operation Sequence<String> FQN():  Sequence<String>{
	return self;
}




//channel decleration for node container
operation chanDeclNC(){
	//TO DO
}

//self = name of the channel
//different from ChannelSetPara or ActionPara or ProcessPara, ChannelPara has no property of name
//type indicate the type of the channel, or is sync if is uptyped
operation Set<String> createChannelPara(type: String): Z!ChannelPara{
	var chanDeclPara = new Z!ChannelPara;
	chanDeclPara.declList = new Z!ZDeclList;
	
	var decl = self.createChannelDecl(type);
	chanDeclPara.declList.decls = Sequence{decl};
	
	return chanDeclPara;
}

operation Set<String> createChannelPara(): Z!ChannelPara{
	var chanDeclPara = new Z!ChannelPara;
	
	chanDeclPara.declList = new Z!ZDeclList;
	
	var decl = self.createChannelDecl();
	chanDeclPara.declList.decls = Sequence{decl};
	
	return chanDeclPara;
}


operation Set<String> createChannelDecl(): Z!ChannelDecl{
	var decl = new 	Z!ChannelDecl;
	
	//The first element is the (possibly empty) list of generic formal parameters
//	var fst_list = createNameList(Set{});
	decl.genFormals = createNameList(Set{});
	
	//the second element is the (possibly empty) list of declared channel names
//	var snd_list = createNameList(self);
	decl.channelNameList = createNameList(self);
	//decl.nameLists is a list of non-null NameList objects with size two. decl.nameLists = new Sequence<Z!ZNameList>;
//	decl.listOfNameLists = new Sequence<Z!ZNameList>;
//	decl.listOfNameLists = Sequence{fst_list, snd_list};
//	decl.listOfNameLists = Sequence{decl.genFormals, decl.channelNameList};
	//expr attr indicate the type of the channel, and it's a RefExpr
	//if it's untyped, type = "SYNCH"
	decl.expr = "SYNCH".createRefExpr(false, false);
	
	return decl;
}


operation Set<String> createChannelDecl(type: String): Z!ChannelDecl{
	var decl = new 	Z!ChannelDecl;
	
	//The first element is the (possibly empty) list of generic formal parameters
//	var fst_list = createNameList(Set{});
	decl.genFormals = createNameList(Set{});
	//the second element is the (possibly empty) list of declared channel names
//	var snd_list = createNameList(self);
	decl.channelNameList = createNameList(self);
	//decl.nameLists is a list of non-null NameList objects with size two. decl.nameLists = new Sequence<Z!ZNameList>;
//	decl.listOfNameLists = new Sequence<Z!ZNameList>;
//	decl.listOfNameLists = Sequence{fst_list, snd_list};
//	decl.listOfNameLists = Sequence{decl.genFormals, decl.channelNameList};
	//expr attr indicate the type of the channel, and it's a RefExpr
	//if it's untyped, type = "SYNCH"
	decl.expr = type.createRefExpr(false, false);
	
	return decl;
}




//CSP Rule 40

operation ncBehaviour(nc:RC!NodeContainer): Z!ProcessPara{

	var hideset_string = enterSS(nc).includingAll(Set{"exit", "exited", "internal__"}.FQN());
	
	var ncBehaviourProc = ncCoreBehaviour(nc).createHideProcess(hideset_string).createRenameProcess(renameTriggerEventsPairL(nc), renameTriggerEventsPairR(nc));
	
	("line 175, renameTriggerEventsPairL(nc) = " + renameTriggerEventsPairL(nc)).println();
	var ncBehaviourProcPara =  ncBehaviourProc.createProcessPara("ncBehaviourProc_"+nc.name.FQN(), true);

	return ncBehaviourProcPara;
}




//CSP Rule 41
operation ncCoreBehaviour(nc:RC!NodeContainer): Z!CircusProcess{

	
	/***************start of tidsR(nc) calculation************************/
	
	//tidsR(nc) renaming is implemented as transitions renaming and nodes renaming 
	//firstly, to calculate the renaming pair for the transitions
	var tidsR_trans_pairL = new Sequence<String>;
	for(t in nc.transitions){
		tidsR_trans_pairL.add("interrupt."+nc.name+"."+t.source.name);
	}
	var tidsR_trans_pairR = new Sequence<String>;
	for(t in nc.transitions){
//		tidsR_trans_pairR.add(tevent(t,nc.name));
		tidsR_trans_pairR.add(tevent_str(t));
	} 
	

	//Secondly, to calculate the renaming pair for the nodes
	var tidsR_nodes_pairL = new Sequence<String>; 
	for(n in nc.nodes.select(m|m.instanceOf(State))){
		tidsR_nodes_pairL.add("interrupt."+nc.name+"."+n.name);
	}
	var tidsR_nodes_pairR = new Sequence<String>;
	for(n in nc.nodes.select(m|m.instanceOf(State))){
		tidsR_nodes_pairR.add("interrupt."+nc.name);
	}
	

	//to combine the two sets of pair
	var tidsR_pairL = tidsR_trans_pairL.includingAll(tidsR_nodes_pairL);
	var tidsR_pairR = tidsR_trans_pairR.includingAll(tidsR_nodes_pairR);
	
	/***************end of tidsR(nc)************************/
	
	
	
	//Rename composedNodes(nc.nodes) with tidsR(nc)
	var composedNodeProcTidsRenamed = composedNodes(nc.nodes).createRenameProcess(tidsR_pairL, tidsR_pairR);
	
	
	//create transition process: Q
	var transProc = nc.createTransitionsAsCircusProcess();
	
	//a process paragraph is created for transProc because transProc is defined standalone in auto-gen CSPM 
	var transProcPara = transProc.createProcessPara("trans_proc_" + nc.FQN(), true);
	
	
	var cs_stringset = flowevts(nc).includingAll(transSync(nc));
	cs_stringset.add("terminate");
	//?? TO DO: do "terminate" need to be "terminate"+"_"+ nc.name? 
	
	/***************begin of C.2.2 metanotatin************************/
	/*
	"line 238".println();
	("No1:  nc.type = "+ nc.eClass().name).println();
	
	("No1.1:  nc.type = nodecontainer? "+ nc.instanceOf(RC!NodeContainer)).println();
	
	("No2:  composeNodeProcRenamed2Para.name.createCallProcess().type = "+ composeNodeProcRenamed2Para.name.createCallProcess().eClass().name).println();
	
	("No2.1:  callprocss.type = circusproc? "+ composeNodeProcRenamed2Para.name.createCallProcess().instanceOf(Z!CircusProcess)).println();
	
	("No3:  vars(nc.nodes).type = "+ vars(nc.nodes).type().name).println();
	
	
	("No3.1:  vars(nc.nodes).type = set<string>? "+ vars(nc.nodes).instanceOf(Set<String>)).println();
	
	
	("No4:  vars(nc.nodes).type = "+ vars(nc.nodes).type().name).println();
	
	("No5:  cs_stringset.type = "+ cs_stringset.type().name).println();
	
	("No6:  vtguards(nc).type = "+ vtguards(nc).type().name).println();
	
	("No7:  Set{}.type = "+ Set{}.type().name).println();
	
	("No8:  transProcPara.name.createCallProcess().type = "+ transProcPara.name.createCallProcess().eClass().name).println();
	
	
	("lin 255").println();
	*/
	
	
	var ncCoreBehProc = createMetaParallelProcess(nc, composedNodeProcTidsRenamed, vars(nc.nodes), vars(nc.nodes), cs_stringset, vtguards(nc), Set{}, transProcPara.name.createCallProcess());
	/***************end of C.2.2 metanotatin************************/
	
	
	return ncCoreBehProc;
}



//used inCSP Rule 41 - operation ncCoreBehaviour  
operation vtguards(nc: RC!NodeContainer):  Set<String>{
	var varset = new Set<String>;
	varset = Set{};
	for(t in nc.transitions){
		varset = varset.includingAll(usedVariables(t.condition));
	}
	return varset;
}

	
//CSP Rule 46
operation vars(nodeset:Set<RC!Node>): Set<String>{
	"Rule 46 is called".println();
	var varset = Set<String>;
	varset = Set{};

	for(n in nodeset){
		varset = varset.includingAll(vars(n));
	}
	return varset;
}


//CSP Rule 47
operation vars(ts: Set<RC!Transition>):Set<String>{
	"Rule 47 is called".println();
	var varset = Set<String>;
	for(t in ts){
		varset = varset.includingAll(vars(t));
	}
	return varset;
}


//CSP Rule 48
operation vars(node: RC!Node):Set<String>{
	"Rule 48 is called".println();
	var varset = Set<String>;
	varset = Set{};
	if(node.instanceOf(RC!State)){
		for(a in node.actions){
			varset = varset.includingAll(vars(a.action));
		}
		"line 285".println();
		varset = varset.includingAll(vars(node.nodes)).includingAll(vars(node.transitions));
	} else{
		varset = Set{};
	}
	return varset;
}

//CSP Rule 49
operation vars(t: RC!Transition):Set<String>{
	"Rule 49 is called".println();
	var varset = Set<String>;
	if(t.condition.isDefined()){
		varset = varset.includingAll(vars(t.condition));
	}
	if(t.action.isDefined()){
		varset = varset.includingAll(vars(t.action));
	}
	if(t.deadline.isDefined()){
		varset = varset.includingAll(vars(t.deadline));
	}
	
	return varset;
}

//CSP Rule 50
operation vars(stmt: RC!Statement):Set<String>{
	"Rule 50 is called".println();
	var varset = Set<String>;
	varset = Set{};
	if(stmt.instanceOf(RC!Assignment)){
//		varset = usedVariables(stmt.left).includingAll(usedVariables(stmt.right));
		varset = Set{stmt.left.name.name}.includingAll(usedVariables(stmt.right));
		//TO DO: to confirm: "stmt.left.name.name" works for one var name, is there stmt.left has multiple names?
		
	} else
	if(stmt.instanceOf(RC!Call)){
		for(arg in stmt.args){
			varset = usedVariables(arg);
		}
		varset = varset.includingAll(requiredVariables(stmt.`operation`));
	} else
	if(stmt.instanceOf(RC!IfStmt)){
		varset = usedVariables(stmt.expression).includingAll(vars(stmt.then)).includingAll(vars(stmt.`else`));
	} else
	if(stmt.instanceOf(RC!CommunicationStmt) and (stmt.communication._type=CommunicationType#SYNC or stmt.communication._type=CommunicationType#OUTPUT)){
		varset = usedVariables(stmt.communication.value);
	} else
	if(stmt.instanceOf(RC!CommunicationStmt) and (stmt.communication._type=CommunicationType#INPUT)){
		varset = Set{stmt.communication.parameter.name};
	} else
	if(stmt.instanceOf(RC!ParStmt)){
		varset = vars(stmt.stmt);
	} else
	if(stmt.instanceOf(RC!SeqStatement)){
		varset = vars(stmt.statements);
	} else
	if(stmt.instanceOf(RC!TimedStatement)){
		varset = vars(stmt.stmt).includingAll(vars(stmt.deadline));
	}
		
	return varset;
}

//TO DO
operation requiredVariables(op: RC!OperationSig): Set<String>{
	var varset = new Set<String>;
	varset = Set{};
	
	//TO DO
	
	return varset;
}



//CSP Rule 51
operation vars(seq: Sequence<RC!Statement>):Set<String>{
	"Rule 51 is called".println();
	var varset = Set<String>;
	for(stmt in seq){
		varset = varset.includingAll(vars(stmt));
	}

	return varset;
}

//CSP C.2.2 metanotation
operation createMetaParallelProcess(
	nc: RC!NodeContainer, 
	P: Z!CircusProcess, 
	pr: Set<String>, 
	pw: Set<String>, 
	cs: Set<String>, 
	qr: Set<String>, 
	qw: Set<String>, 
	Q: Z!CircusProcess
	): Z!CircusProcess{


	
	//step 1 - rename P: (1) create assigementpairs, (2) rename P 

	
	//share <-- share
	var PRenaming_pairR = Sequence{"share"};
	var PRenaming_pairL = Sequence{"share"};
	
	//share <-- setR(v)
	var pr_qw = intersect(pr,qw);
	
	for(v in pr_qw){
		PRenaming_pairR.add("share");
		PRenaming_pairL.add("setR_"+v);//R207 setR(v)
	}
	
	//set(v) <-- setL(v)
	var pw_qr = intersect(pw,qr);
	for(v in pw_qr){
		PRenaming_pairR.add("set_"+v);//Rule 201
		PRenaming_pairL.add("setL_"+v);//R204 setL(v)
	}
	
	var PRenamed = P.createRenameProcess(PRenaming_pairR, PRenaming_pairL);
	
	

	//step 2 - rename Q: (1) create assigementpairs, (2) rename Q
				
	//share <-- share
	var QRenaming_pairR = Sequence{"share"};
	var QRenaming_pairL = Sequence{"share"};
	
	//share <-- setL(v)
	var qr_pw = intersect(qr,pw);
	for(v in qr_pw){
		QRenaming_pairR.add("share");
		QRenaming_pairL.add("setL_"+v);//R204 setL(v)
	}
	
	//set(v) <-- setR(v)
	var qw_pr = intersect(pw,qr);
	for(v in qw_pr){
		PRenaming_pairR.add("set_"+v);//Rule 201
		PRenaming_pairL.add("setR_"+v);//R207 setR(v)
	}
	
	var QRenamed = Q.createRenameProcess(QRenaming_pairR, QRenaming_pairL);
	
	
	//step 3 - create parallel process: (1) define channel set 

	
	var channel_names = cs.includingAll(setLC(intersect(pw,qr))).includingAll(setRC(intersect(qw,pr)));
	channel_names.add("share");
	//TO DO, each channel in channelset_stringSet needs to be declared as a channel.
	//channelset_stringSet.createChannel();
	
	var channelset = createChannelSet(createBasicChannelSetExpr(channel_names)).createChanSetPara("chanset_paral_ncCoreBeh_" + nc.name);
	
	
	//step 4 - create parallel process	P{|channelset|}Q
	
	var PparQ = createParallelProcess("chanset_paral_ncCoreBeh_" + nc.name, PRenamed,QRenamed);
	
	
	//step 5 - rename parallel process: (1) create assigementpairs, (2) rename P{|channelset|}Q
	
	var PQRenaming_pairR = new Sequence<String>;
	var PQRenaming_pairL = new Sequence<String>;
	for(v in pr_qw){
		PQRenaming_pairR.add("setR_"+v);
		PQRenaming_pairL.add("set_"+v);
	}
	for(v in qr_pw){
		PQRenaming_pairR.add("setL_"+v);
		PQRenaming_pairL.add("set_"+v);
	}
	
	var PparQRenamed = PparQ.createRenameProcess(PQRenaming_pairR, PQRenaming_pairL);
	
	return PparQRenamed;
}


//used in  C.2.2 metanotation's operation "createMetaParallelProcess"
operation intersect(
	setA: Set<Any>, 
	setB: Set<Any>
	): Set<Any>{
	var intersection = new Set<Any>;
	for (elementA in setA) {
        if (setB.includes(elementA)) {
            intersection.add(elementA);
        }
    }
	return intersection;	
}

//used in CSP Rule 41
operation flowevts(nc: RC!NodeContainer): Set<String>{
	var flowevts = enterSS(nc).includingAll(Set{"exit."+nc.name, "exited."+nc.name, "interrupt."+nc.name});
	return flowevts;
}


//used in CSP Rule 40 and operation flowevts
//this creates the string set, but not the channel declaration yet //TO DO
operation enterSS(nc: RC!NodeContainer): Set<String>{
	var set = new Set<String>;
	for(n in nc.nodes){
		set.add(nc.name+"."+n.name+"::enter"); //stm0.i0::enter ? 
	}
	return set;
}


//used in Rule 41
operation transSync(nc: RC!NodeContainer): Set<String>{
	var set = new Set<String>;
	for(t in nc.transitions){
		set.add(tevent_str(t));
	}
	return set;
}


//CSP Rule 206, used in C.2.2 (Rule 41)
operation setLC(nameset: Set<String>):Set<String>{
	var set = new Set<String>;
	for(n in nameset){
		set.add("SetL_"+n);
	}
	return set;
}

//CSP Rule 209, used in C.2.2 (Rule 41)
operation setRC(nameset: Set<String>):Set<String>{
	var set = new Set<String>;
	for(n in nameset){
		set.add("SetR_"+n);
	}
	return set;
}

//CSP Rule 42 - part1, used in Rule 40
operation renameTriggerEventsPairL(nc:RC!NodeContainer): Sequence<String>{
	var pairL = new Sequence<String>;
	
	for(t in nc.transitions.select(l|l.trigger.isDefined())){
		
		pairL.add(t.trigger.event.name + "__."+ nc.name+"." + t.name + "." + t.source.name); //TO DO: confirm the FQN format for t.src
	}
	return pairL;
}

//CSP Rule 42 - part2
operation renameTriggerEventsPairR(nc:RC!NodeContainer): Sequence<String>{
	var pairR = new Sequence<String>;
	for(t in nc.transitions.select(l|l.trigger.isDefined())){
		pairR.add(nc.name+"." + t.name + "." + t.trigger.event.name);//TO DO: confirm the FQN format
	}
	return pairR;
}


//TO DO: NEED to test in CZT first
//channelset is declared, and is referred here as a name (RefExp)
operation Z!CircusProcess createHideProcess(
	cs_name: String//, 
//	nc: RC!NodeContainer
	):Z!HideProcess{
	"line 608 createHideProcess is called".println();
	var hideProc = new Z!HideProcess;
	hideProc.channelSet =  createChannelSet(cs_name.createRefExpr(false,false));
	
	hideProc.circusProcess = self;
	hideProc.type().println();
 	return hideProc;
}

//channelset is not declared, and is declared within hideProcess, but has no name (BasicChannelSetExpr)
operation Z!CircusProcess createHideProcess(
	channel_names: Set<String>//, 
//	nc: RC!NodeContainer
	):Z!HideProcess{

	"line 622 createHideProcess is called".println();
	var hideProc = new Z!HideProcess;
	hideProc.channelSet = createChannelSet(createBasicChannelSetExpr(channel_names));
	
	hideProc.circusProcess = self;
	hideProc.type().println();
 	return hideProc;
}



operation Z!CircusProcess createRenameProcess(
	nameSetL: Sequence<String>, 
	nameSetR: Sequence<String>
	): Z!RenameProcess{
	var proc = new Z!RenameProcess;
	proc.circusProcess = self;
	proc.assignmentPairs = createAssignmentPairs(nameSetL, nameSetR);
	
	return proc;
}

//this is not directly used, but in createRenameProcess
operation createAssignmentPairs(
	nameSetL: Sequence<String>, 
	nameSetR: Sequence<String>
	): Z!AssignmentPairs{
	var pairs = new Z!AssignmentPairs;
	var lhs = new Z!ZNameList;
	var rhs = new Z!ZExprList;
	
	for(sname in nameSetL){
		lhs.names.add(sname.createZName());
	}
	pairs.lhsElement = lhs;
	
	for(tname in nameSetR){
		rhs.exprs.add(tname.createRefExpr(false,false));
	}
	pairs.rhsElement = rhs;
	
	return pairs;
}

//was used in R41 tidsR(nc), now replaced by the below updated version (the parameter 'context' was removed)
/*
//this version makes the FQN locally instead of using FQN
operation tevent(t: RC!Transition, context: String): String{
 	
 	var tevent_string;
 	
	if(t.trigger = null){
		tevent_string = "internal." + context +"." + t.source.name;
	} 
	
	else {
		tevent_string = t.trigger.event.name + "__." + context+"." + t.source.name + "_in";
	}
	
	return tevent_string;
}
*/

// used in R41 tidsR(nc) //TO DO: 't.source.name' should be replaced by 't.source.FQN()' later on.
operation tevent_str(t: RC!Transition): String{
 	
 	var tevent_string;
 	
	if(t.trigger = null){
		tevent_string = "internal." + t.source.name;
	} 
	
	else {
		tevent_string = t.trigger.event.name + "__." + t.source.name + "_in";
	}
	
	return tevent_string;
}

//CSP Rule 43 variation
//TO DO: to confirm the Z type, shall trigger event be both a channel AND a communication?
//this version returns Communication
operation  tevent(t: RC!Transition): Z!Communication{
 	
 	var chan_name;
 	var chan_type = "SYNCH";

	if(t.trigger = null){
		chan_name = "internal." + t.source.name;
	} 
	
	else {
		chan_name = t.trigger.event.name + "__." + t.source.name + "_in";
	}
	
	var commu = createSynchCommunication(chan_name);
	
	return commu;
}


//CSP Rule 44
operation usedVariables(stmt:RC!Statement):Set<String>{
	var varSet = new Set<String>;
	if(stmt.instanceOf(RC!Assignment)){
		varSet = usedVariables(stmt.right);
	} else
	if(stmt.instanceOf(RC!Call)){
		for(arg in stmt.args){
			varSet = varSet.includingAll(usedVariables(arg));
		}
	} else
	//stmt.then and stmt.else are handled in the IfStmt incontext semantics
	if(stmt.instanceOf(RC!IfStmt)){
		varSet = usedVariables(stmt.expression);
	} else
	if(stmt.instanceOf(RC!CommunicationStmt) and (stmt.communication._type=CommunicationType#SYNC or stmt.communication._type=CommunicationType#OUTPUT)){
		varSet = usedVariables(stmt.communication.value);
	} else
//	if(stmt.instanceOf(RC!SeqStatement)){
//		for(s in stmt.statements){
//			varSet = varSet.includingAll(usedVariables(s));
//		}
//	} else
//	if(stmt.instanceOf(RC!ParStmt)){
//		varSet = usedVariables(stmt.stmt);
//	} else
	if(stmt.instanceOf(RC!TimedStatement)){
		varSet = usedVariables(stmt.stmt).includingAll(usedVariables(stmt.deadline));
	} else
	{//SeqStatement falls in this case
	}
	
	return varSet;
}



//used in operation usedVariables(stmt:RC!Statement)
//TO DO: this is not a complete implementation because of lamda expr
//TO BE FIXED LATER for LAMDA
//as the lamda expression is not well considered.
//the local variable in lamda expr should not be considered in this function
//CSP Rule 45
operation usedVariables(expr:RC!Expression): Set<String>{
	var set = new Set<String>;
	if(expr = null
	 //when expr is concreate value (int, float, string, boolean, ect.), as these do not fall into any if case, therefore, set = {}
	 //or expr.instanceOf(IntegerExp) or expr.instanceOf(FloatExp) or expr.instanceOf(StringExp) or expr.instanceOf(BooleanExp)
	 ){
	} else
	if(expr.instanceOf(RefExp)){
		var value = expr.ref;
		if(value.instanceOf(RC!Variable) and value.modifier= VariableModifier#VAR){
			set.add(value.name);
		}

	} else{
		"line814".println();
		 expr.eContents.println();
		 "line816".println();
		for(obj in expr.eContents){
			if(obj.instanceOf(RC!Expression)){
				set = set.includingAll(usedVariables(obj));
			}
		}
		
	}
	
	return set;
}




//CSP Rule 52
operation composedNodes(nodes: Set<Node>): Z!CircusProcess{
	
	var procForComposeNodes;
	
	if(nodes.size()=0){//SStop /\ terminate -> Skip, this is an action, need to be converted into process
		var action = createAction2("InterruptAction", "SSTOP".createCallAction(), createPrefixingAction(createSynchCommunication("terminate"), createSkipAction()));
		
		var actionParaSeq = new Sequence<Z!ActionPara>;
		actionParaSeq = Sequence{action.createActionPara("action")};
		procForComposeNodes = actionParaSeq.createBasicProcess("action");
	}else{
		
//		var ndProcSet = new Set<CircusProcess>;
		var ndProcNameSet = new Set<String>;
		
		for(nd in nodes){
			var proc_name = nd.name + "_proc";//TO DO: need to give the fully qualified name?
			if(nd.instanceOf(Junction)){
				
				//to create the process for this node as a standalone process paragraph
				nd.createJunctionAsBasicProcess().createProcessPara(proc_name, true);
				ndProcNameSet.add(proc_name);
				
				//we don't need the process set, but the name set of the processes
				//because the parallel process is for callProcess, so the line below is commented out.
				//ndProcSet.add(nd.createJunctionAsBasicProcess());
			} else
			if(nd.instanceOf(Final)){
				
				nd.createFinalAsBasicProcess().createProcessPara(proc_name, true);
				ndProcNameSet.add(proc_name);
//				ndProcSet.add(nd.createFinalAsBasicProcess());
			} else
			if(nd.instanceOf(State)){
				if(nd.nodes.size()=0){
					nd.createSimpleStateAsBasicProcess().createProcessPara(proc_name, true);
					ndProcNameSet.add(proc_name);
//					ndProcSet.add(nd.createSimpleStateAsBasicProcess());
				} else{
					//TO DO: to uncomment when createCompositeStateAsBasicProcess is defined
					//ndProcSet.add(nd.createCompositeStateAsBasicProcess()); 
				}
				
			}
		}
		
//		//to create channelset as a channel set paragraph	
//		var cs = createChannelSet(createBasicChannelSetExpr(Set{"share", "terminate"})).createChanSetPara("cs");
		
		if(nodes.size()<2){
			throw "There are less than 2 nodes, so the parallel process can not be composed.";
		} else{
		
			//we can directly use the node process ndProcSet.at(0),ndProcSet.at(1) to create parallel process directly, but to be consistent with the auto-gen CSPM, we use callProcess here
			procForComposeNodes = createParallelProcess(Set{"share", "terminate"}, ndProcNameSet.at(0).createCallProcess(),ndProcNameSet.at(1).createCallProcess());
			ndProcNameSet.removeAt(0);
			ndProcNameSet.removeAt(0);
						
			while(ndProcNameSet.size()>0){

				procForComposeNodes = createParallelProcess(Set{"share", "terminate"}, procForComposeNodes,ndProcNameSet.at(0).createCallProcess());			
				ndProcNameSet.removeAt(0);
			}

		}
		
	}
	
	return procForComposeNodes;
}

operation String createCallProcess(): Z!CallProcess{
	var proc = new Z!CallProcess;
	proc.callExpr = self.createRefExpr(false,false);
	proc.callUsage = Z!CallUsage#Parameterised;
	
	return proc;
}

operation Z!ZName createCallProcess(): Z!CallProcess{
	var proc = new Z!CallProcess;
	proc.callExpr = self.word.createRefExpr(false,false);
	proc.callUsage = Z!CallUsage#Parameterised;
	
	return proc;
}

operation Z!CircusProcess createProcessPara(name: String, isBasicProc: Boolean): Z!ProcessPara{
	var para = new Z!ProcessPara;
	para.name = name.createZName();
	para.circusProcess = self;
	para.isBasicProcess = isBasicProc;
	
	return para;
}



//channelset is a reference to a channelset name, therefore it is an RefExpr
operation createParallelProcess(
	cs_name: String, 
	left: Z!CircusProcess, 
	right: Z!CircusProcess
	):Z!ParallelProcess{
	
	var proc = new Z!ParallelProcess;
	proc.channelSet = createChannelSet(cs_name.createRefExpr(false,false));
	proc.leftProcess = left;
	proc.rightProcess = right;
	
	return proc;
}


//channelset is declared in the process directly using the channel names, so has no nameo a channelset name
//therefore it is an BasicChannelSetExpr
operation createParallelProcess(
	channel_names: Set<String>, 
	left: Z!CircusProcess, 
	right: Z!CircusProcess
	):Z!ParallelProcess{
	
	var proc = new Z!ParallelProcess;
//	proc.channelSet = createChannelSet(cs_name.createRefExpr(false,false));
	proc.channelSet = createChannelSet(createBasicChannelSetExpr(channel_names));
	proc.leftProcess = left;
	proc.rightProcess = right;
	
	return proc;
}


//to create BasicChannelSetExpr used in channel set declaration
operation createBasicChannelSetExpr(channel_names: Set<String>): Z!BasicChannelSetExpr{
	var expr = new Z!BasicChannelSetExpr;
	var commuList = new Sequence<Z!Communication>;
	for(n in channel_names){
		commuList.add(createChannelSetCommunication(n));
	} 
	var communicationList = new Z!CircusCommunicationList;
	expr.communicationList = communicationList;
	expr.communicationList.communications = commuList;
	return expr;
}


//to create communication of channelset type to be used in the BasicChannelSetExpr
operation createChannelSetCommunication(
	channel_name:String
	): Z!Communication{
	
	var commu = new Z!Communication;
	commu.commUsage = Z!CommUsage#Normal;
	commu.indexed = false;
	commu.multiSych = 0;
	commu.channelExpr = channel_name.createRefExpr(false,false);
	commu.fieldList = new Z!CircusFieldList; 
	
	commu.commPattern = Z!CommPattern#ChannelSet;
	commu.fieldList.fields = Sequence{};		
		
	return commu;
}

operation createChannelSet(expr: Z!Expr):Z!CircusChannelSet{
	var cs = new Z!CircusChannelSet;
	cs.expr = expr;
	return cs;

}




operation Z!CircusChannelSet createChanSetPara(name: String): Z!ChannelSetPara{
	var para = new Z!ChannelSetPara;
	para.name = name.createZName();
	para.channelSet = self;
	
	return para;
}


//CSP Rule 53, modified: update action Trans into a prefixingaction, then updated as a process: (enter.initial(nc.nodes) -> Trans)
operation RC!NodeContainer createTransitionsAsCircusProcess(): Z!CircusProcess{
	
	var trans;

	var tran_seq = Sequence<Z!CircusAction>;
	tran_seq = Sequence{};
	for(t in self.transitions){
		"line188".println();
		("tran_seq = " + tran_seq).println();
		tran_seq.add(t.createTransitionAsCircusAction());
	}
	var choice1_action1_left = tran_seq.createSequenceAsExtchoiceAction();

	
	var choice1_action1_right = createPrefixingAction(createSynchCommunication("share"), createSkipAction());
	
 	var choice1_action1 = createAction2("ExtChoiceAction", choice1_action1_left, choice1_action1_right);
	"line 199".println();
	("trans " + trans).println();
	var choice1 = createAction2("SeqAction", choice1_action1, "trans".createCallAction());
	
	
	/* Start of Choice 2 creation*/
	//Stop /\ (exit -> Skip)
	var choice2_action1_action2 = createAction2("InterruptAction", "SSTOP".createCallAction(), createPrefixingAction(createSynchCommunication("exit"), createSkipAction()));
	var choice2_action1 = createPrefixingAction(createSynchCommunication("interrupt." + self.name), choice2_action1_action2);
	
	//exited -> end -> Skip
	var choice2_action2_action2 = createPrefixingAction(createSynchCommunication("exited"), createPrefixingAction(createSynchCommunication("terminate"), createSkipAction()));
	
	//SStop /\ (exited -> end -> Skip)
	var choice2_action2 = createAction2("InterruptAction", "SSTOP".createCallAction(), choice2_action2_action2);
	var choice2 = createAction2("SeqAction", choice2_action1, choice2_action2);
	/* End of Choice 2 creation*/
	
	
	//terminate -> Skip
	var choice3 = createPrefixingAction(createSynchCommunication("terminate"), createSkipAction());
		
	var trans = createAction2("ExtChoiceAction", choice1, createAction2("ExtChoiceAction", choice2, choice3));
	("trans: "+trans).println();
	
	
	var vguards = self.vguards(); 
	"line309".println();
	vguards.println();
	var Trans = readStateA(vguards, trans);
	//Trans is an actioin and can not be a process, because it will be prefixed.
	//end of CSP Rule53
	
	
	//to integrate the prefix "enter.initial"
	//and to convert the action into a Process
	var initial_name = nc.nodes.selectOne(n|n.instanceOf(Initial)).name;
	"line496".println();
	nc.nodes.selectOne(n|n.instanceOf(Initial)).println();
	nc.nodes.selectOne(n|n.instanceOf(Initial)).name.println();
	var commu = createSynchCommunication("enter." + nc.name + "." + initial_name);
	
	var prefixAction = createPrefixingAction(commu, Trans);
	
	var actionParaSeq = new Sequence<Z!ActionPara>;
	actionParaSeq = Sequence{prefixAction.createActionPara("prefixedTransAction_"+nc.name)};
	var proc = actionParaSeq.createBasicProcess("prefixedTransAction_"+nc.name);
		
	return proc;
}


//CSP Rule 54
//to create circus action for each transition
operation RC!Transition createTransitionAsCircusAction(): Z!CircusAction{
	var circusAction;
	if(self.source.type().name = "State"){
					
		//action1: trigger; action2: interruptAction1 ; action3: interruptAction(SStop, SeqAction )
		
		var action1 = trigger(self);
		
		//to create action2: exit
		var rightAction1 = createPrefixingAction(createSynchCommunication("exit"), createSkipAction());
		var action2 = createAction2("InterruptAction", "SSTOP".createCallAction(), rightAction1);
		
		//to create action3_inner_1: exited
		var prefixedAction = self.createTrActionAsCircusAction();
		
		
		var action3_inner_1 = createPrefixingAction(createSynchCommunication("exited"), prefixedAction);
		
		
		//to create action3_inner_2: enter
		var action3_inner_2 = createPrefixingAction(createSynchCommunication("enter." + self.target.name), createSkipAction());
		
		var action3_right = createAction2("SeqAction", action3_inner_1, action3_inner_2);
		
		//SStop /\ ( (exited-> [[t.action]]) ; (enter_t.target -> Skip))
		var action3 = createAction2("InterruptAction", "SSTOP".createCallAction(), action3_right);
		
		
		circusAction = createAction2("SeqAction", action1, createAction2("SeqAction", action2, action3));
		
		if(self.condition != null){
			var pred = self.condition.createExpr().createMemPredEquality();
			circusAction = createGuardedAction(pred, circusAction);
		} 
	} else 
	
	if(self.source.type().name != "State"){
		//action1: prefixingAction
		
		
		var prefixedAction = self.createTrActionAsCircusAction();
		
		var action1 = createPrefixingAction(tevent(self), prefixedAction);
		
		var action2 = createPrefixingAction(createSynchCommunication("enter." + self.target.name), createSkipAction());
		
		circusAction = createAction2("SeqAction", action1, action2);
				
		if(self.condition != null){
			var pred = self.condition.createExpr().createMemPredEquality();
			circusAction = createGuardedAction(pred, circusAction);
		} 
	} 
	
	return circusAction;
}


//equality is s relation operator application (C.5.12): MemPred
operation Z!Expr createMemPredEquality(): Z!MemPred{
	var pred =  new Z!MemPred;
	pred.leftExpr = self;
	
	var set = Set{"True"};
	pred.rightExpr = set.createSetExpr();
	pred.mixFix = true;
	
	return pred;
}


operation  Set<String> createSetExpr(): Z!SetExpr{
	var setExpr = new Z!SetExpr;
	var exprList = new Z!ZExprList;
	var exprs = new Sequence<Z!Expr>;
	
	for(m in self){
		exprs.add(m.createRefExpr(false,false));
	}
	exprList.exprs = exprs;
	setExpr.exprList = exprList;
	return setExpr;
}



 

//CSP Rule 55
operation  trigger(t: RC!Transition): Z!PrefixingAction{
	var triggerAction;
	var commu;
	var callAction;
	var channel_name;
	
	if(t.trigger = null){
	
		commu = createSynchCommunication("internal." + t.source.name);
		triggerAction = createPrefixingAction(commu, createSkipAction());
			
	} else 
	
	//trigger event can only be input or simple type
	if(t.trigger._type = CommunicationType#INPUT){
		
		var channel_name = t.trigger.event.name + "__." + t.source.name + "_in";
		var var_name = t.trigger.parameter.name;
		commu = createInputCommunication(channel_name, var_name);

		var inner_channel_name = "set_" + t.trigger.parameter.name;
		var expr_string = t.trigger.parameter.name;
		var inner_commu = createOutputCommunicationFromString(inner_channel_name, expr_string);
//		var inner_commu = t.trigger.createCommuAsCommunication(inner_channel_name, "OUTPUT");
					
		var rightAction = createPrefixingAction(inner_commu, createSkipAction());
		var leftAction = "SSTOP".createCallAction();
		callAction = createAction2("InterruptAction", leftAction, rightAction);
		
		triggerAction = createPrefixingAction(commu, callAction);
	} else
	
	if(t.trigger._type = CommunicationType#SIMPLE){
		channel_name = t.trigger.event.name + "__." + t.source.name + "_in";
		commu = createSynchCommunication(channel_name);
		triggerAction = createPrefixingAction(commu, createSkipAction());
	} 
	return triggerAction;
}






//CSP Rule 57
operation RC!Junction createJunctionAsBasicProcess(): Z!BasicProcess{
	var actionParaSeq = new Sequence<Z!ActionPara>;
	
		
	var Inactive = createAction2("InterruptAction", "SSTOP".createCallAction(), createAction2("ExtChoiceAction", "Activation".createCallAction(), "Termination".createCallAction()));
	
	actionParaSeq = Sequence{Inactive.createActionPara("Inactive")};
	
		
	var Activation = createPrefixingAction(createSynchCommunication("enter_"+self.name), "Active".createCallAction());
	actionParaSeq.add(Activation.createActionPara("Activation"));
	
	var Termination = createPrefixingAction(createSynchCommunication("terminate"), createSkipAction());
	actionParaSeq.add(Termination.createActionPara("Termination"));
	
	var seqAction1 = createAction2("InterruptAction", "SSTOP".createCallAction(), createPrefixingAction(createSynchCommunication("interrupt_"+self.name), createSkipAction()));
	
	var Active = createAction2("SeqAction", seqAction1, "Inactive".createCallAction());
	actionParaSeq.add(Active.createActionPara("Active"));
	
	var mainActionname = "Inactive";
	
	var basicProcess = actionParaSeq.createBasicProcess(mainActionname);
	return basicProcess;
}




//CSP Rule 58
operation RC!Final createFinalAsBasicProcess(): Z!BasicProcess{
	var actionParaSeq = new Sequence<Z!ActionPara>;
	
		
	var Inactive = createAction2("InterruptAction", "".createCallAction(), createAction2("ExtChoiceAction", "Activation".createCallAction(), "Termination".createCallAction()));
	
	actionParaSeq = Sequence{Inactive.createActionPara("Inactive")};
	
		
	var Activation = createPrefixingAction(createSynchCommunication("enter_"+self.name), "Entering".createCallAction());
	actionParaSeq.add(Activation.createActionPara("Activation"));
	
	var Termination = createPrefixingAction(createSynchCommunication("terminate"), createSkipAction());
	actionParaSeq.add(Termination.createActionPara("Termination"));
	
	var Entering = createPrefixingAction(createSynchCommunication("entered_" + self.name), "Active".createCallAction());
	actionParaSeq.add(Entering.createActionPara("Entering"));
	
	
	
	var rightAction = createAction2("ExtChoiceAction", "Termination".createCallAction(), createPrefixingAction(createSynchCommunication("interrupt_"+self.name), "Interrupted".createCallAction()));
	
	var Active = createAction2("InterruptAction", "SSTOP".createCallAction(), rightAction);
	actionParaSeq.add(Active.createActionPara("Active"));
	
	var rightAction2 = createPrefixingAction(createSynchCommunication("exit"), createPrefixingAction(createSynchCommunication("exited"), "Inactive".createCallAction()));
	
	var Interrupted = createAction2("InterruptAction", "SSTOP".createCallAction(), rightAction2);
	actionParaSeq.add(Interrupted.createActionPara("Interrupted"));
	
	var mainActionname = "Inactive";
	
	var basicProcess = actionParaSeq.createBasicProcess(mainActionname);
	return basicProcess;
}




//CSP Rule 59
operation RC!State createSimpleStateAsBasicProcess(): Z!BasicProcess{
	var actionParaSeq = new Sequence<Z!ActionPara>;
	
		
	var Inactive = createAction2("InterruptAction", "SSTOP".createCallAction(), createAction2("ExtChoiceAction", "Activation".createCallAction(), "Termination".createCallAction()));
	var InactivePara = Inactive.createActionPara("Inactive");
	actionParaSeq.add(InactivePara);
	
	"line115".println();
	actionParaSeq.println();
	var Activation = createPrefixingAction(createSynchCommunication("enter_"+self.name), "Active".createCallAction());
	actionParaSeq.add(Activation.createActionPara("Activation"));
	
	var Termination = createPrefixingAction(createSynchCommunication("terminate"), createSkipAction());
	actionParaSeq.add(Termination.createActionPara("Termination"));
	
	var Active = createAction2("SeqAction", self.createStateActionAsCircusAction("EntryAction"), createAction2("SeqAction", "Behaviour".createCallAction(), "Exiting".createCallAction()));
	actionParaSeq.add(Active.createActionPara("Active"));
	
	
	var Behaviour = createPrefixingAction(createSynchCommunication("entered_" + self.name), "During".createCallAction());
	actionParaSeq.add(Behaviour.createActionPara("Behaviour"));
	
	var duringLeft = createAction2("SeqAction", self.createStateActionAsCircusAction("DuringAction"), "SSTOP".createCallAction());
	"line324".println();
	var duringRight = createPrefixingAction(createSynchCommunication("interrupt_" + self.name), createSkipAction());
	"line326".println();
	var During = createAction2("InterruptAction", duringLeft, duringRight);
	"line328".println();
	actionParaSeq.add(During.createActionPara("During"));
	
	
	
	var exitingAction1 = createAction2("InterruptAction", "SSTOP".createCallAction(), createPrefixingAction(createSynchCommunication("exit"), createSkipAction()));
	var exitingAction2 = self.createStateActionAsCircusAction("ExitAction");
	var exitingAction3 = createPrefixingAction(createSynchCommunication("exited"), "Inactive".createCallAction());
	var Exiting = createAction2("SeqAction", exitingAction1, createAction2("SeqAction", exitingAction2, exitingAction3));
	actionParaSeq.add(Exiting.createActionPara("Exiting"));
	
	var mainActionname = "Inactive";
	
	var basicProcess = actionParaSeq.createBasicProcess(mainActionname);
	return basicProcess;
}





operation Z!CircusAction createActionPara(name: String): Z!ActionPara{
	var para = new Z!ActionPara;
	para.name = name.createZName();
	para.circusAction = self;
	
	return para;
}


//to convert action list into a process
operation Sequence<Z!Para> createBasicProcess(mainActionName: String): Z!BasicProcess{
	
//	var list.paras = new Sequence<Z!Para>;
//	list.paras = self;
	var basicProcess = new Z!BasicProcess;
	
	basicProcess.mainAction = mainActionName.createCallAction();
	
	var list = new Z!ZParaList;
	basicProcess.paraList = list;
	basicProcess.paraList.paras = new Sequence<Z!Para>;
	basicProcess.paraList.paras = self;
		
	return basicProcess;
}




operation Sequence<Z!CircusAction> createSequenceAsExtchoiceAction(): Z!ExtChoiceAction{
	var extchoiceAction;
	var size = self.size();
	var i = 0;
	extchoiceAction = createAction2("ExtChoiceAction", self.at(0), self.at(1));
	i = i + 2;
	if(size > 2){
		while(i<size){
			extchoiceAction = createAction2("ExtChoiceAction", extchoiceAction, self.at(i));
			i = i + 1;
		}
	}
	return extchoiceAction;
}


//This is not used yet
operation Sequence<Z!CircusAction> createSequenceAsSeqAction(): Z!SeqAction{
	var seqAction;
	var size = self.size();
	var i = 0;
	seqAction = createAction2("SeqAction", self.at(0), self.at(1));
	i = i + 2;
	if(size > 2){
		while(i<size){
			seqAction = createAction2("SeqAction", seqAction, self.at(i));
			i = i + 1;
		}
	}
	return seqAction;
}


operation RC!NodeContainer vguards(): Set<String>{
	var vguards = new Set<String>;
	for (tr in self.transitions){
		vguards= vguards.includingAll(usedVariables(tr.condition));
	}

	return vguards;
}




//TO DO to confirm the Z type
//this version returns ChannelDecl
/*
operation  tevent(t: RC!Transition): Z!ChannelDecl{
 	
 	var chan_name;
 	var chan_type;

	if(t.trigger = null){
		chan_name = "internal." + t.source.name;
		chan_type = "SYNCH";
	} 
	
	//TO DO: to confirm if this "else" is necessary 
	//as trigger is only allowed when source= state 
	else {
		chan_name = t.trigger.event.name + "__." + t.source.name + "_in";
		chan_type = "SYNCH";
	}
	
	var channel = chan_name.createChannelDecl(chan_type);
	
	return channel;
}
*/






operation String createZName(): Z!ZName{
	var zname = new Z!ZName;
	zname.word = self;
	return zname;
}


operation createNameList(stringSet: Set<String>): Z!ZNameList{
	var nl = new Z!ZNameList;
	nl.names = new Sequence<ZName>;
	nl.names = Sequence{};
	
	for(str in stringSet){
		nl.names.add(str.createZName());
	}
	
	return nl;
}


//not used, replaced by above which take Set<String> as parameter
operation createNameList(nl_string: String): Z!ZNameList{
	var nl = new Z!ZNameList;
	nl.names = new Sequence<ZName>;
"line 185".println();
nl_string.println();
nl_string.length.println();
	
	//if the nl_string is empty string, then the returned list is an empty list.
	//i.e., nl.names = Sequence{}
	if(nl_string.length>1){
		var nl_seq = nl_string.split(",");
		"line191".println();
		nl_seq.println();
		for(name in nl_seq){
			nl.names.add(name.createZName());
		}
	} 

	return nl;
}



operation createShareAsCommunication(): Z!Communication{
	var commu = new Z!Communication;
	
	var chanExpr = new Z!RefExpr;
	var chanExpr = "share".createRefExpr(false,false);
	commu.channelExpr = chanExpr;
	commu.commPattern.name = "Synch";
	commu.commUsage.name = "Normal";
	commu.indexed = false;
	commu.multiSych = 0;
	
	return commu;
}

//TO DO: shall it be an actionPara or action?
operation createSStopActionPara(): Z!ActionPara{
	var actionPara = new Z!ActionPara;
	
	actionPara.name = "SStop".createZName();
	
	var commu = createShareAsCommunication();
	var callAction = "SStop".createCallAction();
	
	//this is a PrefixingAction
	
	actionPara.circusAction = createPrefixingAction(commu, callAction);
	
	return actionPara;
}

operation createPrefixingAction(
	commu: Z!Communication, 
	action: Z!CircusAction
	): Z!PrefixingAction{
	
	var prefixingAction = new Z!PrefixingAction;
	
	prefixingAction.communication  = commu;
	
	prefixingAction.circusAction = action;
	
	return prefixingAction;
}




operation String createAction1(type: String): Z!Action1{
	var action1 = new Z!Action1;
	
	return action1;
}

//binary circus action: not covering PrefixingAction
//TO DO: to complete other types of Action2
operation createAction2(
	type: String, 
	fst_action: Z!CircusAction, 
	snd_action: Z!CircusAction
	): Z!Action2{
	
	var action2;
	if(type = "InterruptAction"){
		//action2 = createInterruptAction(fst_action, snd_action);
		action2 = new Z!InterruptAction;
	} else
	if(type = "SeqAction"){
		action2 = new Z!SeqAction;
	} else
	if(type = "ExtChoiceAction"){
		action2 = new Z!ExtChoiceAction;
	} 	
	
	action2.leftAction = fst_action;

	action2.rightAction = snd_action;
//	action2.actionList = new Z!CircusActionList;
	
//	action2.actionList.circusActions = Sequence{action2.leftAction, action2.rightAction};
		
	return action2;
}


operation String createCallAction(): Z!CallAction{
	var callAction = new Z!CallAction;
	callAction.name = self.createZName();
	
	return callAction;
}



operation String createCallAction(list: Sequence<Z!Expr>): Z!CallAction{
	var callAction = new Z!CallAction;
	callAction.name = self.createZName();
	callAction.exprList =  new Z!ZExprList;
	callAction.exprList.exprs = list;
	
	return callAction;
}




operation RC!Transition createTrActionAsCircusAction(): Z!CircusAction{
	if(self.action != null){
		//return self.action.createStmtAsAction();
		return self.action.createStmtInContextAsAction();
	} else{
		return createSkipAction();
	}
}



//CSP Rule 62
operation readState(varSet: Set<String>, action: Z!CircusAction):Z!CircusAction{
	if(varSet.size()=0){
		return action;
	} else {
		
		var var_name = varSet.at(0);

		var commu = createInputCommunication("get_"+var_name, var_name);
		varSet.removeAt(0);	
		var prefixAction = createPrefixingAction(commu, readState(varSet,action));
		var leftAction = "SSTOP".createCallAction();
		
		var action1 = createAction2("InterruptAction", leftAction, prefixAction);
		return action1;
	}
}


//CSP Rule 63
operation readStateAtomic(varSet: Set<String>, action: Z!CircusAction):Z!CircusAction{
	if(varSet.size()=0){
		return action;
	} else {
		
		var var_name = varSet.at(0);
		var commu = createInputCommunication("get_"+var_name, var_name);
		varSet.removeAt(0);	
		var prefixAction = createPrefixingAction(commu, readStateAtomic(varSet,action));
		
		return prefixAction;
	}
}


//CSP Rule 64
operation readStateA(varSet: Set<String>, action: Z!CircusAction):Z!CircusAction{
	if(varSet.size()=0){
		return action;
	} else {
		
		var var_name = varSet.at(0);

		var commu = createInputCommunication("get_"+var_name, var_name);
		varSet.removeAt(0);	
		var prefixAction = createPrefixingAction(commu, readStateAtomic(varSet,action));
		var leftAction = "SSTOP".createCallAction();
		
		var action1 = createAction2("InterruptAction", leftAction, prefixAction);
		return action1;
	}
}




//to create a internal input communication 
//used in readState()
operation createInputCommunication(
	chan_name: String,
	var_name:String
	): Z!Communication{
	
	var commu = new Z!Communication;

	commu.commUsage = Z!CommUsage#Normal;
	commu.indexed = false;
	commu.multiSych = 0;
	commu.channelExpr = chan_name.createRefExpr(false,false);
	
	commu.commPattern = Z!CommPattern#Input;
	commu.fieldList = new Z!CircusFieldList; 
		
	var field = new Z!InputField;
	field.varialbeName = var_name.createZName();
	commu.fieldList.fields = Sequence{field};
	
//	if(type = "INPUT"){ 
//		commu.commPattern = Z!CommPattern#Input;
//
//		var field = new Z!InputField;
//		field.varialbeName = var_name.createZName();
//		commu.fieldList.fields = Sequence{field};
//	} 
	

	
	return commu;
}


//to create a internal output communication, can be outputfield !, or dotfield .
//used in Rule 69 for output and Sync type of RoboChart Communiation
operation createOutputCommunication(
	chan_name: String,
	expr:RC!Expression,
	type: String
	): Z!Communication{
	
	var commu = new Z!Communication;

	commu.commUsage = Z!CommUsage#Normal;
	commu.indexed = false;
	commu.multiSych = 0;
	commu.channelExpr = chan_name.createRefExpr(false,false);

	commu.fieldList = new Z!CircusFieldList; 
		
	
	commu.commPattern = Z!CommPattern#Output;		
	var field = new Z!DotField;
	field.expr = expr.createExpr();
		
	if(type = "OUTPUT"){ 
		field.outputField = true;
	} else
	if(type = "SYNC"){ 
		field.outputField = false;
	}
	
	commu.fieldList.fields = Sequence{field};
	
	return commu;
}



//to create a internal sync communication 
operation createSynchCommunication(
	channel_name:String
	): Z!Communication{
	
	var commu = new Z!Communication;
	commu.commUsage = Z!CommUsage#Normal;
	commu.indexed = false;
	commu.multiSych = 0;
	commu.channelExpr = channel_name.createRefExpr(false,false);
	commu.fieldList = new Z!CircusFieldList; 
	
	commu.commPattern = Z!CommPattern#Synch;
	commu.fieldList.fields = Sequence{};		
		
	return commu;
}




//CSP Rule 65
operation RC!Statement createStmtInContextAsAction(): Z!CircusAction{

	return readState(usedVariables(self), self.createStmtAsAction());
}

//CSP Rule 65_1
operation RC!Statement createStmtAsAction(): Z!CircusAction{
	if(self.instanceOf(RC!Assignment)){
		return self.createAssignmentStmtAsAction();
	} else
	if(self.instanceOf(RC!Call)){
		return self.createCallStmtAsAction();
	} else
	if(self.instanceOf(RC!Skip)){
		return self.createSkipStmtAsAction();
	} else
	if(self.instanceOf(RC!CommunicationStmt)){
		return self.createCommuStmtAsAction();
	} else
	if(self.instanceOf(RC!ParStmt)){
		return self.createParStmtAsAction();
	} else
	if(self.instanceOf(RC!IfStmt)){
		"line956".println();
		("predicate = "+ self.expression).println();
		"line958".println();
		return self.createIfStmtAsAction();
	} else
	if(self.instanceOf(RC!SeqStatement)){
		return self.createSeqStmtAsAction();
	} 
}




//CSP Rule 66
operation RC!Assignment createAssignmentStmtAsAction(): Z!InterruptAction{
	
	/*
	assignment is an interrupt actio in Circus
	left action is SStop
	right action is a prefixing action
	*/
	
	/* CallAction permits a name to be an action.
	*/
	var leftAction = "SSTOP".createCallAction();
	var chan_name = "set_" + self.left.name.name;
	var prefix = createOutputCommunication(chan_name, self.right, "OUTPUT");
	
	var rightAction = createPrefixingAction(prefix, createSkipAction());
//	var rightAction = createPrefixingAction(self.createCommunication("",""), createSkipAction()); //PrefixingAction is a type of Action1, so can not use createAction2()

	var circusAction = createAction2("InterruptAction", leftAction, rightAction);
	
	return circusAction;
}



//CSP Rule 67
operation RC!Call createCallStmtAsAction(): Z!CircusAction{
	
	var list = new Sequence<Z!Expr>;
	
	for(elem in self.args){
		list.add(elem.createExpr());
	}
	var circusAction = self.`operation`.name.createCallAction(list);
	
	return circusAction;
}



//CSP Rule 68
operation RC!IfStmt createIfStmtAsAction(): Z!IfGuardedCommand{
	
	var if_expr = self.expression;
		"line999".println();
	self.expression.println();
//		var ifAction = createGuardedAction(pred_expr, self.then.createStmtAsAction());
	var if_pred = self.expression.createExpr().createMemPredEquality();
	
	var ifActionInContext = createGuardedAction(if_pred, self.then.createStmtInContextAsAction());
	
	var else_expr = new RC!Not;
	else_expr.exp = clone(if_expr);
	//else_pred.exp = self.expression;

	var pred_else = else_expr.createExpr().createMemPredEquality();
	
	var elseActionInContext = createGuardedAction(pred_else, self.`else`.createStmtInContextAsAction());
	
	var actions = Sequence{ifActionInContext, elseActionInContext};
	
	
	var action = createIFGuardedCommand(actions);
	
	return action;
}


operation createIFGuardedCommand(actions: Sequence<Z!GuardedAction>): Z!IfGuardedCommand{
	var action = new Z!IfGuardedCommand;
	action.actionList = new Z!CircusActionList;
	action.actionList.circusActions = actions;
	
	return action;
}


operation clone(exp : RC!Expression) : RC!Expression   {
	var emfTool = new Native("org.eclipse.epsilon.emc.emf.tools.EmfTool");
	var ecoreUtil = emfTool.ecoreUtil;
	var cloned = ecoreUtil.copy(exp);
	return cloned;
}



operation if_pred(actions: Sequence<Z!GuardedAction>): Z!IfGuardedCommand{
	var action = new Z!IfGuardedCommand;
	action.actionList = new Z!CircusActionList;
	action.actionList.circusActions = actions;
	
	return action;
}

operation createGuardedAction(
	pred: Z!Pred, 
	action: Z!CircusAction
	): Z!GuardedAction{
	var guardedaction = new Z!GuardedAction;
	
	guardedaction.pred = pred;
	guardedaction.circusAction = action;
	return guardedaction;
}





//
//operation String createRCRefExp():RC!RefExp{
//
// 	var refExp = new RC!RefExp;
// 	refExp.ref = new RC!Variable;
// 	refExp.ref.name = self;
// 	
// 	return refExp;
//}


//CSP Rule 69
operation RC!CommunicationStmt createCommuStmtAsAction(): Z!CircusAction{

	
	if(self.communication._type.name = "INPUT"){
		"this is an INPUT type communication".println();
		return self.communication.createCommuINPUTAsAction();
	} else

	if(self.communication._type.name = "OUTPUT" or self.communication._type.name = "SYNC"){
		"this is an OUTPUT or SYNC type communication".println();
		return self.communication.createCommuOUTPUT_SYNCAsAction();
//		if(self.communication.value.isTypeOf(RC!RefExp)){
//			return self.communication.createCommuOUTPUT_SYNCRefAsAction();
//		} else{
//			return self.communication.createCommuOUTPUT_SYNCConcreteAsAction();
//		}
	} else
	
	if(self.communication._type.name = "SIMPLE"){
		"this is an SIMPLE type communication".println();
		return self.communication.createCommuSIMPLEAsAction();
	} 

}

//CSP Rule 69 - RC commu.type = Input
operation RC!Communication createCommuINPUTAsAction(): Z!InterruptAction{
	/*
	CommunicationStmt is an interrupt action in Circus
	left action is SStop
	right action is a prefixing action
	*/
	var leftAction = "SSTOP".createCallAction();
	

//	/*to create inner-layer prefixing of the prefixingAction,i.e., the setting part
//	e.g., set_input!input
//	we need to create an internal RC!Communication of OUTPUT type first*/
//	var inner_RC_commu = new RC!Communication;//set_input!input
//	
//	inner_RC_commu.event = new RC!Event;
//	inner_RC_commu.event.name = "set_"+ self.parameter.name;
//	
//	inner_RC_commu.value =  self.parameter.name.createRCRefExp();
//
//	inner_RC_commu._type = CommunicationType#OUTPUT;
//	
//	/*End of internal RC!Communication creation*/
		
//	var inner_prefix = inner_RC_commu.createCommunication(inner_RC_commu.event.name,"OUTPUT");

	var chan_name = "set_" + self.parameter.name;
	var expr_string = self.parameter.name;
	var inner_prefix = createOutputCommunicationFromString(chan_name, expr_string);
	
//	var expr = self.parameter.name.createRefExpr(false,false);
//	var inner_prefix = createOutputCommunication(chan_name, expr, "OUTPUT");
//	var inner_prefix = createOutputCommunicationFromString("set_" + self.parameter.name, self.parameter.name);


	var inner_prefix_action = createPrefixingAction(inner_prefix, createSkipAction());
	var inner_interrupt_action = createAction2("InterruptAction", "SSTOP".createCallAction(),inner_prefix_action);
	
	var outer_prefix = self.createCommuAsCommunication(self.event.name + "_in","INPUT");
	var outer_prefix_action = createPrefixingAction(outer_prefix, inner_interrupt_action);
	
	var circusAction = createAction2("InterruptAction", leftAction, outer_prefix_action);
	
	return circusAction;
}




operation createOutputCommunicationFromString(
	chan_name: String,
	expr_string:String
	): Z!Communication{
	
	var commu = new Z!Communication;

	commu.commUsage = Z!CommUsage#Normal;
	commu.indexed = false;
	commu.multiSych = 0;
	commu.channelExpr = chan_name.createRefExpr(false,false);

	commu.fieldList = new Z!CircusFieldList; 
		
	
	commu.commPattern = Z!CommPattern#Output;		
	var field = new Z!DotField;
	field.expr = expr_string.createRefExpr(false,false);
	field.outputField = true;
//	if(type = "OUTPUT"){ 
//		field.outputField = true;
//	} else
//	if(type = "Sync"){ 
//		field.outputField = false;
//	}
	
	commu.fieldList.fields = Sequence{field};
	
	return commu;
}




//CSP Rule 69 - RC commu.type = Output/Sync
operation RC!Communication createCommuOUTPUT_SYNCAsAction(): Z!InterruptAction{
	
	/*
	CommunicationStmt is an interrupt action in Circus
	left action is SStop
	right action is a prefixing action
	*/
	
	

	/*to create prefixing of the prefixingAction,i.e., the setting part
	e.g., status_out!input, status_out.input
	*/
//	var inner_RC_commu = new RC!Communication;//set_input!input
//	
//	inner_RC_commu.event = new RC!Event;
//	inner_RC_commu.event.name = self.event.name + "_out";
//	inner_RC_commu.value = self.value.ref.name.createRCRefExp();
//	inner_RC_commu._type = self._type;

	
//	var inner_prefix = inner_RC_commu.createCommunication(inner_RC_commu.event.name,self._type.name);
	
	var prefix = createOutputCommunication(self.event.name + "_out", self.value, self._type.name);
	
	var prefix_action = createPrefixingAction(prefix, createSkipAction());
	var interrupt_action = createAction2("InterruptAction", "SSTOP".createCallAction(), prefix_action);
		
	return interrupt_action;
}


//CSP Rule 69 - 3:  RC comm.type = simple
operation RC!Communication createCommuSIMPLEAsAction(): Z!InterruptAction{

	var prefix = self.createCommuAsCommunication(self.event.name+"_out","SIMPLE");

	var prefix_action = createPrefixingAction(prefix, createSkipAction());
	
	var circusAction = createAction2("InterruptAction", "SSTOP".createCallAction(), prefix_action);
	
	return circusAction;	

}


//not necessary
//status_out!6; status_out.6
//operation RC!Communication createCommuOUTPUT_SYNCConcreteAsAction(): Z!InterruptAction{
//	
	/*
	CommunicationStmt is an interrupt action in Circus
	left action is SStop
	right action is a prefixing action
	*/
//	var leftAction = "SSTOP".createCallAction();
//			
//	var prefix = self.createCommunication(self.event.name + "_out",self._type.name);
//	var prefix_action = createPrefixingAction(prefix, createSkipAction());
//	
//	var circusAction = createAction2("InterruptAction", leftAction, prefix_action);
//	
//	return circusAction;
//}


//operation Any createCommunication(
//			channel_name:String, 
//			type:String
//			):Z!Communication{
//	var commu;
//	
//	if(self.EClass().name = "Assignment"){
//		commu = self.createAssignmentAsOutputCommunication();
//	} else
//	if(self.EClass().name = "Communication"){
//		commu = self.createCommuAsCommunication(channel_name, type);
//		("line 511, this commu pattern is "+ commu.commPattern).println();
//	}
//	return commu;
//}



operation String createInputField(): Z!InputField{
	var field = new Z!InputField;
	field.varialbeName = self.createZName();
	//var name = new String;
//	if(self._type = CommunicationType#INPUT){
//		inputField.varialbeName = self.parameter.name.createZName();
//	} else
//	if(self._type = CommunicationType#OUTPUT){
//		inputField.varialbeName = self.value.ref.name.createZName();
//	} 
	
	return field;
}


operation RC!Expression createOutputField(): Z!DotField{
	var field = new Z!DotField;
	field.expr = self.createExpr();
	field.outputField = true;
	return field;
}


operation RC!Expression createDotField(): Z!DotField{
	var field = new Z!DotField;
	field.expr = self.createExpr();
	field.outputField = false;
	return field;
}
 
////this is used for the communication statement
//operation RC!Communication createOutputField(): Z!DotField{
//	var field = new Z!DotField;
//	var expr;
//	if(self._type = CommunicationType#INPUT){
//	("self.parameter: "+self.parameter).println();
//		expr = self.parameter.name.createRefExpr(false,false);
//	} else
//	if(self._type = CommunicationType#OUTPUT or self._type = CommunicationType#SYNC){
//
////		if(self.value.type().name = "RefExp"){
////			expr = self.value.ref.name.createRefExpr(false,false);		
////		} else{
////			//expr = self.value.createNumExpr(); //the output can be any expr, not only a var or a concreate number
////			expr = self.value.createExpr();
////		}
//		expr = self.value.createExpr();
//	
//	}
//	field.expr = expr;
//	field.outputField = true;
//	
//	return field;
//}


//operation RC!Communication createDotField(): Z!DotField{
//	var dotField = new Z!DotField;
//	dotField.outputField = false;
//	
//	dotField.expr = self.value.createExpr();
////	if(self.value.type().name = "RefExp"){
////		dotField.expr = self.value.ref.name.createRefExpr(false,false);		
////	} else{
////		dotField.expr = self.value.createNumExpr();
////	}
//	
//	return dotField;
//}




//operation RC!Communication createInputField(): Z!InputField{
//	var inputField = new Z!InputField;
//	var name = new String;
//	if(self._type = CommunicationType#INPUT){
//		inputField.varialbeName = self.parameter.name.createZName();
//	} else
//	if(self._type = CommunicationType#OUTPUT){
//		inputField.varialbeName = self.value.ref.name.createZName();
//	} 
//	
//	return inputField;
//}



//operation RC!Assignment createAssignmentAsOutputCommunication():Z!Communication{
//	var commu = new Z!Communication;
//	
//	commu.commUsage = Z!CommUsage#Normal;
//	commu.indexed = false;
//	commu.multiSych = 0;
//	commu.commPattern = Z!CommPattern#Output;	
//	("line 588 commPattern = "+commu.commPattern).println();
//	commu.channelExpr = ("set_" + self.left.name.name).createRefExpr(false,false);
//	
//	commu.fieldList = new Z!CircusFieldList;
//	commu.fieldList.fields = Sequence{self.right.createOutputField()};
//
//	return commu;
//}


//RoboChart Commu to Circus Commu
operation RC!Communication createCommuAsCommunication(
	channel_name:String,
	type:String
	): Z!Communication{
	
	var commu = new Z!Communication;

	commu.commUsage = Z!CommUsage#Normal;
	commu.indexed = false;
	commu.multiSych = 0;
	commu.channelExpr = channel_name.createRefExpr(false,false);
	commu.fieldList = new Z!CircusFieldList; 
	
	if(type = "INPUT"){ 
		commu.commPattern = Z!CommPattern#Input;
		commu.fieldList.fields = Sequence{self.parameter.name.createInputField()};
//		commu.fieldList.fields = Sequence{self.createInputField()};
	} else
	
	if(type = "OUTPUT"){ 
		commu.commPattern = Z!CommPattern#Output;
		"line1383".println();
		self.println();
		self._type.println();
		commu.fieldList.fields = Sequence{self.value.createOutputField()};
	} else
	
	if(type = "SIMPLE"){ 
		commu.commPattern = Z!CommPattern#Synch;
		commu.fieldList.fields = Sequence{};		
	} else
	
	if(type = "SYNC"){
		commu.commPattern = Z!CommPattern#Output;
		commu.fieldList.fields = Sequence{self.value.createDotField()};		
	} 
	
	return commu;
}



//CSP Rule 70
operation RC!SeqStatement createSeqStmtAsAction(): Z!CircusAction{
	var seq = self.statements;
	return seq.createSeqAsAction();

}

//CSP Rule 70 - auxilary
operation OrderedSet<Any> createSeqAsAction(): Z!CircusAction{
	var seq = self.clone();
	if(seq.size()= 0){
		return null; //TO DO: need to confirm
	} else
	if(seq.size()= 1){
		//return seq.at(0).createStmtAsAction();
		return seq.at(0).createStmtInContextAsAction();
		
	} else	
	if(seq.size()>1){
//		var leftAction = seq.at(0).createStmtAsAction();
		var leftAction = seq.at(0).createStmtInContextAsAction();
		seq.removeAt(0);
		var rightAction = seq.createSeqAsAction();
		return createAction2("SeqAction", leftAction, rightAction);

	}
}




//CSP Rule 71
operation RC!Skip createSkipStmtAsAction(): Z!InterruptAction{

	var leftAction = "SSTOP".createCallAction();
	var rightAction = createSkipAction();
	var circusAction = createAction2("InterruptAction", leftAction, rightAction);
	
	return circusAction;
}


//CSP Rule 72
//parenthesis is removed in Circus
operation RC!ParStmt createParStmtAsAction(): Z!CircusAction{
	return self.stmt.createStmtInContextAsAction();
}




//CSP Rule 73
operation RC!State createStateActionAsCircusAction(actionType:String): Z!CircusAction{
	
	if(self.stateActionDefined(actionType)){
		var index = self.indexOfStateAction(actionType);
		
		"line910".println();
		("actionType = " + actionType).println();
		("index = " + index).println();
		self.name.println();
		return self.actions.at(index).action.createStmtInContextAsAction();
	} else{
		return createSkipAction();
	}
}

//to check if the specific type (actionType) of state action is defined
operation RC!State stateActionDefined(actionType: String): Boolean{
	var bool = false;
	if(self.actions.size()>0){
		for(act in self.actions){
			if(act.type().name = actionType){
				bool = true;
			}
		}
	} 
	return bool;
}




operation RC!State indexOfStateAction(actionType: String): Integer{
	var index = 0;
	
	for(act in self.actions){
		if(act.type().name = actionType){
			return index;
		} else{
			index++;
		}
	}
	
}



//TO DO: to confirm if this is used: No
//operation RC!Communication createCommuAsAction(): Z!CircusAction{
//
//	if(self._type.name = "INPUT"){
//		"this is an INPUT type communication".println();
//		return self.createCommuINPUTAsAction();
//	} else
//
//	if(self._type.name = "OUTPUT" or self.communication._type.name = "SYNC"){
//		"this is an OUTPUT or SYNC type communication".println();
//		return self.createCommuOUTPUT_SYNCRefAsAction();
////		if(self.value.isTypeOf(RefExp)){
////			return self.createCommuOUTPUT_SYNCRefAsAction();
////		} else{
////			return self.createCommuOUTPUT_SYNCConcreteAsAction();
////		}
//	} else
//	
//	if(self._type.name = "SIMPLE"){
//		"this is an SIMPLE type communication".println();
//		return self.createCommuSIMPLEAsAction();
//	} 
//
//}






operation createSkipAction(): Z!SkipAction {
	var skipAction = new Z!SkipAction;
	return skipAction;
}



operation String createRefExpr(explicit: Boolean, mixFix: Boolean): Z!RefExpr{
	var refExpr = new Z!RefExpr;
	refExpr.mixFix = mixFix;
	refExpr.explicit = explicit;
	refExpr.name = self.createZName();
	refExpr.name.word = self;
	
	return refExpr;

}

operation RC!BooleanExp createBooleanExpr(): Z!RefExpr{
	var boolExpr = new Z!RefExpr;
	boolExpr.mixFix = false;
	boolExpr.explicit = false;
	boolExpr.name = new Z!ZName;
	if(self.value = "true"){
		boolExpr.name.word ="True";
	} else {
		boolExpr.name.word ="False";
	}
	
	return boolExpr;
}

operation  RC!IntegerExp createNumExpr(): Z!NumExpr{
	var numExpr = new Z!NumExpr;
	numExpr.numeral = new Z!ZNumeral;
	numExpr.numeral.value = self.value;
	
	return numExpr;
}
	
/*
operation RC!Minus createMinusExpr(){
				
	var minus_left = self.left.createNumExpr();
	var minus_right = self.right.createNumExpr();
				
	var minusExpr = new Z!ApplExpr;
	minusExpr.mixFix = true;
				
	minusExpr.leftExpr = "_-_".createRefExpr(false,false);

				
	minusExpr.rightExpr = new Z!TupleExpr;
	minusExpr.rightExpr.exprList = new Z!ZExprList;
	minusExpr.rightExpr.exprList.exprs = Sequence{minus_left, minus_right};
	minusExpr.rightExpr.exprList.exprs.println();
}
*/

/*
operation RC!LessOrEqual createLessOrEqualExpr() {
	var left = self.left.createNumExpr();
	var right = self.right.createNumExpr();
	var lessOrEqualExpr = new Z!ApplExpr;
	lessOrEqualExpr.mixFix = true;
				
	lessOrEqualExpr.leftExpr = "_leq_".createRefExpr(false,false);
							
	lessOrEqualExpr.rightExpr = Sequence{left, right}.createTupleExpr();
}
*/

operation Any createApplExpr(operator: String): Z!ApplExpr{
	var expr = new Z!ApplExpr;
	expr.mixFix = true;
	
	var operand_left = self.left.createExpr();
	var operand_right = self.right.createExpr();

	expr.leftExpr = operator.createRefExpr(false,false);
	expr.rightExpr = Sequence{operand_left, operand_right}.createTupleExpr();	
//	var left = operator.createRefExpr(false,false);
//	var right = Sequence{operand_left, operand_right}.createTupleExpr();	

//	expr.exprList = new Z!ZExprList;
//	expr.exprList.exprs = Sequence{left, right};
	
	return 	expr;
}





//covers Neg, Not
//TO DO: is there other unaryApplExpr?
operation Any createUnaryApplExpr(operator: String): Z!ApplExpr{

	var expr = new Z!ApplExpr;
	expr.mixFix = true;
	
	expr.leftExpr = operator.createRefExpr(false,false);
	
	if(self.isTypeOf(Neg) or self.isTypeOf(Not)){
		expr.rightExpr = self.exp.createExpr();
	} 
		
//	expr.exprList = new Z!ZExprList;
//	expr.exprList.exprs = Sequence{expr.leftExpr, expr.rightExpr};

	return 	expr;
}

operation RC!LessThan createLessThanExpr():Z!ApplExpr{
	return self.createApplExpr("_less_");
}


operation RC!GreaterThan createGreaterThanExpr():Z!ApplExpr{
	return self.createApplExpr("_greater_");
}


operation RC!LessOrEqual createLessOrEqualExpr():Z!ApplExpr{
	return self.createApplExpr("_leq_");
}

operation RC!GreaterOrEqual createGreaterOrEqualExpr():Z!ApplExpr{
	return self.createApplExpr("_geq_");
}

operation RC!Equals createEqualsExpr():Z!ApplExpr{
	return self.createApplExpr("_equals_");
}

operation RC!Different createNequalExpr():Z!ApplExpr{
	return self.createApplExpr("_nequals_");
}


operation RC!And createAndExpr():Z!ApplExpr{
	return self.createApplExpr("_And_");
}

operation RC!Or createOrExpr():Z!ApplExpr{
	return self.createApplExpr("_Or_");
}



operation RC!Iff createIffExpr():Z!ApplExpr{
	return self.createApplExpr("_Equivalence_");
}

operation RC!Implies createImpliesExpr():Z!ApplExpr{
	return self.createApplExpr("_Implies_");
}


operation RC!Not createNotExpr():Z!ApplExpr{
	return self.createUnaryApplExpr("not_");
}	


operation RC!Plus createPlusExpr():Z!ApplExpr{
	return self.createApplExpr("_+_");
}

operation RC!Minus createMinusExpr():Z!ApplExpr{
	return self.createApplExpr("_-_");
}

operation RC!Mult createMultExpr():Z!ApplExpr{
	return self.createApplExpr("_*_");
}

operation RC!Div createDivExpr():Z!ApplExpr{
	return self.createApplExpr("_div_");
}

operation RC!Modulus createModExpr():Z!ApplExpr{
	return self.createApplExpr("_mod_");
}


 	
operation RC!Neg createNegExpr():Z!ApplExpr{
	return self.createUnaryApplExpr("-_");
}	




//TO DO: shall this be an ApplExpr instead??
operation RC!IfExpression createCondExpr():Z!CondExpr{

}

//TO DO: what class in Z?
operation RC!FloatExp createFloatExpr():Z!Expr{

}

//TO DO: what class in Z?
operation RC!VarExp createVarExpr():Z!Expr{

}

//TO DO: what class in Z?
operation RC!CallExp createCallExpr():Z!Expr{

}




operation RC!Expression createExpr():Z!Expr{
	if(self.isTypeOf(RC!LessThan)){
		return self.createLessThanExpr();
	} else 
	if(self.isTypeOf(RC!GreaterThan)){
		return self.createGreaterThanExpr();
	} else 
	if(self.isTypeOf(RC!LessOrEqual)){
		return self.createLessOrEqualExpr();
	} else 
	if(self.isTypeOf(RC!GreaterOrEqual)){
		return self.createGreaterOrEqualExpr();
	} else 
	if(self.isTypeOf(RC!Equals)){
		return self.createEqualsExpr();
	} else 
	if(self.isTypeOf(RC!Different)){
		return self.createNequalExpr();
	} else 
	if (self.isTypeOf(RC!And)){
		return self.createAndExpr();
	} else 
	if (self.isTypeOf(RC!Or)){
		return self.createOrExpr();
	} else 
	if (self.isTypeOf(RC!Not)){
		return self.createNotExpr();
	} else 
	if (self.isTypeOf(RC!Plus)){
		return self.createPlusExpr();
	} else 
	if (self.isTypeOf(RC!Minus)){
		return self.createMinusExpr();
	} else 
	if (self.isTypeOf(RC!Mult)){
		return self.createMultExpr();
	} else 
	if (self.isTypeOf(RC!Div)){
		return self.createDivExpr();
	} else
	if (self.isTypeOf(RC!Modulus)){
		return self.createModExpr();
	} else
	if (self.isTypeOf(RC!Neg)){
		return self.createNegExpr();
	} else
	if(self.isTypeOf(RC!Iff)){
	 return self.createIffExpr();
	} else
	if(self.isTypeOf(RC!Implies)){
		return self.createImpliesExpr();
	} else
	if(self.isTypeOf(RC!IfExpression)){
		return self.createCondExpr();
	} else
	if(self.isTypeOf(RC!IntegerExp) or self.isTypeOf(RC!RefExp) or self.isTypeOf(RC!BooleanExp) or self.isTypeOf(RC!CallExp)  or self.isTypeOf(RC!ResultExp) or self.isTypeOf(RC!Selection) or self.isTypeOf(RC!EnumExp) or self.isTypeOf(RC!ArrayExp) or self.isTypeOf(RC!TupleExp) or self.isTypeOf(RC!ClockExp) or self.isTypeOf(RC!SeqExp) ){
		return self.createUnaryExpr();
	} else 
	if(self.isTypeOf(RC!ParExp)){
		return self.exp.createExpr();
	}

}



operation Sequence<Any> createTupleExpr(): Z!TupleExpr{
	var tupleExpr = new Z!TupleExpr;
	tupleExpr.exprList = new Z!ZExprList;
	tupleExpr.exprList.exprs.println();
	tupleExpr.exprList.exprs = self;
	return tupleExpr;

}


operation RC!Expression createUnaryExpr(): Z!Expr {
	if(self.isTypeOf(RC!IntegerExp)){
		return self.createNumExpr();
	} else

	if(self.isTypeOf(RC!BooleanExp)){
		return self.createBooleanExpr();
	} 
	else

 	if(self.isTypeOf(RC!RefExp)){
		//self.ref.name.println();
		return self.ref.name.createRefExpr(false, false);
	} 
	//TO DO: to complete the following unaryExpr of RoboChart
	/*else 
	
	if(self.isTypeOf(CallExp)){
		//self.callExpString().println();
		return self.callExpString();
	} else 
	
	if(self.isTypeOf(ResultExp)){
		return "result";
	} else 
	
	if(self.isTypeOf(Selection)){
		return self.member.name+"("+self.receiver.value.ref.name+"!"+self.receiver.parameters.at(0).ref.name+")";
	} else 
	
	if(self.isTypeOf(EnumExp)){
		return self.literal.name;
	} else 
	
	if(self.isTypeOf(SeqExp)){
		return self.sequenceString();
	} else 
	
	if(self.isTypeOf(ArrayExp)){
		return self.value.ref.name + "."+self.parameters.at(0).value;
		//e.g., vel[1] -> vel.1
	} else 
	
	if(self.isTypeOf(TupleExp)){
		return "("+ self.values.at(0).oneSideOfBianryString()+", "+self.values.at(1).oneSideOfBianryString() +")";
		//e.g., (3,4)
	} else 
	
	if(self.isTypeOf(ClockExp)){
		return "clock";
	}
*/
}