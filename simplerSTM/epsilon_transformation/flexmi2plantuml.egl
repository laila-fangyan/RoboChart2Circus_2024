[%import "shared.eol";%]
[%import "ecoreutil.eol";%]

@startuml
[%var elements = M.allInstances();%]

[*identify allowmixing feature*]
[%if(allowMixing()){%]allow_mixing[%}%]


[*identify diagram direction*]
[%=d.getDirection()%]

[*Generate node shapes, and as compartment if annotated as compartment
because createShape() is a recursive function, we only iterate d.eContents, i.e., the elements directly contained in d,
other nodes that are further indirectly contained will be processed through recursively calling createShape() *]
[%for (e in d.eContents.select(e|e.isNode())){%]
	[%e.createShape();%]
[%}%]

	
[*Generate links for link elements*]
[%for (l in elements.select(l|l.isLink())){%]
	[%if(l.getSource().isDefined() and l.getTarget().isDefined()) {%]
		[%=l.getSource().getNodeId()%] -[%=l.getLineThickness()%][%=l.getLinkDir()%]->[%=l.getTarget().getNodeId()%] [*next, to output #*][%if(l.getColor().isDefined() or l.getLineStyle().isDefined() or (l.getLabel().isDefined() and  l.getTextColor().isDefined())){%] #[%}%][*next to output getColor With or Without ';'*][%if(l.getColor().isDefined() and (l.getLineStyle().isDefined() or (l.getLabel().isDefined() and l.getTextColor().isDefined()))){%][%=l.getColor()%];[%}%][%else {%][%=l.getColor()%][%}%][%=l.getLineStyle()%][%if(l.getLabel().isDefined()){%][%=l.getTextColor()%] : [%=l.getLabel()%]	[%}%]
	
	[%}%]
[%}%]

[*search each node "e", to Generate an edge for every NON-CONTAINMENT reference 'ref' in the node, the edge link the node and the ref in it.  Omitting opposites*]
[%for (e in elements.select(e|e.isNode())) {%]
[*e is the node to be examined, it has references*]
	[%for (r in e.getReferenced()) {%]
		[*for every target, we generate a link*]
		[*e.getReferenced() returns a sequence of sequences*]
		[*each r is a sequence containing two members*]	
		[*r.at(0) is instances that e references in FLEXMI MODEL*]
		[%for (v in r.at(0).select(r|M.allInstances().includes(r))){%]
			[*each v is the instance in FLEXMI MODEL that e references (both val and ref)*]
			[*e.g., v: Object [name=Apple] or v: Object [name=Ball]*]
			[%var displayReferenceLabel = r.at(1).isLink() and r.at(1).getLabel().isDefined();%]
			[%if (r.at(1).isLink()){%]
					[%=e.getNodeId()%] -[%=r.at(1).getLineThickness()%][%=r.at(1).getLinkDir()%]->[%=v.getNodeId()%] [*next, to output #*][%if(r.at(1).getColor().isDefined() or r.at(1).getLineStyle().isDefined() or ((getReferenceLabel(e, v, r.at(1)).isDefined() and displayReferenceLabel)and r.at(1).getTextColor().isDefined())){%] #[%}%][*next to output getColor With or Without ';'*][%if(r.at(1).getColor().isDefined() and (r.at(1).getLineStyle().isDefined() or ((getReferenceLabel(e, v, r.at(1)).isDefined() and displayReferenceLabel) and r.at(1).getTextColor().isDefined()))){%][%=r.at(1).getColor()%];[%}%][%else {%][%=r.at(1).getColor()%][%}%][%=r.at(1).getLineStyle()%][%if(getReferenceLabel(e, v, r.at(1)).isDefined() and displayReferenceLabel){%][%=r.at(1).getTextColor()%] [%=getReferenceLabel(e, v, r.at(1))%]	[%}%]	
			[%}%]
		[%}%]
	[%}%]
[%}%]


@enduml


[%operation Any createShape(){%]

	[%//To identify if self (e) is a package
	var isPackage = false; //true when there is at least one contained reference which is annotated with "picto.compartment"
	var hasNestedNodeAsLink = false;
	var compartmentVisible; //set to true if the user allow the compartment to be visible
	
	for (r in self.eClass.eAllReferences.select(l|l.containment)){
		for (anno in r.eAnnotations.source){
			if (anno = "picto.compartment"){
	    		isPackage = true;
	    	} else if(anno = "picto.link"){
				hasNestedNodeAsLink = true;
			}
		}
	}%]

	[*shape creation for the node self, when not allowmixing (i.e., no object or class is used)*]
	[%if (not allowMixing()) {%][*all the annotations for node are supported*]
		[%=self.getShape()%] "[%=self.getLabel()%]" as [%=self.getNodeId()%] [%if(self.getColor().isDefined() or self.getLineStyle().isDefined() or self.getLineColor().isDefined() or self.getTextColor().isDefined() ){%] #[%}%][%if(self.getColor().isDefined() and (self.getLineStyle().isDefined() or self.getLineColor().isDefined() or self.getTextColor().isDefined())){%][%=self.getColor()%];[%}%][%else {%][%=self.getColor()%][%}%][%=self.getLineStyle()%][%=self.getLineColor()%][%=self.getTextColor()%][*next consider whether '{}' is needed, if this node is a package, then yes. The left '{' must be in the same line of the annotation of the node*][%if(isPackage){%]{[%}%]
	[%} else {%][*allowmixing = true, only shape color is supported*]
		[%if (not(self.getShape() = "object" or self.getShape() = "class")){%]
			[%=self.getShape()%] "[%=self.getLabel()%]" as [%=self.getNodeId()%] [%if(self.getColor().isDefined()){%] #[%=self.getColor()%][%if(isPackage){%]{[%}%]
			[%}%]
		[%} else{%] [*Generate object/class nodes, attributes are included, but can not be annotated as compartment, so the line '[%if(isPackage){%]{[%}%]' is not repeated in this else clause*]
        	[% var attributes = self.eClass().getEAllAttributes(); %]
			[%=self.getShape()%] "[%=self.getLabel()%]" as [%=self.getNodeId()%] [%if(self.getColor().isDefined()){%] #[%=self.getColor()%][%}%][%if(attributes.size()>0){%] {

			[%for (attr in attributes){%]
    			[%=attr.name%] = [%=self.getAttributeValue(attr)%]
   			[%}%]
			}
	[%}}}%]
	
	[*Generate compartment nodes  for the package.*]	
	[*we have created left brace '{' at the end of line 76 (not allowMixing) and 79 (allowMixing), now we need to create the shapes for contained nodes with or without the compartment, and the right brace '}' *]
	[%if(isPackage){%]
		[%for (r in self.eClass.getCompartmentReferences()){%]
			
			[*before creating the shapes for the contained nodes, we need to check if a compartment shape is necessary which is used to contain the referenced nodes. We use mutlipleCompartments to check this necessity.*]
			[%var mutlipleCompartments = self.eClass().getCompartmentReferences().size() > 1;%]
			[*mutlipleCompartments = true means there are at least two TYPEs of contained reference that are annotated as compartment in self, therefore we allow to add compartment shapes to contain each type of contained reference*]
			[*If there is only one type of contained reference that are annotated as compartment in self, then there is no need to create a compartment shape*]
						
			[*The second condition for display compartment shape is the reference type has MORE THAN ONE instance. *]
			[*So we need to calculate the number of the instance for this type of reference in self*]
			[%var numOfRef=0;
			  for(refSeq in self.getReferenced()){
			  	for(ref in refSeq.at(0)) {
					if(ref.isNode() and ref.eClass = r.eType){
						numOfRef++;
					}
				}
			  }
			 var hasMultiRefIns=false;
			 if(numOfRef>1){
				hasMultiRefIns=true;
			 }%]
			
			[*When mutlipleCompartments is true, we also allow user to disable the present of the compartment shape through the annotation picto.compartment (visible = "false")*]
			[%
			compartmentVisible = r.getCompartmentVisibility().asBoolean();
	    	%]
			[%if(mutlipleCompartments and hasMultiRefIns and compartmentVisible) {%]
			[*if multipleCompartments, it means the package contains several types of picto.compartment elements, e.g., OrderedSet{objects, persons}, so that we need a {} for each type.
						
			here we give the left '{' for the compartment.
			If no multiple TYPES of compartment in self, then this If is not executed, there is no {}*]
				[%=r.getShape()%] "[%=r.name%]" as N_compartment_[%=r.name%][%if(r.getColor().isDefined() or r.getLineStyle().isDefined() or r.getLineColor().isDefined() or r.getTextColor().isDefined() ){%] #[%}%][%if(r.getColor().isDefined() and (r.getLineStyle().isDefined() or r.getLineColor().isDefined() or r.getTextColor().isDefined())){%][%=r.getColor()%];[%}%][%else {%][%=r.getColor()%][%}%][%=r.getLineStyle()%][%=r.getLineColor()%][%=r.getTextColor()%] {
			[%}%]
			
			[*Now we create the shape for each node by calling the operation createShape()*]
			[%for(refSeq in self.getReferenced()){
				for(ref in refSeq.at(0)) {
					if(ref.isNode() and ref.eClass = r.eType){
						ref.createShape();
					}
				}
			}%]
			
			[%if(mutlipleCompartments and hasMultiRefIns and compartmentVisible){%]
			[*this is the right } for the compartment*]
				}
			[%}%]
  	  	
	[%}%]
	[*this is the right } for the package*]
	}
[%}%]

[*Generate compartent nodes  as LINK.*]		
[*we allow to display a contained node (containment = true, referenced using 'val') outside its parent node (package), and linked by a directional edge*]
[%if(hasNestedNodeAsLink){%]
	[%for (r in self.eClass.eAllReferences.select(l|l.containment)){%]
		[%var containmentIsLink=false;
		  
 	  	  for(anno in r.eAnnotations.source){
				if(anno = "picto.link"){
	    			containmentIsLink= true;
				}
  		  }%]
		
		[%if(containmentIsLink){%][*containmentIsLink = true, means this 'r' is annotated as picto.link*]
			[*refSeq is the sequence of all the references of self, each refSeq has 2 members*]
			[%for(refSeq in self.getReferenced()){%]
				[%for(ref in refSeq.at(0)) {%] [*ref is the target of the link*]
					[%if(ref.isNode() and ref.eClass= r.eType){%]
						[%ref.createShape();%]
						[%=self.getNodeId()%] -[%=r.getLineThickness()%][%=r.getLinkDir()%]->[%=ref.getNodeId()%] [*next, to output #*][%if(r.getColor().isDefined() or r.getLineStyle().isDefined() or (getReferenceLabel(self, ref, refSeq.at(1)).isDefined() and r.getTextColor().isDefined())){%] #[%}%][*next, to output getColor With or Without ';'*][%if(r.getColor().isDefined() and (r.getLineStyle().isDefined() or (getReferenceLabel(self, ref, refSeq.at(1)).isDefined() and r.getTextColor().isDefined()))){%][%=r.getColor()%];[%}%][%else {%][%=r.getColor()%][%}%][%=r.getLineStyle()%][%if(getReferenceLabel(self, ref, refSeq.at(1)).isDefined()){%][%=r.getTextColor()%] : [%=getReferenceLabel(self, ref, refSeq.at(1))%]	[%}%]
					[%}%]
				[%}%]
			[%}%]
		[%}%]
	[%}%]
[%}%]
[%}%]